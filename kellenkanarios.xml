<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3564</fr:anchor><fr:addr
type="user">kellenkanarios</fr:addr><fr:route>kellenkanarios.xml</fr:route><fr:title
text="Kellen Kanarios">Kellen Kanarios</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta
name="external">https://kellenkanarios.github.io/</fr:meta><fr:meta
name="institution"><fr:link
type="external"
href="University%20of%20Michigan">University of Michigan</fr:link></fr:meta><fr:meta
name="position">PhD Student</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Contributions">Contributions</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3565</fr:anchor><fr:addr
type="user">kak-005D</fr:addr><fr:route>kak-005D.xml</fr:route><fr:title
text="Optimization from a Deep Learning Perspective">Optimization from a Deep Learning Perspective</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3567</fr:anchor><fr:addr
type="user">kak-004X</fr:addr><fr:route>kak-004X.xml</fr:route><fr:title
text="A Note on Advantage Estimation">A Note on Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:title
text="What is it?">What is it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:title
text="Why do we do it?">Why do we do it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:title
text="Generalized Advantage Estimation">Generalized Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3569</fr:anchor><fr:addr
type="user">kak-004I</fr:addr><fr:route>kak-004I.xml</fr:route><fr:title
text="Virtual Memory">Virtual Memory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In my foray into C programming, I have become thoroughly confused with virtual memory and the like. Mainly, what is malloc really doing? In the minimap2 library, they implement essentially their own memory management on top of malloc. The reason for this is what had me confused. I think the following summarizes my findings:
  <fr:ul><fr:li>When a process is started by the OS, it allocates virtual address space for the process.</fr:li>
    <fr:li>Within this virtual address space, malloc allocates memory on the heap. Namely, just returning a pointer (technically virtual address) to a block of memory of the desired size.</fr:li>
    <fr:ul><fr:li>Malloc is an OS system call and therefore stops execution of all threads.</fr:li>
      <fr:li>To get around this, they pre-allocate their own intra-thread memory (a large contiguous chunk) then allocate memory within this chunk throughout the program.</fr:li></fr:ul></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3571</fr:anchor><fr:addr
type="user">kak-004B</fr:addr><fr:route>kak-004B.xml</fr:route><fr:title
text="Information Theory">Information Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:title
text="Lecture 5">Lecture 5</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr
type="user">kak-004C</fr:addr><fr:route>kak-004C.xml</fr:route><fr:title
text="Convex set">Convex set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[C]]></fr:tex> is said to be convex if for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\lambda  x_1 + (1 - \lambda )x_2 \in  C]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr
type="user">kak-004D</fr:addr><fr:route>kak-004D.xml</fr:route><fr:title
text="Convex Function">Convex Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex
display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    This can be thought of as the tangent is always an underestimate of a convex function.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  This implies positive curvature or the common "bowl-shaped" interpretation.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Holds with equality if and only if 
    <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f]]></fr:tex> is linear on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a constant almost surely.</fr:li></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr
type="user">kak-004E</fr:addr><fr:route>kak-004E.xml</fr:route><fr:title
text="Gibb's inequality">Gibb's inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[D_{\mathrm {KL}}(P || Q) \geq  0]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Note that 
<fr:tex
display="block"><![CDATA[ \begin {align*}  D_{\mathrm {KL}}(P || Q) &= \mathbb {E}_P \left [\log \left (\frac {P(x)}{Q(x)}\right )\right ] \\ &= \mathbb {E}_P \left [-\log \left (\frac {Q(x)}{P(x)}\right )\right ] \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-002G.xml"
addr="kak-002G"
title="Jensen's Inequality">Jensen's Inequality</fr:link>,
<fr:tex
display="block"><![CDATA[   \begin {align*}     D_{\mathrm {KL}}(P || Q) &\geq  -\log  \left (\mathbb {E}_P \left [\frac {Q(x)}{P(x)}\right ]\right ) = 0   \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  When is <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q) = 0]]></fr:tex>?
</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Need <fr:tex
display="inline"><![CDATA[Q(x) / P(x)]]></fr:tex> to be constant almost surely. This occurs only when <fr:tex
display="inline"><![CDATA[Q = P]]></fr:tex>. 
    <fr:tex
display="block"><![CDATA[         Q(x) / P(x) = c \implies  Q(x) = P(x) c \iff  \sum  Q(x) = c \sum  P(x) \implies  c = 1       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:strong>Applications of <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[I(X; Y) \geq  0]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X | Y) \leq  H(X)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X^n) \leq  \sum _{i = 1}^n H(X_i)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X) \leq  \log  |\mathcal {X}|]]></fr:tex></fr:li></fr:ul>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">kak-004F</fr:addr><fr:route>kak-004F.xml</fr:route><fr:title
text="Log-Sum Inequality">Log-Sum Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[a_{i},b_{i}>0]]></fr:tex> for <fr:tex
display="inline"><![CDATA[i\in \{1,\ldots ,n\}]]></fr:tex>; <fr:tex
display="inline"><![CDATA[A=\sum _{i=1}^{n}a_{i},\quad  B=\sum _{i=1}^{n}b_{i}]]></fr:tex>
Then, we have: <fr:tex
display="inline"><![CDATA[\sum _{i=1}^{n}a_{i}\log  a_{i}/b_{i}\geq  A\log  A/B]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Define <fr:tex
display="inline"><![CDATA[p_i = \frac {a_i}{A}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[q_i = \frac {b_i}{B}]]></fr:tex>, then 
<fr:tex
display="block"><![CDATA[ \begin {align*}   D_{\mathrm {KL}}(p || q) &= \sum  \frac {a_i}{A} \log {\frac {B a_i}{A b_i}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \sum  \frac {a_i}{A} \log {\frac {A}{B}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>,
<fr:tex
display="block"><![CDATA[ \begin {align*}   \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \geq  0   &\implies    \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} \geq  \log {\frac {A}{B}} \\   &\iff    A \sum  a_i \log {\frac {a_i}{b_i}} \geq  A \log {\frac {A}{B}} \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:strong>Consequences of <fr:link
type="local"
href="kak-004F.xml"
addr="kak-004F"
title="Log-Sum Inequality">Log-Sum Inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li>Joint convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>,</fr:li>
      <fr:li>Individual convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>.</fr:li>
      <fr:li>Concavity of entropy.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:title
text="Lecture 7">Lecture 7</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr
type="user">kak-004Y</fr:addr><fr:route>kak-004Y.xml</fr:route><fr:title
text="Maximum Aposteriori Estimator">Maximum Aposteriori Estimator</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The optimal estimator <fr:tex
display="inline"><![CDATA[g^* : \mathcal {Y} \to  \mathcal {X}]]></fr:tex> is
<fr:tex
display="block"><![CDATA[ \begin {align*}   g*(y) = \arg \max _{x \in  \mathcal {X}} P_{X | Y}(x | y) \end {align*} ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr
type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that
<fr:tex
display="block"><![CDATA[     \begin {align*}       P_{e}(g) &= \sum _{x}\sum _y P_{XY}(x, y) \cdot  \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) \sum _{x} P_{X|Y}(x|y) \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) (1 - P_{X|Y}(g(y)|y)) \\     \end {align*} ]]></fr:tex>
To minimize this, we take
<fr:tex
display="block"><![CDATA[   \begin {align*}     g^*(y) = \arg \max _{x} P_{X|Y}(x | y)   \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    High-level
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[Y]]></fr:tex> contains more information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> than <fr:tex
display="inline"><![CDATA[\hat {X}]]></fr:tex>.</fr:li>
        <fr:li>We cannot increase the amount of information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> by processing <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:li></fr:ul>
    <fr:strong>Markov Chains:</fr:strong>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[(U, V, W)]]></fr:tex> form a Markov chain if
        <fr:tex
display="block"><![CDATA[ \begin {align*}   P(W = w \mid  U = u, V = v) = P(w = w \mid  V = v) \end {align*}           ]]></fr:tex>
Denoted <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>.</fr:li>
          <fr:li>Equivalently, we say <fr:tex
display="inline"><![CDATA[(U \perp  W) | V]]></fr:tex> which means <fr:tex
display="block"><![CDATA[              P(W = w, U=u \mid  V = v) \implies  P(W = w \mid  V = v)P(U = u \mid  V = v)           ]]></fr:tex></fr:li>
          <fr:li>Reversibility: <fr:tex
display="inline"><![CDATA[U \to  V \to  W \iff  W \to  V \to  U]]></fr:tex>.</fr:li>
          <fr:li>Estimation: <fr:tex
display="inline"><![CDATA[X \to  Y \to  \hat {X}]]></fr:tex></fr:li></fr:ul> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr
type="user">kak-004Z</fr:addr><fr:route>kak-004Z.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[I(U; W) \leq  I(U; V)]]></fr:tex>.</fr:p><fr:p><fr:strong>Intuition:</fr:strong> by data processing, we can never create new information about <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Use chain rule to expand <fr:tex
display="inline"><![CDATA[I(U; (V, W))]]></fr:tex> in two ways i.e. 
<fr:tex
display="block"><![CDATA[   \begin {align*}     I(U; (V, W)) = I(U; V) + I(U; W | V) = I(U; W) + I(U; V | W)   \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex> is a Markov chain, <fr:tex
display="inline"><![CDATA[I(U; W | V) = 0]]></fr:tex>. Therefore,
<fr:tex
display="block"><![CDATA[ \begin {align*}   I(U; V)  &= I(U; W) + I(U; V | W) \\ &\geq  I(U; W) \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[H(X | Y)]]></fr:tex> controls the error probability <fr:tex
display="inline"><![CDATA[P_e]]></fr:tex>.</fr:li></fr:ul>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:addr
type="user">kak-0050</fr:addr><fr:route>kak-0050.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[X \iff  Y \iff  \hat {X}]]></fr:tex> and let <fr:tex
display="inline"><![CDATA[p_e = \mathbb {P}(X \neq  \hat {X})]]></fr:tex>. Then, we have 
  <fr:tex
display="block"><![CDATA[       \begin {align*}         H(p_e) + p_e \log (|\mathcal {X}| - 1) \geq  H(X \mid  \hat {X}) \geq  H(X \mid  Y)       \end {align*}     ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:addr
type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:title
text="Asymptotic Equipartion Propery">Asymptotic Equipartion Propery</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>535</fr:anchor><fr:addr
type="user">kak-0051</fr:addr><fr:route>kak-0051.xml</fr:route><fr:title
text="Weak Law of Large Numbers">Weak Law of Large Numbers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[\frac {1}{n}\sum _{i=1}^{n}X_{i}\stackrel {{p}}{{\rightarrow }}\mu ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    By <fr:link
type="local"
href="kak-002F.xml"
addr="kak-002F"
title="Chebyshev's Inequality">Chebyshev's Inequality</fr:link>,
    <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}(|\hat {X} - \mu | > a) \leq  -\frac {\sigma ^2}{a^2}     \end {align*}     ]]></fr:tex>
    Since <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex>'s are independent, 
<fr:tex
display="block"><![CDATA[\mathrm {Var}[\hat {X}] = \frac {1}{n^2} \sum _{i = 1}^{n} \mathrm {Var}[X_i]]]></fr:tex>
    Therefore,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \lim _{n \to  \infty } \mathbb {P}(|\hat {X} - \mu | > a) \leq  \lim _{n \to  \infty }-\frac {\sigma ^2}{n a^2} \to  0     \end {align*} ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr
type="user">kak-0052</fr:addr><fr:route>kak-0052.xml</fr:route><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> be any function, such that <fr:tex
display="inline"><![CDATA[\mathrm {Var}(f(X))=\sigma _{f}^{2}<\infty ]]></fr:tex>. Then,
<fr:tex
display="block"><![CDATA[\frac {1}{n} \sum _{i = 1}^{n} f(X_i) \stackrel {p}{\rightarrow } \mathbb {E}[f(X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:addr
type="user">kak-0053</fr:addr><fr:route>kak-0053.xml</fr:route><fr:title
text="Continuous Mapping Theorem">Continuous Mapping Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_{n}\stackrel {{p}}{{\rightarrow }}X]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> denote a continuous function. Then,
<fr:tex
display="block"><![CDATA[f(X_n) \stackrel {p}{\rightarrow } f(X)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:addr
type="user">kak-0054</fr:addr><fr:route>kak-0054.xml</fr:route><fr:title
text="AEP Theorem">AEP Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex> denote i.i.d. <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with distribution <fr:tex
display="inline"><![CDATA[P_{X}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[ \begin {align*}  \lim _{n\to \infty }-\frac {1}{n}\log  p_{X^{n}}(X_{1},\ldots ,X_{n}) &= \lim _{n \to  \infty } -\frac {1}{n} \log  \prod _{i = 1}^{n} P_X(X_i) \\  &= \mathbb {E}_{X \sim  p_X}[-\log  p_X(X)] \\   &= H(X) \end {align*} ]]></fr:tex>
Equivalently, for large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>
<fr:tex
display="block"><![CDATA[   \begin {align*}     \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon    \end {align*} ]]></fr:tex>
with high probability.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>540</fr:anchor><fr:addr
type="user">kak-0055</fr:addr><fr:route>kak-0055.xml</fr:route><fr:title
text="-Typical set"><fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Fix an <fr:tex
display="inline"><![CDATA[\epsilon >0]]></fr:tex>. Then, an <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set with respect to the pmf <fr:tex
display="inline"><![CDATA[p_{X}]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}]]></fr:tex>, is defined as
<fr:tex
display="block"><![CDATA[\left \{X^n \in  \mathcal {X}^n \mid  \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon  \right \}]]></fr:tex>
Alternatively,
<fr:tex
display="block"><![CDATA[A_{\epsilon ^{(n)}} = \left \{X^n \in  \mathcal {X}^n \mid  2^{-n(H(X) + \epsilon )} \leq  p_{X^n}(X^n) \leq  2^{-n(H(X) - \epsilon )}\right \}]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  We have the following important properties
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)})\geq 1-\epsilon {\text { for large enough }}n]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{c}^{(n)}|\leq 2^{n(H(X)+\epsilon )}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{\epsilon }^{(n)}|\geq (1-\epsilon )2^{n(H(X)-\epsilon )}\;\text {for large enough }\;n\;,]]></fr:tex></fr:li></fr:ol>
    Together, this says that, depending on the entropy, the typical set can contain most of the probability despite being much smaller than the entire space.
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>interpretation:</fr:strong> <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}\,\text { is a subset of }\,{\mathcal {X}}^{n}]]></fr:tex>
<fr:ul><fr:li>Contains almost all the probability.</fr:li>
    <fr:li>Consists of <fr:tex
display="inline"><![CDATA[\approx  2^{nH(X)}]]></fr:tex></fr:li>
    <fr:li>Almost equiprobable sequences.</fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:addr
type="user">kak-0056</fr:addr><fr:route>kak-0056.xml</fr:route><fr:title
text="High probability sets">High probability sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[B_{\epsilon }^{(n)}\subset \mathcal {X}^{n}]]></fr:tex> be the smallest set with probability at least <fr:tex
display="inline"><![CDATA[1-\epsilon ]]></fr:tex>. Then, we must have

<fr:tex
display="block"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)}\cap  B_{\epsilon }^{(n)})\geq 1-2\epsilon ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:addr
type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:title
text="Fixed-rate lossless source coding">Fixed-rate lossless source coding</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr
type="user">kak-0059</fr:addr><fr:route>kak-0059.xml</fr:route><fr:title
text="Coding system">Coding system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A coding system with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> consist of an encoder and a decoder, where an encoder is a function
<fr:tex
display="block"><![CDATA[   e: \mathcal {X}^n \to  \{1, 2, \ldots , \theta \} ]]></fr:tex>
and a decoder is a function 
<fr:tex
display="block"><![CDATA[f: \{1, 2, \ldots , \theta \} \to  \mathcal {X}^n]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Performance:</fr:strong>
    <fr:ul><fr:li>Rate = <fr:tex
display="inline"><![CDATA[\frac {\log _2 \theta }{n}]]></fr:tex></fr:li>
        <fr:li>Probability of decoding error = <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n|]]></fr:tex></fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr
type="user">kak-005A</fr:addr><fr:route>kak-005A.xml</fr:route><fr:title
text="Achievability">Achievability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex> (perturbation parameter) there exists a block length <fr:tex
display="inline"><![CDATA[N(\epsilon )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\forall  n > N(\epsilon )]]></fr:tex> the following holds
<fr:ul><fr:li>There exists an <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding system</fr:link> such that <fr:tex
display="inline"><![CDATA[\frac {\log  \theta }{n} < R + \epsilon ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n| < \epsilon ]]></fr:tex>.</fr:li></fr:ul></fr:p><fr:p>Alternatively, a positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if there exists a sequence of <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding systems</fr:link> <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log  \theta }{n} \to  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \mathbb {P}|\hat {X}^n \neq  X^n| \to  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr
type="user">kak-005B</fr:addr><fr:route>kak-005B.xml</fr:route><fr:title
text="Minimum rate of source coding">Minimum rate of source coding</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>minimum rate of source coding</fr:em> <fr:tex
display="inline"><![CDATA[R_s]]></fr:tex> is the infimum over all <fr:tex
display="inline"><![CDATA[R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link> i.e.  
<fr:tex
display="block"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr
type="user">kak-005C</fr:addr><fr:route>kak-005C.xml</fr:route><fr:title
text="Entropy as MRSC">Entropy as <fr:link
type="local"
href="kak-005B.xml"
addr="kak-005B"
title="Minimum rate of source coding">MRSC</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[R_s = H(P_X) = H(X) = -\sum _{x \in  \mathcal {X}} P_X(x) \log  P_X(x)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>497</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>First we will show that <fr:tex
display="inline"><![CDATA[H(X)]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. Then we will have <fr:tex
display="inline"><![CDATA[R_s \leq  H(X)]]></fr:tex> by definition. Idea: take <fr:tex
display="inline"><![CDATA[\theta  = 2^{n(H(X) + \epsilon )} + 1]]></fr:tex>. Give each element in typical set a unique index, everything else the same index. By properties of typical set, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\text {error}) < \epsilon ]]></fr:tex> for sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</fr:p>
  <fr:p>For the other direction, suppose we have some <fr:tex
display="inline"><![CDATA[R]]></fr:tex> <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. By definition, for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, for all sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex> there exists a [kak-0059] with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that
<fr:tex
display="block"><![CDATA[         \begin {align*}           \frac {\log  \theta }{n} < R + \epsilon , \quad  \mathbb {P}(\text {error}) < \epsilon          \end {align*}       ]]></fr:tex>
      Use <fr:link
type="local"
href="kak-0050.xml"
addr="kak-0050"
title="Fano's Inequality">Fano's Inequality</fr:link> to show this is not possible.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3573</fr:anchor><fr:addr
type="user">kak-004G</fr:addr><fr:route>kak-004G.xml</fr:route><fr:title
text="Self-Attention">Self-Attention</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>TLDR: Learned weighting of token embeddings. Essentially, learning which words to "attend" to in the input sequence. Have matrices
<fr:tex
display="inline"><![CDATA[\mathbf {Q} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {q}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {q}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_q}]]></fr:tex>, 
<fr:tex
display="inline"><![CDATA[ \mathbf {K} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {k}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {k}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_k} ]]></fr:tex>
<fr:tex
display="inline"><![CDATA[ \mathbf {V} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_v} ]]></fr:tex></fr:p><fr:p><fr:strong>Intuition 1:</fr:strong> Convex re-weighting of input tokens.
  Note that
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_1 & p_2 & p_3   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} = p_1 \mathbf {v}^{(1)} + p_2 \mathbf {v}^{(2)} + p_3 \mathbf {v}^{(3)} \end {align*}   ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_{11} & 0 & 0 \\     p_{21} & p_{22} & 0 \\     p_{31} & p_{32} & p_{33}   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} =    \begin {bmatrix}   p_{11} \mathbf {v}^{(1)}  \\   p_{21} \mathbf {v}^{(1)} + p_{22} \mathbf {v}^{(2)} \\   p_{31} \mathbf {v}^{(1)} + p_{32} \mathbf {v}^{(2)} + p_{33} \mathbf {v}^{(3)}   \end {bmatrix} \end {align*}   ]]></fr:tex>
  <fr:strong>Intuition 2:</fr:strong> Context dependent re-weighting.
      If <fr:tex
display="inline"><![CDATA[\mathbf {p} = \mathbb {S}(\mathbf {Q} \mathbf {K}^T)]]></fr:tex> then
      <fr:tex
display="block"><![CDATA[         \begin {align*}           p_{ij} = \frac {\mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}{\sum _{j} \mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}         \end {align*}       ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Suppose that <fr:tex
display="inline"><![CDATA[\mathbf {x} = \text {I play with the ball}]]></fr:tex>. Then 
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``ball"})     \end {align*}   ]]></fr:tex>
  A feasible query for "ball" would be a verb describing the action of the ball, so maybe
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_q \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``play"})   \end {align*}   ]]></fr:tex>
  and a key for "play" would be what you are playing with like a ball, so 
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_k \mathbf {x}^{(2)} = \mathrm {Embed}(\text {``ball"})   \end {align*}   ]]></fr:tex>
  i.e.
<fr:tex
display="block"><![CDATA[   \begin {align*}     \mathrm {Query}(\text {``quantum"}) \cdot  \mathrm {Key}(\text {``mechanics"}) \approx      ||\mathrm {Query}(\text {``quantum"})|| \cdot  ||\mathrm {Key}(\text {``mechanics"})||   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
 
<fr:p><fr:tex
display="block"><![CDATA[   \begin {align*} \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} &= \mathbb {S}\left (\begin {bmatrix} \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(1)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(2)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(3)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(4)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(5)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(6)} \end {bmatrix} \right ) \\ &= \begin {bmatrix} 0 & 0.2 & 0.3 & 0.5 & 0 & 0 \end {bmatrix}   \end {align*} ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} \mathbf {V} = 0.2 \mathbf {v}^{(2)} + 0.3 \mathbf {v}^{(3)} + 0.5 \mathbf {v}^{(5)} ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3575</fr:anchor><fr:addr
type="user">crlr1</fr:addr><fr:route>crlr1.xml</fr:route><fr:title
text="Contrastive Learning as Goal Conditioned RL + Deepseek R1">Contrastive Learning as Goal Conditioned RL + Deepseek R1</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/clrl-r1.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3577</fr:anchor><fr:addr
type="user">rlhf</fr:addr><fr:route>rlhf.xml</fr:route><fr:title
text="Reinforcement Learning from Human Feedback">Reinforcement Learning from Human Feedback</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/RLHF-Group-Meeting.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3579</fr:anchor><fr:addr
type="user">kak-003Z</fr:addr><fr:route>kak-003Z.xml</fr:route><fr:title
text="Stochastic Processes">Stochastic Processes</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:title
text="Markov Chains">Markov Chains</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>578</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:title
text="Definitions">Definitions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>580</fr:anchor><fr:addr
type="user">kak-0040</fr:addr><fr:route>kak-0040.xml</fr:route><fr:title
text="Markov Chain">Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say a stochastic process <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> is a Markov chain (MC) with transition matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> if for any <fr:tex
display="inline"><![CDATA[n \in  \mathcal {N}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{0}, \ldots  x_{n - 1}]]></fr:tex>
  <fr:tex
display="block"><![CDATA[ 		\mathbb {P}(X_{n + 1} = y \mid  X_{n} = x, X_{n - 1} = x_{n - 1}, \ldots , X_0 = x_0) = \mathbb {P}(X_{n + 1} = y \mid  X_n = x) = p(x, y)   ]]></fr:tex>
	whenever conditional probability is well-defined. 
	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>581</fr:anchor><fr:addr
type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Moreover, any matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[\sum _{y \in  \mathcal {S}} p(x, y) = 1]]></fr:tex> is called a stochastic matrix. Given any stochastic matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, one can create a MC.
</fr:mainmatter><fr:backmatter /></fr:tree>

	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>582</fr:anchor><fr:addr
type="machine">#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
		This is called a temporally homogeneous discrete Markov chain because <fr:tex
display="inline"><![CDATA[p]]></fr:tex> does not depend on time.
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>583</fr:anchor><fr:addr
type="user">kak-0041</fr:addr><fr:route>kak-0041.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th step transition probability <fr:tex
display="inline"><![CDATA[\mathbb {P}(X_{n + m} = y \mid  X_{n} = x)]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th power of transition matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, computed at <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>584</fr:anchor><fr:addr
type="user">kak-0042</fr:addr><fr:route>kak-0042.xml</fr:route><fr:title
text="Chapman-Kolmogorov Equation">Chapman-Kolmogorov Equation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[p^{m + n}(x,y) = \sum _{z \in  S} p^{m}(x,z) p^{n}(z,y)]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>585</fr:anchor><fr:addr
type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Note that
<fr:tex
display="block"><![CDATA[       \begin {align*}         p^{m + n}(x, y) &= \mathbb {P}(X_{m+n} = y \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y, X_{m} = z \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z, X_{0} = x) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} p^{n}(z, y) p^{m}(x, z)       \end {align*}     ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>586</fr:anchor><fr:addr
type="user">kak-0043</fr:addr><fr:route>kak-0043.xml</fr:route><fr:title
text="Stopping time">Stopping time</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[T : \Omega  \to  \mathbb {N} \cup  \{\infty \}]]></fr:tex> is a stopping time with respect to <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\{T = k\}]]></fr:tex> can be determined by <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{k}\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>587</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:title
text="Classification of States">Classification of States</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>589</fr:anchor><fr:addr
type="user">kak-0044</fr:addr><fr:route>kak-0044.xml</fr:route><fr:title
text="Strong Markov Property">Strong Markov Property</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> be a stopping time with respect to <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>, given <fr:tex
display="inline"><![CDATA[\{T < \infty , X_{T} = x\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X_{T + k}]]></fr:tex> is independent of <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{T}\}]]></fr:tex>. Moreover, 
<fr:tex
display="block"><![CDATA[\mathbb {P}(X_{T + k} \mid  T < \infty , X_T = x) = p^k(x,y)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>590</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  TODO
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>591</fr:anchor><fr:addr
type="user">kak-0045</fr:addr><fr:route>kak-0045.xml</fr:route><fr:title
text="Transient and recurrent states">Transient and recurrent states</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex> is recurrent if <fr:tex
display="inline"><![CDATA[\rho _{xx} = 1]]></fr:tex> and transient if <fr:tex
display="inline"><![CDATA[\rho _{xx} < 1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>592</fr:anchor><fr:addr
type="user">kak-0048</fr:addr><fr:route>kak-0048.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say <fr:tex
display="inline"><![CDATA[T_y]]></fr:tex> is a return time if <fr:tex
display="inline"><![CDATA[T_y = \inf  \{n \geq  1 \mid  X_n = y\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\rho _{xy} = \mathbb {P}(T_y < \infty )]]></fr:tex>. We write the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th return time as 
	<fr:tex
display="block"><![CDATA[T_{y}^{k} = \min  \{n > T_y^{k - 1} \mid  X_{n} = y\}]]></fr:tex>
  with <fr:tex
display="inline"><![CDATA[T_y^{1} \coloneqq  T_{y}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>593</fr:anchor><fr:addr
type="user">kak-0046</fr:addr><fr:route>kak-0046.xml</fr:route><fr:title
text="Communicates">Communicates</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x]]></fr:tex> communicates with <fr:tex
display="inline"><![CDATA[y]]></fr:tex> and denote it by <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\rho _{xy} > 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>594</fr:anchor><fr:addr
type="user">kak-0047</fr:addr><fr:route>kak-0047.xml</fr:route><fr:title
text="Transitivity of communcation">Transitivity of communcation</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	If <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y \to  z]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[x \to  z]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>595</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	By assumption, there exists <fr:tex
display="inline"><![CDATA[m, n \leq  t]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[p^{m}(x,y) > 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[p^n(y,z) > 0]]></fr:tex>. Then 
  <fr:tex
display="block"><![CDATA[ 	\begin {align*} 		p^{m + n}(x, z) &= \sum _{k \in  S} p^{m}(x, k)p^{n}(k,z) \\ 										&\geq  p^{m}(x,y)p^{n}(y,z) \quad  \quad  (\text {Strong Markov})\\  										&> 0 	\end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>596</fr:anchor><fr:addr
type="user">kak-0049</fr:addr><fr:route>kak-0049.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Suppose <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_{y} \leq  k) \geq  a > 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_y \geq  mk) \leq  (1-a)^m]]></fr:tex>, <fr:tex
display="inline"><![CDATA[m \in  \mathbb {N}]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>597</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Define <fr:tex
display="inline"><![CDATA[X_{n}^{(1)} = X_{k + n}, \ldots , X_{n}^{(m-1)} = X_{(m-1)k + n}]]></fr:tex>. Then define <fr:tex
display="inline"><![CDATA[T_{y}^{(1)}, \ldots , T_{y}^{(m-1)}]]></fr:tex> as the corresponding hitting times of state <fr:tex
display="inline"><![CDATA[y]]></fr:tex>. We have
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}_x(T_y > km) &= \mathbb {P}_{x}(T_y > k, T_y^{(1)} > k, \ldots , T_y^{(m-1)} > k) \\                             &\leq  \mathbb {P}_x(T_y > k, \ldots , T_y^{(m-1)} > k \mid  X_{k} \neq  y, \ldots , X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}_{x}(T_y > k)\mathbb {P}_x(T_y^{(1)} > k \mid  X_{k} \neq  y) \cdots  \mathbb {P}_x(T_y^{(m-1)} > k \mid  X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}(T_y > k)\left (\sum _{z \neq  y}\underbrace {\mathbb {P}_z(T_y > k)}_{\leq  (1-a)} \mathbb {P}_x(X_{k} = z \mid  X_{k} \neq  y)\right ) \\                             &\leq  (1-a)^{m}\underbrace {\sum _{z \neq  y}\mathbb {P}_x \left (X_k = z \mid  X_k \neq   y \right )}_{=1}     \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr
type="user">kak-0058</fr:addr><fr:route>kak-0058.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a finite closed and irreducible set, then all states in <fr:tex
display="inline"><![CDATA[C]]></fr:tex> are recurrent.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>599</fr:anchor><fr:addr
type="user">kak-0057</fr:addr><fr:route>kak-0057.xml</fr:route><fr:title
text="Decomposition Theorem">Decomposition Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is finite, then <fr:tex
display="inline"><![CDATA[S]]></fr:tex> can be written as a disjoint union <fr:tex
display="inline"><![CDATA[T\cup  R_{1}\cup \cdots \cup  R_{k}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[T]]></fr:tex> is a set of transient states and the <fr:tex
display="inline"><![CDATA[R_{i},\ 1\leq  i\leq  k]]></fr:tex>, are closed irreducible sets of recurrent states.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3581</fr:anchor><fr:addr
type="user">kak-003Y</fr:addr><fr:route>kak-003Y.xml</fr:route><fr:title
text="The History and Evolution of Policy Gradient Algorithms">The History and Evolution of Policy Gradient Algorithms</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Rough itinerary,
  <fr:ul><fr:li>Vanilla policy gradient
      <fr:ul><fr:li>Policy gradient theorem + proof</fr:li>
          <fr:li>Deterministic policy gradient theorem + (maybe)proof</fr:li></fr:ul></fr:li>
      <fr:li>Actor critic method
      <fr:ul><fr:li>A2C: Variance reduction method</fr:li>
        <fr:li>(Maybe) A3C: Asynchronous update</fr:li></fr:ul></fr:li>
      <fr:li>Trust region policy optimization</fr:li>
      <fr:li>Soft Actor Critic</fr:li>
      <fr:li><fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">Proximal Policy Optimization</fr:link></fr:li>
      <fr:li><fr:link
type="local"
href="kak-003X.xml"
addr="kak-003X"
title="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:link></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3583</fr:anchor><fr:addr
type="user">kak-003U</fr:addr><fr:route>kak-003U.xml</fr:route><fr:title
text="Threads on the hardware level">Threads on the hardware level</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>28</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I have been wondering how multithreading is actually implemented on the hardware level. Here, I summarize my findings:
<fr:ul><fr:li>Threads have their own program counter and can fetch and decode instructions in parallel.</fr:li>
    <fr:li>Threads have their own registers, but <fr:strong>share</fr:strong> most execution resources i.e. memory, ALU, etc.</fr:li>
    <fr:li>Thread instructions are scheduled just as typical instructions to maximize throughput.</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3585</fr:anchor><fr:addr
type="user">kak-003D</fr:addr><fr:route>kak-003D.xml</fr:route><fr:title
text="Deepseek v1 through R1: RL is back!">Deepseek v1 through R1: RL is back!</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog, we will aim to understand the key contributions of <fr:link
type="local"
href="deepseekai2025deepseekr1incentivizingreasoningcapability.xml"
addr="deepseekai2025deepseekr1incentivizingreasoningcapability"
title="DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning">DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning</fr:link>. It will serve as the complement to my group meeting presentation possibly consisting of more in-depth explanations. Time permitting, we might go over the engineering innovations introduced in <fr:link
type="local"
href="deepseekai2024deepseekv3technicalreport.xml"
addr="deepseekai2024deepseekv3technicalreport"
title="DeepSeek-V3 technical report">DeepSeek-V3 technical report</fr:link>.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:title
text="Background">Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    By request of my advisor, I will cover the basics of LLMs prior to the innovations in the Deepseek lineage. For those familiar with LLMs, please skip this section.
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">kak-004J</fr:addr><fr:route>kak-004J.xml</fr:route><fr:title
text="Word Embeddings">Word Embeddings</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tex
display="block"><![CDATA[\mathrm {Tok}(\mathbf {x})=\begin {bmatrix} 132\\ 17 \\ 87\\ 83\\ 184\end {bmatrix}]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>465</fr:anchor><fr:addr
type="user">kak-004G</fr:addr><fr:route>kak-004G.xml</fr:route><fr:title
text="Self-Attention">Self-Attention</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>TLDR: Learned weighting of token embeddings. Essentially, learning which words to "attend" to in the input sequence. Have matrices
<fr:tex
display="inline"><![CDATA[\mathbf {Q} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {q}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {q}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_q}]]></fr:tex>, 
<fr:tex
display="inline"><![CDATA[ \mathbf {K} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {k}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {k}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_k} ]]></fr:tex>
<fr:tex
display="inline"><![CDATA[ \mathbf {V} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_v} ]]></fr:tex></fr:p><fr:p><fr:strong>Intuition 1:</fr:strong> Convex re-weighting of input tokens.
  Note that
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_1 & p_2 & p_3   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} = p_1 \mathbf {v}^{(1)} + p_2 \mathbf {v}^{(2)} + p_3 \mathbf {v}^{(3)} \end {align*}   ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_{11} & 0 & 0 \\     p_{21} & p_{22} & 0 \\     p_{31} & p_{32} & p_{33}   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} =    \begin {bmatrix}   p_{11} \mathbf {v}^{(1)}  \\   p_{21} \mathbf {v}^{(1)} + p_{22} \mathbf {v}^{(2)} \\   p_{31} \mathbf {v}^{(1)} + p_{32} \mathbf {v}^{(2)} + p_{33} \mathbf {v}^{(3)}   \end {bmatrix} \end {align*}   ]]></fr:tex>
  <fr:strong>Intuition 2:</fr:strong> Context dependent re-weighting.
      If <fr:tex
display="inline"><![CDATA[\mathbf {p} = \mathbb {S}(\mathbf {Q} \mathbf {K}^T)]]></fr:tex> then
      <fr:tex
display="block"><![CDATA[         \begin {align*}           p_{ij} = \frac {\mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}{\sum _{j} \mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}         \end {align*}       ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Suppose that <fr:tex
display="inline"><![CDATA[\mathbf {x} = \text {I play with the ball}]]></fr:tex>. Then 
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``ball"})     \end {align*}   ]]></fr:tex>
  A feasible query for "ball" would be a verb describing the action of the ball, so maybe
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_q \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``play"})   \end {align*}   ]]></fr:tex>
  and a key for "play" would be what you are playing with like a ball, so 
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_k \mathbf {x}^{(2)} = \mathrm {Embed}(\text {``ball"})   \end {align*}   ]]></fr:tex>
  i.e.
<fr:tex
display="block"><![CDATA[   \begin {align*}     \mathrm {Query}(\text {``quantum"}) \cdot  \mathrm {Key}(\text {``mechanics"}) \approx      ||\mathrm {Query}(\text {``quantum"})|| \cdot  ||\mathrm {Key}(\text {``mechanics"})||   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
 
<fr:p><fr:tex
display="block"><![CDATA[   \begin {align*} \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} &= \mathbb {S}\left (\begin {bmatrix} \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(1)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(2)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(3)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(4)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(5)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(6)} \end {bmatrix} \right ) \\ &= \begin {bmatrix} 0 & 0.2 & 0.3 & 0.5 & 0 & 0 \end {bmatrix}   \end {align*} ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} \mathbf {V} = 0.2 \mathbf {v}^{(2)} + 0.3 \mathbf {v}^{(3)} + 0.5 \mathbf {v}^{(5)} ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:addr
type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:title
text="RLHF">RLHF</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tex
display="block"><![CDATA[\mathrm {loss}\left (\phi \right )=E_{\left (x,y\right )\sim  D_{\pi _{\phi }^{\mathrm {RL}}}}\left [r_\theta (x,y)-\beta \log \left (\pi _{\phi }^{\mathrm {RL}}(y\mid  x)/\pi ^{\mathrm {SFT}}(y\mid  x)\right )\right ] + \gamma  E_{x\sim  D_{\mathrm {pretrain}}}\left [\log (\pi _{\phi }^{\mathrm {RL}}(x))\right ]]]></fr:tex>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:title
text="Deepseek v2">Deepseek v2</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Paper 
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:title
text="Deepseek v3">Deepseek v3</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
TODO. Kinda wanna look into the architectural / training innovations from this paper.
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr
type="machine">#308</fr:addr><fr:route>unstable-308.xml</fr:route><fr:title
text="Deepseek R1">Deepseek R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:addr
type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:title
text="How is R1 different then previous iterations of models?">How is R1 different then previous iterations of models?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>In R1-Zero, they do <fr:strong>ZERO</fr:strong> SFT on the base model - directly apply reinforcement learning.</fr:li>
    <fr:li>Use PPO like policy optimization but do <fr:strong>NOT</fr:strong> learn a reward model.</fr:li>
    <fr:ul><fr:li>Use very simple reward: 
        <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[+1]]></fr:tex> for correct answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-0.5]]></fr:tex> for incorrect answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-1]]></fr:tex> for inability to answer.</fr:li></fr:ul></fr:li></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:addr
type="user">kak-003X</fr:addr><fr:route>kak-003X.xml</fr:route><fr:title
text="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Traditional actor critic RL algorithms, require training both an actor and a critic (as the name implies). Typically, these components are both of equal size. In the field of RL, this is non-problematic because models are typically rather small (at least in comparison to LLMs).
In <fr:link
type="local"
href="shao2024deepseekmathpushinglimitsmathematical.xml"
addr="shao2024deepseekmathpushinglimitsmathematical"
title="DeepSeekMath: Pushing the limits of mathematical reasoning in open language models">DeepSeekMath: Pushing the limits of mathematical reasoning in open language models</fr:link></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>480</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:title
text="Math">Math</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tex
display="block"><![CDATA[     \begin {align*}     {\mathcal {J}}_{\mathrm {GRPO}}(\theta )&= \mathbb {E}[q\sim  P(Q),\{o_{i}\}_{i=1}^{G}\sim \pi _{\theta _{o l d}}(O|q)] \\     &= \frac {1}{G}\sum _{i=1}^{G}\left (\operatorname *{min}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d}}(o_{i}|q)}A_{i},\operatorname *{clip}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d d}}(o_{i}|q)},1-\varepsilon ,1+\varepsilon \right )A_{i}\right )-\beta \mathbb {D}_{K L}\left (\pi _{\theta }||\pi _{r e f}\right )\right )     \end {align*}   ]]></fr:tex>
  where
  <fr:tex
display="block"><![CDATA[         \mathbb {D}_{\mathrm {K L}}\left (\pi _{\theta }||\pi _{\mathrm {ref}}\right )=\frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-\log \frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-1     ]]></fr:tex>
    The astute RL reader will notice this is essentially <fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">PPO</fr:link>.
    The key distinction here is that the advantage <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> is not computed using a critic model. Instead, 
<fr:tex
display="block"><![CDATA[A_{i}=\frac {r_{i}-\mathrm {mean}(\{r_{1},r_{2},\cdots ,r_{G}\})}{\mathrm {std}(\{r_{1},r_{2},\cdots ,r_{G}\})}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:addr
type="machine">#306</fr:addr><fr:route>unstable-306.xml</fr:route><fr:title
text="Post-training">Post-training</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:em>Reinforcement Learning for all Scenarios:</fr:em> Seems like they do RLHF after the pure RL stage.</fr:li>
        <fr:ul><fr:li>Do traditional helpfulness harmfulness RLHF with trained reward model.</fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:addr
type="machine">#307</fr:addr><fr:route>unstable-307.xml</fr:route><fr:title
text="Distilling Models with R1">Distilling Models with R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>To distill, they do only SFT with R1 generated COT.</fr:li>
      <fr:li>They show that distillation outperforms doing pure RL approach on smaller model</fr:li>
      <fr:ul><fr:li>Seems contradictory to <fr:link
type="local"
href="zeng2025simplerl.xml"
addr="zeng2025simplerl"
title="7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient">7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient</fr:link></fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<html:script
xmlns:html="http://www.w3.org/1999/xhtml"
src="https://utteranc.es/client.js"
repo="kkanarios32/website-comments"
issue-term="pathname"
theme="boxy-light"
crossorigin="anonymous"
async="" /></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3587</fr:anchor><fr:addr
type="user">kak-003F</fr:addr><fr:route>kak-003F.xml</fr:route><fr:title
text="Misc.">Misc.</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1498</fr:anchor><fr:addr
type="user">kak-004B</fr:addr><fr:route>kak-004B.xml</fr:route><fr:title
text="Information Theory">Information Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:title
text="Lecture 5">Lecture 5</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr
type="user">kak-004C</fr:addr><fr:route>kak-004C.xml</fr:route><fr:title
text="Convex set">Convex set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[C]]></fr:tex> is said to be convex if for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\lambda  x_1 + (1 - \lambda )x_2 \in  C]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr
type="user">kak-004D</fr:addr><fr:route>kak-004D.xml</fr:route><fr:title
text="Convex Function">Convex Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex
display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    This can be thought of as the tangent is always an underestimate of a convex function.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  This implies positive curvature or the common "bowl-shaped" interpretation.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Holds with equality if and only if 
    <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f]]></fr:tex> is linear on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a constant almost surely.</fr:li></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr
type="user">kak-004E</fr:addr><fr:route>kak-004E.xml</fr:route><fr:title
text="Gibb's inequality">Gibb's inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[D_{\mathrm {KL}}(P || Q) \geq  0]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Note that 
<fr:tex
display="block"><![CDATA[ \begin {align*}  D_{\mathrm {KL}}(P || Q) &= \mathbb {E}_P \left [\log \left (\frac {P(x)}{Q(x)}\right )\right ] \\ &= \mathbb {E}_P \left [-\log \left (\frac {Q(x)}{P(x)}\right )\right ] \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-002G.xml"
addr="kak-002G"
title="Jensen's Inequality">Jensen's Inequality</fr:link>,
<fr:tex
display="block"><![CDATA[   \begin {align*}     D_{\mathrm {KL}}(P || Q) &\geq  -\log  \left (\mathbb {E}_P \left [\frac {Q(x)}{P(x)}\right ]\right ) = 0   \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  When is <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q) = 0]]></fr:tex>?
</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Need <fr:tex
display="inline"><![CDATA[Q(x) / P(x)]]></fr:tex> to be constant almost surely. This occurs only when <fr:tex
display="inline"><![CDATA[Q = P]]></fr:tex>. 
    <fr:tex
display="block"><![CDATA[         Q(x) / P(x) = c \implies  Q(x) = P(x) c \iff  \sum  Q(x) = c \sum  P(x) \implies  c = 1       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:strong>Applications of <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[I(X; Y) \geq  0]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X | Y) \leq  H(X)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X^n) \leq  \sum _{i = 1}^n H(X_i)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X) \leq  \log  |\mathcal {X}|]]></fr:tex></fr:li></fr:ul>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">kak-004F</fr:addr><fr:route>kak-004F.xml</fr:route><fr:title
text="Log-Sum Inequality">Log-Sum Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[a_{i},b_{i}>0]]></fr:tex> for <fr:tex
display="inline"><![CDATA[i\in \{1,\ldots ,n\}]]></fr:tex>; <fr:tex
display="inline"><![CDATA[A=\sum _{i=1}^{n}a_{i},\quad  B=\sum _{i=1}^{n}b_{i}]]></fr:tex>
Then, we have: <fr:tex
display="inline"><![CDATA[\sum _{i=1}^{n}a_{i}\log  a_{i}/b_{i}\geq  A\log  A/B]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Define <fr:tex
display="inline"><![CDATA[p_i = \frac {a_i}{A}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[q_i = \frac {b_i}{B}]]></fr:tex>, then 
<fr:tex
display="block"><![CDATA[ \begin {align*}   D_{\mathrm {KL}}(p || q) &= \sum  \frac {a_i}{A} \log {\frac {B a_i}{A b_i}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \sum  \frac {a_i}{A} \log {\frac {A}{B}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>,
<fr:tex
display="block"><![CDATA[ \begin {align*}   \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \geq  0   &\implies    \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} \geq  \log {\frac {A}{B}} \\   &\iff    A \sum  a_i \log {\frac {a_i}{b_i}} \geq  A \log {\frac {A}{B}} \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:strong>Consequences of <fr:link
type="local"
href="kak-004F.xml"
addr="kak-004F"
title="Log-Sum Inequality">Log-Sum Inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li>Joint convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>,</fr:li>
      <fr:li>Individual convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>.</fr:li>
      <fr:li>Concavity of entropy.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:title
text="Lecture 7">Lecture 7</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr
type="user">kak-004Y</fr:addr><fr:route>kak-004Y.xml</fr:route><fr:title
text="Maximum Aposteriori Estimator">Maximum Aposteriori Estimator</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The optimal estimator <fr:tex
display="inline"><![CDATA[g^* : \mathcal {Y} \to  \mathcal {X}]]></fr:tex> is
<fr:tex
display="block"><![CDATA[ \begin {align*}   g*(y) = \arg \max _{x \in  \mathcal {X}} P_{X | Y}(x | y) \end {align*} ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr
type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that
<fr:tex
display="block"><![CDATA[     \begin {align*}       P_{e}(g) &= \sum _{x}\sum _y P_{XY}(x, y) \cdot  \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) \sum _{x} P_{X|Y}(x|y) \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) (1 - P_{X|Y}(g(y)|y)) \\     \end {align*} ]]></fr:tex>
To minimize this, we take
<fr:tex
display="block"><![CDATA[   \begin {align*}     g^*(y) = \arg \max _{x} P_{X|Y}(x | y)   \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    High-level
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[Y]]></fr:tex> contains more information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> than <fr:tex
display="inline"><![CDATA[\hat {X}]]></fr:tex>.</fr:li>
        <fr:li>We cannot increase the amount of information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> by processing <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:li></fr:ul>
    <fr:strong>Markov Chains:</fr:strong>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[(U, V, W)]]></fr:tex> form a Markov chain if
        <fr:tex
display="block"><![CDATA[ \begin {align*}   P(W = w \mid  U = u, V = v) = P(w = w \mid  V = v) \end {align*}           ]]></fr:tex>
Denoted <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>.</fr:li>
          <fr:li>Equivalently, we say <fr:tex
display="inline"><![CDATA[(U \perp  W) | V]]></fr:tex> which means <fr:tex
display="block"><![CDATA[              P(W = w, U=u \mid  V = v) \implies  P(W = w \mid  V = v)P(U = u \mid  V = v)           ]]></fr:tex></fr:li>
          <fr:li>Reversibility: <fr:tex
display="inline"><![CDATA[U \to  V \to  W \iff  W \to  V \to  U]]></fr:tex>.</fr:li>
          <fr:li>Estimation: <fr:tex
display="inline"><![CDATA[X \to  Y \to  \hat {X}]]></fr:tex></fr:li></fr:ul> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr
type="user">kak-004Z</fr:addr><fr:route>kak-004Z.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[I(U; W) \leq  I(U; V)]]></fr:tex>.</fr:p><fr:p><fr:strong>Intuition:</fr:strong> by data processing, we can never create new information about <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Use chain rule to expand <fr:tex
display="inline"><![CDATA[I(U; (V, W))]]></fr:tex> in two ways i.e. 
<fr:tex
display="block"><![CDATA[   \begin {align*}     I(U; (V, W)) = I(U; V) + I(U; W | V) = I(U; W) + I(U; V | W)   \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex> is a Markov chain, <fr:tex
display="inline"><![CDATA[I(U; W | V) = 0]]></fr:tex>. Therefore,
<fr:tex
display="block"><![CDATA[ \begin {align*}   I(U; V)  &= I(U; W) + I(U; V | W) \\ &\geq  I(U; W) \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[H(X | Y)]]></fr:tex> controls the error probability <fr:tex
display="inline"><![CDATA[P_e]]></fr:tex>.</fr:li></fr:ul>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:addr
type="user">kak-0050</fr:addr><fr:route>kak-0050.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[X \iff  Y \iff  \hat {X}]]></fr:tex> and let <fr:tex
display="inline"><![CDATA[p_e = \mathbb {P}(X \neq  \hat {X})]]></fr:tex>. Then, we have 
  <fr:tex
display="block"><![CDATA[       \begin {align*}         H(p_e) + p_e \log (|\mathcal {X}| - 1) \geq  H(X \mid  \hat {X}) \geq  H(X \mid  Y)       \end {align*}     ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:addr
type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:title
text="Asymptotic Equipartion Propery">Asymptotic Equipartion Propery</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>535</fr:anchor><fr:addr
type="user">kak-0051</fr:addr><fr:route>kak-0051.xml</fr:route><fr:title
text="Weak Law of Large Numbers">Weak Law of Large Numbers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[\frac {1}{n}\sum _{i=1}^{n}X_{i}\stackrel {{p}}{{\rightarrow }}\mu ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    By <fr:link
type="local"
href="kak-002F.xml"
addr="kak-002F"
title="Chebyshev's Inequality">Chebyshev's Inequality</fr:link>,
    <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}(|\hat {X} - \mu | > a) \leq  -\frac {\sigma ^2}{a^2}     \end {align*}     ]]></fr:tex>
    Since <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex>'s are independent, 
<fr:tex
display="block"><![CDATA[\mathrm {Var}[\hat {X}] = \frac {1}{n^2} \sum _{i = 1}^{n} \mathrm {Var}[X_i]]]></fr:tex>
    Therefore,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \lim _{n \to  \infty } \mathbb {P}(|\hat {X} - \mu | > a) \leq  \lim _{n \to  \infty }-\frac {\sigma ^2}{n a^2} \to  0     \end {align*} ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr
type="user">kak-0052</fr:addr><fr:route>kak-0052.xml</fr:route><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> be any function, such that <fr:tex
display="inline"><![CDATA[\mathrm {Var}(f(X))=\sigma _{f}^{2}<\infty ]]></fr:tex>. Then,
<fr:tex
display="block"><![CDATA[\frac {1}{n} \sum _{i = 1}^{n} f(X_i) \stackrel {p}{\rightarrow } \mathbb {E}[f(X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:addr
type="user">kak-0053</fr:addr><fr:route>kak-0053.xml</fr:route><fr:title
text="Continuous Mapping Theorem">Continuous Mapping Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_{n}\stackrel {{p}}{{\rightarrow }}X]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> denote a continuous function. Then,
<fr:tex
display="block"><![CDATA[f(X_n) \stackrel {p}{\rightarrow } f(X)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:addr
type="user">kak-0054</fr:addr><fr:route>kak-0054.xml</fr:route><fr:title
text="AEP Theorem">AEP Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex> denote i.i.d. <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with distribution <fr:tex
display="inline"><![CDATA[P_{X}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[ \begin {align*}  \lim _{n\to \infty }-\frac {1}{n}\log  p_{X^{n}}(X_{1},\ldots ,X_{n}) &= \lim _{n \to  \infty } -\frac {1}{n} \log  \prod _{i = 1}^{n} P_X(X_i) \\  &= \mathbb {E}_{X \sim  p_X}[-\log  p_X(X)] \\   &= H(X) \end {align*} ]]></fr:tex>
Equivalently, for large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>
<fr:tex
display="block"><![CDATA[   \begin {align*}     \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon    \end {align*} ]]></fr:tex>
with high probability.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>540</fr:anchor><fr:addr
type="user">kak-0055</fr:addr><fr:route>kak-0055.xml</fr:route><fr:title
text="-Typical set"><fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Fix an <fr:tex
display="inline"><![CDATA[\epsilon >0]]></fr:tex>. Then, an <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set with respect to the pmf <fr:tex
display="inline"><![CDATA[p_{X}]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}]]></fr:tex>, is defined as
<fr:tex
display="block"><![CDATA[\left \{X^n \in  \mathcal {X}^n \mid  \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon  \right \}]]></fr:tex>
Alternatively,
<fr:tex
display="block"><![CDATA[A_{\epsilon ^{(n)}} = \left \{X^n \in  \mathcal {X}^n \mid  2^{-n(H(X) + \epsilon )} \leq  p_{X^n}(X^n) \leq  2^{-n(H(X) - \epsilon )}\right \}]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  We have the following important properties
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)})\geq 1-\epsilon {\text { for large enough }}n]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{c}^{(n)}|\leq 2^{n(H(X)+\epsilon )}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{\epsilon }^{(n)}|\geq (1-\epsilon )2^{n(H(X)-\epsilon )}\;\text {for large enough }\;n\;,]]></fr:tex></fr:li></fr:ol>
    Together, this says that, depending on the entropy, the typical set can contain most of the probability despite being much smaller than the entire space.
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>interpretation:</fr:strong> <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}\,\text { is a subset of }\,{\mathcal {X}}^{n}]]></fr:tex>
<fr:ul><fr:li>Contains almost all the probability.</fr:li>
    <fr:li>Consists of <fr:tex
display="inline"><![CDATA[\approx  2^{nH(X)}]]></fr:tex></fr:li>
    <fr:li>Almost equiprobable sequences.</fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:addr
type="user">kak-0056</fr:addr><fr:route>kak-0056.xml</fr:route><fr:title
text="High probability sets">High probability sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[B_{\epsilon }^{(n)}\subset \mathcal {X}^{n}]]></fr:tex> be the smallest set with probability at least <fr:tex
display="inline"><![CDATA[1-\epsilon ]]></fr:tex>. Then, we must have

<fr:tex
display="block"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)}\cap  B_{\epsilon }^{(n)})\geq 1-2\epsilon ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:addr
type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:title
text="Fixed-rate lossless source coding">Fixed-rate lossless source coding</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr
type="user">kak-0059</fr:addr><fr:route>kak-0059.xml</fr:route><fr:title
text="Coding system">Coding system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A coding system with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> consist of an encoder and a decoder, where an encoder is a function
<fr:tex
display="block"><![CDATA[   e: \mathcal {X}^n \to  \{1, 2, \ldots , \theta \} ]]></fr:tex>
and a decoder is a function 
<fr:tex
display="block"><![CDATA[f: \{1, 2, \ldots , \theta \} \to  \mathcal {X}^n]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Performance:</fr:strong>
    <fr:ul><fr:li>Rate = <fr:tex
display="inline"><![CDATA[\frac {\log _2 \theta }{n}]]></fr:tex></fr:li>
        <fr:li>Probability of decoding error = <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n|]]></fr:tex></fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr
type="user">kak-005A</fr:addr><fr:route>kak-005A.xml</fr:route><fr:title
text="Achievability">Achievability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex> (perturbation parameter) there exists a block length <fr:tex
display="inline"><![CDATA[N(\epsilon )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\forall  n > N(\epsilon )]]></fr:tex> the following holds
<fr:ul><fr:li>There exists an <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding system</fr:link> such that <fr:tex
display="inline"><![CDATA[\frac {\log  \theta }{n} < R + \epsilon ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n| < \epsilon ]]></fr:tex>.</fr:li></fr:ul></fr:p><fr:p>Alternatively, a positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if there exists a sequence of <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding systems</fr:link> <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log  \theta }{n} \to  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \mathbb {P}|\hat {X}^n \neq  X^n| \to  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr
type="user">kak-005B</fr:addr><fr:route>kak-005B.xml</fr:route><fr:title
text="Minimum rate of source coding">Minimum rate of source coding</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>minimum rate of source coding</fr:em> <fr:tex
display="inline"><![CDATA[R_s]]></fr:tex> is the infimum over all <fr:tex
display="inline"><![CDATA[R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link> i.e.  
<fr:tex
display="block"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr
type="user">kak-005C</fr:addr><fr:route>kak-005C.xml</fr:route><fr:title
text="Entropy as MRSC">Entropy as <fr:link
type="local"
href="kak-005B.xml"
addr="kak-005B"
title="Minimum rate of source coding">MRSC</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[R_s = H(P_X) = H(X) = -\sum _{x \in  \mathcal {X}} P_X(x) \log  P_X(x)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>497</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>First we will show that <fr:tex
display="inline"><![CDATA[H(X)]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. Then we will have <fr:tex
display="inline"><![CDATA[R_s \leq  H(X)]]></fr:tex> by definition. Idea: take <fr:tex
display="inline"><![CDATA[\theta  = 2^{n(H(X) + \epsilon )} + 1]]></fr:tex>. Give each element in typical set a unique index, everything else the same index. By properties of typical set, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\text {error}) < \epsilon ]]></fr:tex> for sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</fr:p>
  <fr:p>For the other direction, suppose we have some <fr:tex
display="inline"><![CDATA[R]]></fr:tex> <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. By definition, for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, for all sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex> there exists a [kak-0059] with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that
<fr:tex
display="block"><![CDATA[         \begin {align*}           \frac {\log  \theta }{n} < R + \epsilon , \quad  \mathbb {P}(\text {error}) < \epsilon          \end {align*}       ]]></fr:tex>
      Use <fr:link
type="local"
href="kak-0050.xml"
addr="kak-0050"
title="Fano's Inequality">Fano's Inequality</fr:link> to show this is not possible.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1500</fr:anchor><fr:addr
type="user">kak-003W</fr:addr><fr:route>kak-003W.xml</fr:route><fr:title
text="LLMs stuff">LLMs stuff</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1005</fr:anchor><fr:addr
type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:title
text="Useful Resources">Useful Resources</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:link
type="external"
href="https://hijkzzz.notion.site/rlhf-implementation-tricks?v=158d9a33ecc98132bf9e000c39227361">PPO + LLM Tricks</fr:link></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1501</fr:anchor><fr:addr
type="user">kak-0033</fr:addr><fr:route>kak-0033.xml</fr:route><fr:title
text="Optimization Theory">Optimization Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>660</fr:anchor><fr:addr
type="machine">#310</fr:addr><fr:route>unstable-310.xml</fr:route><fr:title
text="Convex Optimization Background">Convex Optimization Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>662</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>663</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p><fr:strong>Operations that preserve convexity</fr:strong>
<fr:ul><fr:li><fr:strong>Nonnegative weighted sums:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex
display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</fr:li>
    <fr:li><fr:strong>Pointwise maximum:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex</fr:li></fr:ul></fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>664</fr:anchor><fr:addr
type="user">kak-0036</fr:addr><fr:route>kak-0036.xml</fr:route><fr:title
text="Strong convexity">Strong convexity</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex if and only if 
<fr:tex
display="block"><![CDATA[g(\boldsymbol {x}) = f(\boldsymbol {x}) - \frac {\mu }{2} ||\boldsymbol {x}||_2^2]]></fr:tex>
is convex, <fr:tex
display="inline"><![CDATA[\forall  \boldsymbol {x} \in  \mathrm {dom} f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>665</fr:anchor><fr:addr
type="user">kak-0037</fr:addr><fr:route>kak-0037.xml</fr:route><fr:title
text="Smooth Problem">Smooth Problem</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A problem is <fr:em>smooth</fr:em> if both the objective function and the constraints are differentiable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>666</fr:anchor><fr:addr
type="user">kak-0038</fr:addr><fr:route>kak-0038.xml</fr:route><fr:title
text="Subgradient">Subgradient</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> be convex. A <fr:em>subgradient</fr:em> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\boldsymbol {u}]]></fr:tex> satisfying
<fr:tex
display="block"><![CDATA[f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>667</fr:anchor><fr:addr
type="user">kak-0039</fr:addr><fr:route>kak-0039.xml</fr:route><fr:title
text="Subdifferential">Subdifferential</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>subdifferential</fr:em> is the set of all <fr:link
type="local"
href="kak-0038.xml"
addr="kak-0038"
title="Subgradient">subgradient's</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex>.
<fr:tex
display="block"><![CDATA[\partial  f(\boldsymbol {x}_0) \coloneqq  \{\boldsymbol {u} | f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle  \}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>668</fr:anchor><fr:addr
type="machine">#318</fr:addr><fr:route>unstable-318.xml</fr:route><fr:title
text="Useful Miscellanous Math Background">Useful Miscellanous Math Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>In this section, we cover many random math facts / tools that come up / are useful in later optimization problems.</fr:p>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>670</fr:anchor><fr:addr
type="machine">#311</fr:addr><fr:route>unstable-311.xml</fr:route><fr:title
text="Basic Matrix Analysis">Basic Matrix Analysis</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:ul><fr:li><fr:strong>Matrix inner product:</fr:strong>
<fr:tex
display="block"><![CDATA[\langle \mathbf {x},\mathbf {z}\rangle \ =\ \sum _{i=1}^{n}x_{i}z_{i}\quad \Longrightarrow \quad \langle \mathbf {X},\mathbf {Z}\rangle \ :=\ \sum _{i=1}^{m}\sum _{j=1}^{n}X_{i j}Z_{i j}]]></fr:tex></fr:li>
    <fr:li><fr:strong>Matrix trace:</fr:strong> <fr:tex
display="inline"><![CDATA[{{M}}\in \mathbb {R}^{n\times  n};\ {{\mathrm {tr}}}({{M}}):=\sum _{i=1}^{n}M_{i i}]]></fr:tex>
    <fr:tex
display="block"><![CDATA[       \begin {align*}       &\langle {\boldsymbol  X},{\boldsymbol  Z}\rangle \ =\ \mathrm {tr}\left ({\boldsymbol  X}^{\top }{\boldsymbol  Z}\right )\ =\ \mathrm {tr}\left ({\boldsymbol  X}{\boldsymbol  Z}^{\top }\right ) \\     &\operatorname {tr}(\mathbf {A}\mathbf {B})=\operatorname {tr}(\mathbf {B}\mathbf {A})\\       &\operatorname {tr}(\mathbf {A}_{1}\mathbf {A}_{2}\cdots \mathbf {A}_{n})=\operatorname {tr}(\mathbf {A}_{\pi (1)}\mathbf {A}_{\pi (2)}\cdots \mathbf {A}_{\pi (n)})       \end {align*}     ]]></fr:tex>
    Where <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex> is a cyclic permutation on <fr:tex
display="inline"><![CDATA[\{1,2,\cdots ,n\}]]></fr:tex></fr:li></fr:ul>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr
type="user">kak-003A</fr:addr><fr:route>kak-003A.xml</fr:route><fr:title
text="Positive (semi)definiteness">Positive (semi)definiteness</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:em>symmetric</fr:em> matrix <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{n\times  n}]]></fr:tex> is <fr:em>positive definite</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}>0]]></fr:tex> for all nonzero <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. It is <fr:em>positive semidefinite (p.s.d.)</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}\geq 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>673</fr:anchor><fr:addr
type="user">kak-003B</fr:addr><fr:route>kak-003B.xml</fr:route><fr:title
text="Singular Value Decomposition">Singular Value Decomposition</fr:title><fr:taxon>Fact</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\operatorname {rank}(\mathbf {A})=r]]></fr:tex>. There exist <fr:tex
display="inline"><![CDATA[\sigma _{1}\geq \sigma _{2}\geq \cdots \geq \sigma _{r}>0]]></fr:tex>, and matrices <fr:tex
display="block"><![CDATA[\mathbf {U}\in \mathbb {R}^{m\times  r},\ \mathbf {V}\in \mathbb {R}^{n\times  r},]]></fr:tex> with <fr:em>orthonormal</fr:em> columns <fr:tex
display="inline"><![CDATA[(\mathbf {U}^{\top }\mathbf {U}=\mathbf {I},\ \mathbf {V}^{\top }\mathbf {V}=\mathbf {I})]]></fr:tex> such that <fr:tex
display="block"><![CDATA[\mathbf {A}\ =\ \mathbf {U}\mathbf {\Sigma }\mathbf {V}^{\top }\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }\,,\quad \mathbf {\Sigma }\ =\ \operatorname {diag}\left (\sigma _{1},\cdots ,\sigma _{r}\right ).]]></fr:tex></fr:p><fr:p>Relationship between eigen decomposition and SVD
  <fr:ul><fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {V}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}^T\boldsymbol {A}]]></fr:tex></fr:li>
      <fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {U}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}\boldsymbol {A}^T]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[{{\sigma _{i}({\mathbf {A}})}}={\sqrt {\lambda _{i}({{{\mathbf {A}}{\mathbf {A}}^{\mathsf {T}}}})}}={\sqrt {\lambda _{i}({\mathbf {A}}^{\mathsf {T}}{\mathbf {A}})}}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>674</fr:anchor><fr:addr
type="user">kak-003C</fr:addr><fr:route>kak-003C.xml</fr:route><fr:title
text="Best rank-r approximation">Best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with SVD, <fr:tex
display="inline"><![CDATA[\mathbf {A}=\sum _{i=1}^{\min \{m,n\}}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }]]></fr:tex>. Then an optimal solution to the best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation problem <fr:tex
display="block"><![CDATA[\min _{\mathbf {X}}||\mathbf {X}-\mathbf {A}||_{2}\,,\quad \text {s.t.}\quad \text {rank}(\mathbf {X})\ \leq \ r]]></fr:tex> is the truncated SVD of the following form <fr:tex
display="block"><![CDATA[\boxed {\widehat {\mathbf {A}}_{r}\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }}\,,\ \ \text {if}\ \ \sigma _{r}>\sigma _{r+1}\,,\,\text {it is unique.}]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>675</fr:anchor><fr:addr
type="machine">#309</fr:addr><fr:route>unstable-309.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Suppose <fr:tex
display="inline"><![CDATA[m \geq  n]]></fr:tex>, then we observe that
<fr:tex
display="block"><![CDATA[\left |\left |{\widehat {\mathbf {A}}}_{r}-{\mathbf {A}}\right |\right |_{2}\;=\;\left |\left |\sum _{i=r+1}^{n}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\mathsf {T}}\right |\right |_{2} \leq  \sigma _{r+1}]]></fr:tex>

Second, to prove our result, we want to show that <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {B}_{r}-\mathbf {A}\right |\right |_{2}\ \geq \ \sigma _{r+1},\quad \forall \mathbf {B}_{r}\ \text {with}\ \mathrm {rank}(\mathbf {B}_{r})=r.]]></fr:tex> We suppose <fr:tex
display="inline"><![CDATA[\ \mathbf {B}_{r}=\widetilde {\mathbf {U}}\widetilde {\mathbf {V}}^{\top },\quad \widetilde {\mathbf {U}}\in \mathbb {R}^{m\times  r},\ \widetilde {\mathbf {V}}\in \mathbb {R}^{n\times  r}.]]></fr:tex>
Note
<fr:tex
display="block"><![CDATA[ \begin {align*} ||\mathbf {B}_r - A||_2^2 &= \sup _{||\boldsymbol {z}||_2 \leq  1} ||(\mathbf {B}_r - \mathbf {A})\mathbf {z}||_2^2 \\ &\geq  ||(\mathbf {B}_r - \mathbf {A})\mathbf {w}||_2^2 \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\widetilde {V}]]></fr:tex> has <fr:tex
display="inline"><![CDATA[r]]></fr:tex> columns, then there must be a nontrivial linear combination of the first <fr:tex
display="inline"><![CDATA[r{+}1]]></fr:tex> columns of <fr:tex
display="inline"><![CDATA[V]]></fr:tex>, i.e., <fr:tex
display="block"><![CDATA[\mathbf {w}=\gamma _{1}\mathbf {v}_{1}+\cdots +\gamma _{r+1}\mathbf {v}_{r+1}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\widetilde {V}^{\top }\mathbf {w}=\mathbf {0}\,.]]></fr:tex> Wlog, we can scale <fr:tex
display="inline"><![CDATA[\left |\left |\mathbf {w}\right |\right |_{2}=1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\,\sum _{i=1}^{r+1}\gamma _{i}^{2}=1]]></fr:tex>
Then 
<fr:tex
display="block"><![CDATA[||\mathbf {A}-\mathbf {B}_{k}||_{2}^{2}\geq ||(\mathbf {A}-\mathbf {B}_{k})\,\mathbf {w}||_{2}^{2}=||\mathbf {A}\mathbf {w}||_{2}^{2}=\gamma _{1}^{2}\sigma _{1}^{2}+\cdots +\gamma _{r+1}^{2}\sigma _{r+1}^{2}\geq \sigma _{r+1}^{2}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>676</fr:anchor><fr:addr
type="user">kak-003G</fr:addr><fr:route>kak-003G.xml</fr:route><fr:title
text="Matrix Operator Norm">Matrix Operator Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{a}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{b}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathbb {R}^{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {R}^{m}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {A}\right |\right |_{a\to  b}\ :=\ \sup _{\left |\left |\mathbf {x}\right |\right |_{a}\leq  1}\left |\left |\mathbf {A}\mathbf {x}\right |\right |_{b}.]]></fr:tex>
It satisfies the <fr:em>three criteria</fr:em> for norm, and is <fr:em>submultiplicative</fr:em> <fr:tex
display="block"><![CDATA[||\boldsymbol {A}\boldsymbol {B}||_{a\to  b}\ \leq \ ||\boldsymbol {A}||_{a\to  b}\cdot  ||\boldsymbol {B}||_{a\to  b};]]></fr:tex>. 
<fr:tex
display="block"><![CDATA[||{\cal  A}||_{2\to 2}\;=\;\sigma _{1}({\cal  A})\;\;(\mathrm {{spectral\ norm}},\;\mathrm {{write\ as}}\;||{\cal  A}||\;\;);\;]]></fr:tex>
<fr:tex
display="block"><![CDATA[\begin {array}{l}{{||{\boldsymbol {A}}||_{1\to  b}\ =\ \operatorname *{max}_{j=1,\cdots ,n}||{\boldsymbol {A e}}_{j}||_{b}}}\\ {{||{\boldsymbol {A}}||_{a\to \infty }\ =\ \operatorname *{max}_{i=1,\cdots ,m}||{\boldsymbol {e}}_{i}^{*}{\boldsymbol {A}}||_{b}^{*}\,,\ \ ||{\boldsymbol {v}}||_{b}^{*}\ :=\ \operatorname *{sup}_{||{\boldsymbol {u}}||_{b}\leq 1}\langle {\boldsymbol {u}},{\boldsymbol {v}}\rangle \,,}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>677</fr:anchor><fr:addr
type="user">kak-003H</fr:addr><fr:route>kak-003H.xml</fr:route><fr:title
text="Unitary Invariant Matrix Norm">Unitary Invariant Matrix Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}.]]></fr:tex> We say the matrix norm is unitary invariant if <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{\sharp }\ =\ \left ||\mathbf {PAQ}\right ||_{\sharp },\quad \forall \ \mathbf {P}\in  O(m),\ \mathbf {Q}\in  O(n).]]></fr:tex></fr:p><fr:p>Eg.
  <fr:ul><fr:li><fr:strong>Spectral norm</fr:strong> <fr:tex
display="block"><![CDATA[||A||_{2 \to  2}=\sigma _{1}(A)=||\sigma (A)||_{\infty }]]></fr:tex></fr:li>
    <fr:li><fr:strong>Frobenius norm</fr:strong> <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{F}\ =\ \sqrt {\sum _{i=1}^{\min \{m,n\}}\sigma _{i}^{2}(\mathbf {A})}\ =\ \left ||\mathbf {\sigma }(\mathbf {A})\right ||_{2}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>678</fr:anchor><fr:addr
type="user">kak-003I</fr:addr><fr:route>kak-003I.xml</fr:route><fr:title
text="Schatten p-norm">Schatten <fr:tex
display="inline"><![CDATA[p]]></fr:tex>-norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[p \in  [1,+\infty ]]]></fr:tex>, the function <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}|\right |_{\mathrm {S}_{p}}\,:=\,\left ||\mathbf {\sigma }(\mathbf {A})|\right |_{p}]]></fr:tex> is a norm on <fr:tex
display="inline"><![CDATA[\,\mathbb {R}^{m\times  n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>679</fr:anchor><fr:addr
type="machine">#313</fr:addr><fr:route>unstable-313.xml</fr:route><fr:title
text="Taylor Expansion and Lipschitz Functions">Taylor Expansion and Lipschitz Functions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>681</fr:anchor><fr:addr
type="user">kak-003J</fr:addr><fr:route>kak-003J.xml</fr:route><fr:title
text="Lipschitz Continous">Lipschitz Continous</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f:\mathcal {X}\mapsto \mathcal {Y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> being open sets;</fr:li> 
  <fr:li><fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {X}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {Y}}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex>, respectively.</fr:li></fr:ul>
<fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex> is Lipschitz continuous over <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\exists  L<\infty \,,]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||f(\boldsymbol {y})-f(\boldsymbol {x})||_{\mathcal {Y}}\ \leq \ L(\boldsymbol {x})\,||\boldsymbol {y}-\boldsymbol {x}||_{\mathcal {X}}\,,\quad \forall \boldsymbol {x},\ \boldsymbol {y}\in \mathcal {X}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>682</fr:anchor><fr:addr
type="user">kak-003K</fr:addr><fr:route>kak-003K.xml</fr:route><fr:title
text="Smooth Function">Smooth Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A differentiable function <fr:tex
display="inline"><![CDATA[f(\mathbf {x})]]></fr:tex> is called smooth iff it has a Lipschitz continuous gradient, i.e., iff <fr:tex
display="inline"><![CDATA[L< \infty ]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x})-\nabla  f(\mathbf {z}) ||_{2}\ \leq  L ||\mathbf {x}-\mathbf {z} ||_{2},\quad  \forall  \mathbf {x},\ \mathbf {z}\in \mathbb {R}^{n}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>683</fr:anchor><fr:addr
type="user">kak-003L</fr:addr><fr:route>kak-003L.xml</fr:route><fr:title
text="Mean Value Theorem I">Mean Value Theorem I</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\,f(\mathbf {y})\,=\,f(\mathbf {x})\,+\,\langle \nabla  f(\mathbf {z}(t_{L})),\mathbf {y}-\mathbf {x}\rangle \,]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t_{L})=(1-t_{L})\cdot \mathbf {x}+t_{L}\cdot \mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t_{L}\in (0,1)\,]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>684</fr:anchor><fr:addr
type="machine">#312</fr:addr><fr:route>unstable-312.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^n\mapsto \mathbb {R}]]></fr:tex> is continuously differentiable, <fr:tex
display="block"><![CDATA[\begin {aligned}      |f(\pmb {x})-f(\pmb {y})| &\leq  & \sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2 \, ||\pmb {x}-\pmb {y}||_2   \end {aligned}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2]]></fr:tex>.</fr:li>
          <fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is twice continuously differentiable, <fr:tex
display="block"><![CDATA[||\nabla  f(\boldsymbol {x})-\nabla  f(\boldsymbol {y})||_{2}\ \leq \ \sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}\,||\boldsymbol {x}-\boldsymbol {y}||_{2}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}]]></fr:tex></fr:li></fr:ul>
      </fr:mainmatter><fr:backmatter /></fr:tree>

      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>686</fr:anchor><fr:addr
type="user">kak-003M</fr:addr><fr:route>kak-003M.xml</fr:route><fr:title
text="Mean Value Theorem II">Mean Value Theorem II</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be twice continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {y})\;=\;\nabla  f(\mathbf {x})\,+\,\int _{0}^{1}\nabla ^{2}f(\mathbf {z}(t))\cdot (\mathbf {y}-\mathbf {x})dt]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t)=(1-t)\mathbf {x}+t\mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t\in (0,1)\,,]]></fr:tex> and that <fr:tex
display="block"><![CDATA[\boxed {f(\mathbf {y})\;=\;f(\mathbf {x})+(\nabla  f(\mathbf {x}),\mathbf {y}-\mathbf {x})+\frac {1}{2}(\mathbf {y}-\mathbf {x})^{\top }\nabla ^{2}f(\mathbf {z}(t_{Q}))(\mathbf {y}-\mathbf {x})}]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[t_{Q}\in (0,1)\,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>687</fr:anchor><fr:addr
type="user">kak-003N</fr:addr><fr:route>kak-003N.xml</fr:route><fr:title
text="First-order approximation">First-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be continuously differentiable, and <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{L}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{L}(\mathbf {x}_{0})}{2}\,||\mathbf {x}-\mathbf {x}_{0}||_{2}^{2}\,,]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\ :=\ f(\mathbf {x}_{0})\ +\ \langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle \,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>688</fr:anchor><fr:addr
type="user">kak-003O</fr:addr><fr:route>kak-003O.xml</fr:route><fr:title
text="Second-order approximation">Second-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be twice continuously differentiable, and suppose <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{Q}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{Q}(\mathbf {x}_{0})}{6}\left ||\mathbf {x}-\mathbf {x}_{0}\right ||_{2}^{3},]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0}):=f(\mathbf {x}_{0})+\langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle ]]></fr:tex> <fr:tex
display="block"><![CDATA[+\frac {1}{2}(\mathbf {x}-\mathbf {x}_{0})^{\top }\nabla ^{2}f(\mathbf {x}_{0})(\mathbf {x}-\mathbf {x}_{0}).]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>689</fr:anchor><fr:addr
type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title
text="Optimality Conditions">Optimality Conditions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>691</fr:anchor><fr:addr
type="user">kak-003P</fr:addr><fr:route>kak-003P.xml</fr:route><fr:title
text="Stationary point">Stationary point</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A point <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a stationary point of <fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex>, if <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.]]></fr:tex> Here, <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is also known as a critical point.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:ul><fr:li><fr:strong>First order necessary condition</fr:strong>:
    If <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[\ f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is continuously differentiable in an open neighborhood of <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[\boxed {\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.}]]></fr:tex>
    <fr:li><fr:strong>Second order necessary condition:</fr:strong>
    If <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is twice continuously differentiable in an open neighborhood around <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[(i)\ \nabla  f(\mathbf {x_{\star }})=\mathbf {0};]]></fr:tex> <fr:tex
display="block"><![CDATA[(ii)\ \nabla ^{2}f(\mathbf {x_{\star }})\succeq \mathbf {0}.]]></fr:tex>
    <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x_{\star }})\succ \mathbf {0}]]></fr:tex> then the above is a sufficient condition.</fr:li></fr:ul></fr:li></fr:li></fr:ul>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>692</fr:anchor><fr:addr
type="machine">#314</fr:addr><fr:route>unstable-314.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be a convex function, then 
  <fr:ul><fr:li>A local minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is also its global minimizer. If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is strictly convex, the global minimizer is unique</fr:li>
    <fr:li>A point is a global minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> iff <fr:tex
display="block"><![CDATA[\mathbf {0}\ \in \ \partial  f(\mathbf {x_{\star }}).]]></fr:tex></fr:li></fr:ul>
  If <fr:tex
display="inline"><![CDATA[f\in \mathcal {C}^{1}]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x_{\star }})=\mathbf {0}]]></fr:tex> implies that <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a global minimizer.
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>694</fr:anchor><fr:addr
type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title
text="Constrained Case">Constrained Case</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider a smooth contained problem with <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}}f(\mathbf {x}),\quad  \text {s.t.} \quad  r_{i}(\mathbf {x})\ =\ 0,\ 1\leq  i\leq  p,]]></fr:tex> <fr:tex
display="block"><![CDATA[h_{j}(\mathbf {x})\ \leq \ 0,\ 1\leq  j\leq  q.]]></fr:tex> Consider its Lagrangian function <fr:tex
display="block"><![CDATA[\mathscr {L}(\mathbf {x},\mathbf {u},\mathbf {v})\ =\ f(\mathbf {x})+\sum _{i=1}^{p}u_{i}\cdot  r_{i}(\mathbf {x})+\sum _{j=1}^{q}v_{j}\cdot  h_{j}(\mathbf {x}).]]></fr:tex>
    <fr:strong>KKT-conditions:</fr:strong>
    <fr:ul><fr:li>Stationary <fr:tex
display="block"><![CDATA[\nabla _{\mathbf {x}}{\mathcal {L}}(\mathbf {x_*},\mathbf {u_*},\mathbf {v_*})\;=\;\mathbf {0}]]></fr:tex></fr:li>
    <fr:li>Primal Feasibility: <fr:tex
display="block"><![CDATA[\begin {array}{l}{{r_{i}(x_{\star })\ =\ 0,\ 1\leq  i\leq  p,}}\\ {{h_{j}(x_{\star })\ \leq \ 0,\ 1\leq  j\leq  q.}}\end {array}]]></fr:tex></fr:li>
    <fr:li>Dual Feasibility: <fr:tex
display="block"><![CDATA[v_{\star }\geq  0.]]></fr:tex></fr:li>
    <fr:li>Complimentary slackness: <fr:tex
display="block"><![CDATA[h_{j}(x_{\star })\cdot  v_{\star  j}\ =\ 0,\quad \forall \ 1\leq  j\leq  q.]]></fr:tex></fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>696</fr:anchor><fr:addr
type="machine">#317</fr:addr><fr:route>unstable-317.xml</fr:route><fr:title
text="Rate of Convergence">Rate of Convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Want to find
<fr:tex
display="block"><![CDATA[\operatorname *{min}_{\mathbf {x}}\ f(\mathbf {x}),\quad \text {s.t.}\quad \mathbf {x}\ \in \ \mathcal {C}.]]></fr:tex> Solve the problem via iterative methods of optimization, which produce a sequence of points <fr:tex
display="block"><![CDATA[\mathbf {x}_{1},\ \mathbf {x}_{2},\ \cdots ,\mathbf {x}_{k},\cdots ]]></fr:tex> starting from an initialization <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>.</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>698</fr:anchor><fr:addr
type="user">kak-003R</fr:addr><fr:route>kak-003R.xml</fr:route><fr:title
text="First-order convergence">First-order convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>First-order function value convergence 
     <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x}_k)||_2 \; \leq  \; \varepsilon .]]></fr:tex>
       <fr:ul><fr:li>For convex functions, this also means convergence to the global minimizer</fr:li>
        <fr:li>For nonconvex functions, this only means   convergence to a <fr:link
type="local"
href="kak-003P.xml"
addr="kak-003P"
title="Stationary point">Stationary point</fr:link> (e.g., a local minimizer or a saddle point).</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>699</fr:anchor><fr:addr
type="user">kak-003Q</fr:addr><fr:route>kak-003Q.xml</fr:route><fr:title
text="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[(p \geq 1)]]></fr:tex> and with factor <fr:tex
display="inline"><![CDATA[(\gamma  > 0)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[\exists  k_{0}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\forall  k\geq  k_{0}]]></fr:tex>: <fr:tex
display="block"><![CDATA[\boxed {\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k}}-\mathbf {x_{*}}||_{2}\ \leq \ \gamma \cdot \left (\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k-1}}-\mathbf {x_{*}}||_{2}\right )^{p}.}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>700</fr:anchor><fr:addr
type="user">kak-003S</fr:addr><fr:route>kak-003S.xml</fr:route><fr:title
text="R-convergence"><fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[p\;(\geq 1)]]></fr:tex>, <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}_{*}\in \mathcal {X}}||\mathbf {x}_{k}-\mathbf {x}_{*}||_{2}\;\leq \;\rho _{k},]]></fr:tex> if the sequence <fr:tex
display="inline"><![CDATA[\{\rho _{k}\}_{k\geq 1}]]></fr:tex> is <fr:link
type="local"
href="kak-003Q.xml"
addr="kak-003Q"
title="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:link> of the order <fr:tex
display="inline"><![CDATA[p]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>701</fr:anchor><fr:addr
type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:title
text="Iterative Methods">Iterative Methods</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:strong>Assume:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">Convex Function</fr:link> and a <fr:link
type="local"
href="kak-003K.xml"
addr="kak-003K"
title="Smooth Function">Smooth Function</fr:link>.</fr:li>
      <fr:li>The gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>.</fr:li></fr:ul>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>703</fr:anchor><fr:addr
type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title
text="Convergence of Gradient Descent">Convergence of Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>705</fr:anchor><fr:addr
type="user">kak-004L</fr:addr><fr:route>kak-004L.xml</fr:route><fr:title
text="Sufficient Value">Sufficient Value</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>With step size <fr:tex
display="inline"><![CDATA[\tau _{k}=1/L\,,]]></fr:tex> the gradient descent iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathbf {x}_{k}\ -\ \tau _{k}\cdot \nabla  f(\mathbf {x}_{k})]]></fr:tex>

satisfy the following:

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k+1})\ \leq \ f(\mathbf {x}_{k})\ -\ \frac {1}{2L}\,||\nabla  f(\mathbf {x}_{k})||_{2}^{2}]]></fr:tex> <fr:tex
display="block"><![CDATA[<\ f(\mathbf {x}_{k})\quad (||\nabla  f(\mathbf {x}_{k})||_{2}\neq 0)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>656</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Because <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is Lipschitz, by 1st-order Taylor approximation

<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})+\langle \nabla  f(\mathbf {x}),\mathbf {x}^{\prime }-\mathbf {x}\rangle +\frac {L}{2}\left ||\mathbf {x}^{\prime }-\mathbf {x}\right ||_{2}^{2},\quad \forall \ \mathbf {x}^{\prime },\mathbf {x}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \tau  \nabla  f( \mathbf {x})]]></fr:tex>. Then
<fr:tex
display="block"><![CDATA[   \begin {align*}     f(\mathbf {x}^{\prime }) &\leq  f(\mathbf {x})+ \tau  ||\nabla  f( \mathbf {x} )||_2^2 + \frac {\tau ^2 L}{2} ||\nabla  f( \mathbf {x})||_2^2 \\     &= f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2   \end {align*} ]]></fr:tex>
  Take <fr:tex
display="inline"><![CDATA[\tau  = \frac {1}{L}]]></fr:tex>, such that
<fr:tex
display="block"><![CDATA[     \begin {align*} f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2 &= f( \mathbf {x}) - \frac {1}{2L}||\nabla  f( \mathbf {x})||_2^2     \end {align*}   ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>706</fr:anchor><fr:addr
type="user">kak-004M</fr:addr><fr:route>kak-004M.xml</fr:route><fr:title
text="Sublinear convergence of GD">Sublinear convergence of GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. If we run GD for <fr:tex
display="inline"><![CDATA[k]]></fr:tex> iterations with a fixed step size <fr:tex
display="inline"><![CDATA[\tau =1/L]]></fr:tex>, it will yield a sequence <fr:tex
display="inline"><![CDATA[\left \{\mathbf {x}_{k}\right \}_{k\geq 1}]]></fr:tex> such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}\ =\ O(\frac {1}{k}),]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>653</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Given <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex and smooth, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_*]]></fr:tex> is an optimal solution, then
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{\star })\geq  f(\mathbf {x})+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}_{\star }-\mathbf {x})]]></fr:tex>
Flipping the inequality yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x})\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })]]></fr:tex>
By <fr:link
type="local"
href="kak-004L.xml"
addr="kak-004L"
title="Sufficient Value">previous lemma</fr:link>, taking <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \frac {1}{L} \nabla  f( \mathbf {x})]]></fr:tex> yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
such that
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
Equivalently,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })\leq {\frac {L}{2}}\left [{\frac {2}{L}}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{L^{2}}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ]]]></fr:tex>
Completing the square,
<fr:tex
display="block"><![CDATA[ \begin {align*}  f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })&\leq \frac {L}{2}\left [\frac {2}{L}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-\frac {1}{L^{2}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}-\frac {1}{L}\nabla  f(\mathbf {x})-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}^{\prime }-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \end {align*} ]]></fr:tex>
Let <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}=\mathbf {x}_{k-1}-\frac {1}{L}\nabla  f(\mathbf {x}_{k-1})]]></fr:tex>, then we have

<fr:tex
display="block"><![CDATA[ \begin {align*}  \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right ) &\leq  \frac {L}{2}\sum _{i=1}^{k}\left [\left ||\mathbf {x}_{i-1}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{i}-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]  \\ &=\frac {L}{2}\left [\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{k}-\mathbf {x}_{0}\right ||_{2}^{2}\right ] \\   &\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}  \end {align*} ]]></fr:tex>
Therefore, given <fr:tex
display="inline"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\leq  f(\mathbf {x}_{i})-f(\mathbf {x}_{*}) \text { for } \forall  i\leq  k\,,]]></fr:tex>

<fr:tex
display="block"><![CDATA[k\left (f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\right )\leq \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right )\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>707</fr:anchor><fr:addr
type="user">kak-004N</fr:addr><fr:route>kak-004N.xml</fr:route><fr:title
text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose the iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <fr:em>black-box model</fr:em>:

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></fr:p><fr:p>For every positive <fr:tex
display="inline"><![CDATA[L]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">convex</fr:link> differentiable <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>708</fr:anchor><fr:addr
type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title
text="Accelerated Gradient Descent">Accelerated Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>710</fr:anchor><fr:addr
type="user">kak-004O</fr:addr><fr:route>kak-004O.xml</fr:route><fr:title
text="Nesterov's Method">Nesterov's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Generate two sequences <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}{\mathrm {~and~}}\{\mathbf {p}_{k}\}_{k\geq 1}]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*} {\mathbf {\mathit {p}}}_{k+1}\ &=\ {\mathbf {\mathit {x}}}_{k}\ +\ \beta _{k}\cdot ({\mathbf {\mathit {x}}}_{k}-{\mathbf {\mathit {x}}}_{k-1}), \\ x_{k+1} &= p_{k+1}-\alpha \nabla  f(p_{k+1}) \end {align*} ]]></fr:tex>
<fr:ul><fr:li><fr:strong>Not</fr:strong> a descent method.</fr:li>
<fr:li>With properly chosen <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\beta ]]></fr:tex> can achieve <fr:link
type="local"
href="kak-004N.xml"
addr="kak-004N"
title="Suboptimality of Gradient Descent">optimal</fr:link> convergence rate <fr:tex
display="inline"><![CDATA[O(1/k^2)]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>711</fr:anchor><fr:addr
type="user">kak-004P</fr:addr><fr:route>kak-004P.xml</fr:route><fr:title
text="Convergence of accelerated GD">Convergence of accelerated GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. The iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by the accelerated GD method satisfy

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2(k+1)^{2}}\ ||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}^{2}\ =\ O(\frac {1}{k^{2}}).]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>712</fr:anchor><fr:addr
type="machine">#324</fr:addr><fr:route>unstable-324.xml</fr:route><fr:title
text="Line Search">Line Search</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr
type="user">kak-004Q</fr:addr><fr:route>kak-004Q.xml</fr:route><fr:title
text="Exact Linesearch">Exact Linesearch</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For 
<fr:tex
display="block"><![CDATA[x_{k+1}\ =\ x_{k}\ -\ \tau _{k}\cdot \nabla  f(x_{k})]]></fr:tex>
Choose step size by solving
<fr:tex
display="block"><![CDATA[\tau _{k}\;=\;\arg \operatorname *{min}_{t\geq 0}\;f({\mathbf {x}}_{k}-t\cdot \nabla  f({\mathbf {x}}_{k}))]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>715</fr:anchor><fr:addr
type="machine">#321</fr:addr><fr:route>unstable-321.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Way to computationally expensive to use in practice.</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>717</fr:anchor><fr:addr
type="user">kak-004R</fr:addr><fr:route>kak-004R.xml</fr:route><fr:title
text="Armijo Condition">Armijo Condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[c_1 \in  (0,1)]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f( \mathbf {x}_k + \tau _k \cdot  \mathbf {d}_k) < f( \mathbf {x}_k) + c_1 \cdot  \tau _k \cdot  \mathbf {d}_{k}^{\top } \nabla  f(\mathbf {x}_k)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr
type="user">kak-004S</fr:addr><fr:route>kak-004S.xml</fr:route><fr:title
text="Wolfe condition">Wolfe condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[0 < c_1 < c_2 < 1]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k}+\tau _{k}\cdot \mathbf {d}_{k})\ <\ f(\mathbf {x}_{k})+c_{1}\cdot \tau _{k}\cdot \mathbf {d}_{k}^{\intercal }\nabla  f(\mathbf {x}_{k})]]></fr:tex>
<fr:tex
display="block"><![CDATA[d_{k}^{\top }\nabla  f({\mathbf {x}}_{k}+\tau _{k}{\mathbf {d}}_{k})\ \geq \ c_{2}{\mathbf {d}}_{k}^{\top }\nabla  f({\mathbf {x}}_{k})]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>719</fr:anchor><fr:addr
type="machine">#322</fr:addr><fr:route>unstable-322.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Wolfe condition requires evaluating gradient of function each update to <fr:tex
display="inline"><![CDATA[\tau _k]]></fr:tex>. However,  <fr:link
type="local"
href="kak-004R.xml"
addr="kak-004R"
title="Armijo Condition">Armijo Condition</fr:link> only requires evaluating gradient once. Therefore, it is primarily used in practice.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr
type="machine">#323</fr:addr><fr:route>unstable-323.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Backtracking is not used in optimizing DNNs because even function evaluation is very expensive.
      </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>723</fr:anchor><fr:addr
type="user">kak-004T</fr:addr><fr:route>kak-004T.xml</fr:route><fr:title
text="Convergence of GD with backtracking">Convergence of GD with backtracking</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let the function <fr:tex
display="inline"><![CDATA[f(\pmb {x})]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex and <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-smooth. With backtracking

linesearch, the GD method converges with

<fr:tex
display="block"><![CDATA[f(\pmb {x}_k)-f(\pmb {x}_\star )\ \le \ \left (1-\min \left \{2c_1\mu ,\dfrac {2\alpha  c_1\mu }{L}\right \}\right )^k(f(\pmb {x}_0)-f(\pmb {x}_\star ))]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\pmb {x}_\star ]]></fr:tex> is the unique minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>724</fr:anchor><fr:addr
type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title
text="How function properties affect convergence">How function properties affect convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>726</fr:anchor><fr:addr
type="user">kak-004U</fr:addr><fr:route>kak-004U.xml</fr:route><fr:title
text="Linear convergence for strong convexity">Linear convergence for strong convexity</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be smooth and <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity"><fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex</fr:link>, and suppose its gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>. Choose a fixed step size <fr:tex
display="inline"><![CDATA[\tau _{k}\equiv \tau =\frac {2}{\mu +L}]]></fr:tex>, then

<fr:tex
display="block"><![CDATA[\left ||\mathbf {x}_{k}-\mathbf {x}_{\star }\right ||_{2}\ \leq \ \left (\frac {\kappa -1}{\kappa +1}\right )^{k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2},]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\kappa =\frac {L}{\mu }]]></fr:tex> is the condition number, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_{\star }]]></fr:tex> is the minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>727</fr:anchor><fr:addr
type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity">Strong convexity</fr:link> is a sufficient but not necessary condition for linear convergene of gradient descent.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>729</fr:anchor><fr:addr
type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:title
text="Newton and Quasi-Newton Method">Newton and Quasi-Newton Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>731</fr:anchor><fr:addr
type="user">kak-004V</fr:addr><fr:route>kak-004V.xml</fr:route><fr:title
text="Newton's Method">Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Consider <fr:link
type="local"
href="kak-003O.xml"
addr="kak-003O"
title="Second-order approximation">second-order taylor approximation</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>
<fr:tex
display="block"><![CDATA[ f(\mathbf {x}_{k}+\mathbf {d})\ \approx \ \underbrace {f(\mathbf {x}_{k})+\mathbf {d}^{\top }\nabla  f(\mathbf {x}_{k})+{\frac {1}{2}}\mathbf {d}^{\top }\nabla ^{2}f(\mathbf {x}_{k})\mathbf {d}}_{Q_k( \mathbf {d})}]]></fr:tex>
Then setting <fr:tex
display="inline"><![CDATA[\nabla  Q_k( \mathbf {d})]]></fr:tex> and solving for <fr:tex
display="inline"><![CDATA[\mathbf {d}]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[   \nabla  f( \mathbf {x}_k) + \frac {1}{2}\nabla ^2 f( \mathbf {x}_k) \mathbf {d} = 0 ]]></fr:tex>
Thus, take <fr:em>Newton's direction</fr:em>
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{N}=-\left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}\nabla  f(\mathbf {x}_{k}).]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>650</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Some notes
    <fr:ul><fr:li><fr:strong>Fast convergence:</fr:strong> Newton's method usually has local quadratic convergence.</fr:li>
      <fr:li><fr:strong>Expensive:</fr:strong> requires storing and inverting <fr:tex
display="inline"><![CDATA[\nabla ^2 f( \mathbf {x})]]></fr:tex>.</fr:li>
      <fr:li><fr:strong>Unstable:</fr:strong> <fr:tex
display="inline"><![CDATA[\nabla ^2 f \succ  0]]></fr:tex> might not hold for general nonlinear problems.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>732</fr:anchor><fr:addr
type="user">kak-004W</fr:addr><fr:route>kak-004W.xml</fr:route><fr:title
text="Quasi-Newton's Method">Quasi-Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Get around computing and inverting hessian by using a surrogate i.e. 
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{QN}=-\underbrace {\mathbf {H}_k}_{\text {surrogate for } \left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}} \nabla  f(\mathbf {x}_{k}).]]></fr:tex>
Want
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}^{-1}\cdot \underbrace {({\mathbf {x}}_{k+1}-{\mathbf {x}}_{k})}_{{\mathbf {s}}_{k}}\;=\;\underbrace {\nabla  f({\mathbf {x}}_{k+1})-\nabla  f({\mathbf {x}}_{k})}_{{\mathbf {y}}_{k}}]]></fr:tex>
BFGS rank-2 update:
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}\ =\ {\mathbf {H}}_{k}+{\frac {\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}+{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}{\mathbf {y}}_{k}\right ){\mathbf {s}}_{k}{\mathbf {s}}_{k}^{\top }}{\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}\right )^{2}}}-{\frac {{\mathbf {H}}_{k}{\mathbf {y}}_{k}{\mathbf {s}}_{k}^{\top }+{\mathbf {s}}_{k}{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}}{{\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}}}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3589</fr:anchor><fr:addr
type="user">kak-0033</fr:addr><fr:route>kak-0033.xml</fr:route><fr:title
text="Optimization Theory">Optimization Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>660</fr:anchor><fr:addr
type="machine">#310</fr:addr><fr:route>unstable-310.xml</fr:route><fr:title
text="Convex Optimization Background">Convex Optimization Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>662</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>663</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p><fr:strong>Operations that preserve convexity</fr:strong>
<fr:ul><fr:li><fr:strong>Nonnegative weighted sums:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex
display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</fr:li>
    <fr:li><fr:strong>Pointwise maximum:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex</fr:li></fr:ul></fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>664</fr:anchor><fr:addr
type="user">kak-0036</fr:addr><fr:route>kak-0036.xml</fr:route><fr:title
text="Strong convexity">Strong convexity</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex if and only if 
<fr:tex
display="block"><![CDATA[g(\boldsymbol {x}) = f(\boldsymbol {x}) - \frac {\mu }{2} ||\boldsymbol {x}||_2^2]]></fr:tex>
is convex, <fr:tex
display="inline"><![CDATA[\forall  \boldsymbol {x} \in  \mathrm {dom} f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>665</fr:anchor><fr:addr
type="user">kak-0037</fr:addr><fr:route>kak-0037.xml</fr:route><fr:title
text="Smooth Problem">Smooth Problem</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A problem is <fr:em>smooth</fr:em> if both the objective function and the constraints are differentiable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>666</fr:anchor><fr:addr
type="user">kak-0038</fr:addr><fr:route>kak-0038.xml</fr:route><fr:title
text="Subgradient">Subgradient</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> be convex. A <fr:em>subgradient</fr:em> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\boldsymbol {u}]]></fr:tex> satisfying
<fr:tex
display="block"><![CDATA[f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>667</fr:anchor><fr:addr
type="user">kak-0039</fr:addr><fr:route>kak-0039.xml</fr:route><fr:title
text="Subdifferential">Subdifferential</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>subdifferential</fr:em> is the set of all <fr:link
type="local"
href="kak-0038.xml"
addr="kak-0038"
title="Subgradient">subgradient's</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex>.
<fr:tex
display="block"><![CDATA[\partial  f(\boldsymbol {x}_0) \coloneqq  \{\boldsymbol {u} | f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle  \}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>668</fr:anchor><fr:addr
type="machine">#318</fr:addr><fr:route>unstable-318.xml</fr:route><fr:title
text="Useful Miscellanous Math Background">Useful Miscellanous Math Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>In this section, we cover many random math facts / tools that come up / are useful in later optimization problems.</fr:p>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>670</fr:anchor><fr:addr
type="machine">#311</fr:addr><fr:route>unstable-311.xml</fr:route><fr:title
text="Basic Matrix Analysis">Basic Matrix Analysis</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:ul><fr:li><fr:strong>Matrix inner product:</fr:strong>
<fr:tex
display="block"><![CDATA[\langle \mathbf {x},\mathbf {z}\rangle \ =\ \sum _{i=1}^{n}x_{i}z_{i}\quad \Longrightarrow \quad \langle \mathbf {X},\mathbf {Z}\rangle \ :=\ \sum _{i=1}^{m}\sum _{j=1}^{n}X_{i j}Z_{i j}]]></fr:tex></fr:li>
    <fr:li><fr:strong>Matrix trace:</fr:strong> <fr:tex
display="inline"><![CDATA[{{M}}\in \mathbb {R}^{n\times  n};\ {{\mathrm {tr}}}({{M}}):=\sum _{i=1}^{n}M_{i i}]]></fr:tex>
    <fr:tex
display="block"><![CDATA[       \begin {align*}       &\langle {\boldsymbol  X},{\boldsymbol  Z}\rangle \ =\ \mathrm {tr}\left ({\boldsymbol  X}^{\top }{\boldsymbol  Z}\right )\ =\ \mathrm {tr}\left ({\boldsymbol  X}{\boldsymbol  Z}^{\top }\right ) \\     &\operatorname {tr}(\mathbf {A}\mathbf {B})=\operatorname {tr}(\mathbf {B}\mathbf {A})\\       &\operatorname {tr}(\mathbf {A}_{1}\mathbf {A}_{2}\cdots \mathbf {A}_{n})=\operatorname {tr}(\mathbf {A}_{\pi (1)}\mathbf {A}_{\pi (2)}\cdots \mathbf {A}_{\pi (n)})       \end {align*}     ]]></fr:tex>
    Where <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex> is a cyclic permutation on <fr:tex
display="inline"><![CDATA[\{1,2,\cdots ,n\}]]></fr:tex></fr:li></fr:ul>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr
type="user">kak-003A</fr:addr><fr:route>kak-003A.xml</fr:route><fr:title
text="Positive (semi)definiteness">Positive (semi)definiteness</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:em>symmetric</fr:em> matrix <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{n\times  n}]]></fr:tex> is <fr:em>positive definite</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}>0]]></fr:tex> for all nonzero <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. It is <fr:em>positive semidefinite (p.s.d.)</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}\geq 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>673</fr:anchor><fr:addr
type="user">kak-003B</fr:addr><fr:route>kak-003B.xml</fr:route><fr:title
text="Singular Value Decomposition">Singular Value Decomposition</fr:title><fr:taxon>Fact</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\operatorname {rank}(\mathbf {A})=r]]></fr:tex>. There exist <fr:tex
display="inline"><![CDATA[\sigma _{1}\geq \sigma _{2}\geq \cdots \geq \sigma _{r}>0]]></fr:tex>, and matrices <fr:tex
display="block"><![CDATA[\mathbf {U}\in \mathbb {R}^{m\times  r},\ \mathbf {V}\in \mathbb {R}^{n\times  r},]]></fr:tex> with <fr:em>orthonormal</fr:em> columns <fr:tex
display="inline"><![CDATA[(\mathbf {U}^{\top }\mathbf {U}=\mathbf {I},\ \mathbf {V}^{\top }\mathbf {V}=\mathbf {I})]]></fr:tex> such that <fr:tex
display="block"><![CDATA[\mathbf {A}\ =\ \mathbf {U}\mathbf {\Sigma }\mathbf {V}^{\top }\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }\,,\quad \mathbf {\Sigma }\ =\ \operatorname {diag}\left (\sigma _{1},\cdots ,\sigma _{r}\right ).]]></fr:tex></fr:p><fr:p>Relationship between eigen decomposition and SVD
  <fr:ul><fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {V}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}^T\boldsymbol {A}]]></fr:tex></fr:li>
      <fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {U}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}\boldsymbol {A}^T]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[{{\sigma _{i}({\mathbf {A}})}}={\sqrt {\lambda _{i}({{{\mathbf {A}}{\mathbf {A}}^{\mathsf {T}}}})}}={\sqrt {\lambda _{i}({\mathbf {A}}^{\mathsf {T}}{\mathbf {A}})}}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>674</fr:anchor><fr:addr
type="user">kak-003C</fr:addr><fr:route>kak-003C.xml</fr:route><fr:title
text="Best rank-r approximation">Best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with SVD, <fr:tex
display="inline"><![CDATA[\mathbf {A}=\sum _{i=1}^{\min \{m,n\}}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }]]></fr:tex>. Then an optimal solution to the best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation problem <fr:tex
display="block"><![CDATA[\min _{\mathbf {X}}||\mathbf {X}-\mathbf {A}||_{2}\,,\quad \text {s.t.}\quad \text {rank}(\mathbf {X})\ \leq \ r]]></fr:tex> is the truncated SVD of the following form <fr:tex
display="block"><![CDATA[\boxed {\widehat {\mathbf {A}}_{r}\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }}\,,\ \ \text {if}\ \ \sigma _{r}>\sigma _{r+1}\,,\,\text {it is unique.}]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>675</fr:anchor><fr:addr
type="machine">#309</fr:addr><fr:route>unstable-309.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Suppose <fr:tex
display="inline"><![CDATA[m \geq  n]]></fr:tex>, then we observe that
<fr:tex
display="block"><![CDATA[\left |\left |{\widehat {\mathbf {A}}}_{r}-{\mathbf {A}}\right |\right |_{2}\;=\;\left |\left |\sum _{i=r+1}^{n}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\mathsf {T}}\right |\right |_{2} \leq  \sigma _{r+1}]]></fr:tex>

Second, to prove our result, we want to show that <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {B}_{r}-\mathbf {A}\right |\right |_{2}\ \geq \ \sigma _{r+1},\quad \forall \mathbf {B}_{r}\ \text {with}\ \mathrm {rank}(\mathbf {B}_{r})=r.]]></fr:tex> We suppose <fr:tex
display="inline"><![CDATA[\ \mathbf {B}_{r}=\widetilde {\mathbf {U}}\widetilde {\mathbf {V}}^{\top },\quad \widetilde {\mathbf {U}}\in \mathbb {R}^{m\times  r},\ \widetilde {\mathbf {V}}\in \mathbb {R}^{n\times  r}.]]></fr:tex>
Note
<fr:tex
display="block"><![CDATA[ \begin {align*} ||\mathbf {B}_r - A||_2^2 &= \sup _{||\boldsymbol {z}||_2 \leq  1} ||(\mathbf {B}_r - \mathbf {A})\mathbf {z}||_2^2 \\ &\geq  ||(\mathbf {B}_r - \mathbf {A})\mathbf {w}||_2^2 \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\widetilde {V}]]></fr:tex> has <fr:tex
display="inline"><![CDATA[r]]></fr:tex> columns, then there must be a nontrivial linear combination of the first <fr:tex
display="inline"><![CDATA[r{+}1]]></fr:tex> columns of <fr:tex
display="inline"><![CDATA[V]]></fr:tex>, i.e., <fr:tex
display="block"><![CDATA[\mathbf {w}=\gamma _{1}\mathbf {v}_{1}+\cdots +\gamma _{r+1}\mathbf {v}_{r+1}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\widetilde {V}^{\top }\mathbf {w}=\mathbf {0}\,.]]></fr:tex> Wlog, we can scale <fr:tex
display="inline"><![CDATA[\left |\left |\mathbf {w}\right |\right |_{2}=1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\,\sum _{i=1}^{r+1}\gamma _{i}^{2}=1]]></fr:tex>
Then 
<fr:tex
display="block"><![CDATA[||\mathbf {A}-\mathbf {B}_{k}||_{2}^{2}\geq ||(\mathbf {A}-\mathbf {B}_{k})\,\mathbf {w}||_{2}^{2}=||\mathbf {A}\mathbf {w}||_{2}^{2}=\gamma _{1}^{2}\sigma _{1}^{2}+\cdots +\gamma _{r+1}^{2}\sigma _{r+1}^{2}\geq \sigma _{r+1}^{2}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>676</fr:anchor><fr:addr
type="user">kak-003G</fr:addr><fr:route>kak-003G.xml</fr:route><fr:title
text="Matrix Operator Norm">Matrix Operator Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{a}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{b}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathbb {R}^{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {R}^{m}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {A}\right |\right |_{a\to  b}\ :=\ \sup _{\left |\left |\mathbf {x}\right |\right |_{a}\leq  1}\left |\left |\mathbf {A}\mathbf {x}\right |\right |_{b}.]]></fr:tex>
It satisfies the <fr:em>three criteria</fr:em> for norm, and is <fr:em>submultiplicative</fr:em> <fr:tex
display="block"><![CDATA[||\boldsymbol {A}\boldsymbol {B}||_{a\to  b}\ \leq \ ||\boldsymbol {A}||_{a\to  b}\cdot  ||\boldsymbol {B}||_{a\to  b};]]></fr:tex>. 
<fr:tex
display="block"><![CDATA[||{\cal  A}||_{2\to 2}\;=\;\sigma _{1}({\cal  A})\;\;(\mathrm {{spectral\ norm}},\;\mathrm {{write\ as}}\;||{\cal  A}||\;\;);\;]]></fr:tex>
<fr:tex
display="block"><![CDATA[\begin {array}{l}{{||{\boldsymbol {A}}||_{1\to  b}\ =\ \operatorname *{max}_{j=1,\cdots ,n}||{\boldsymbol {A e}}_{j}||_{b}}}\\ {{||{\boldsymbol {A}}||_{a\to \infty }\ =\ \operatorname *{max}_{i=1,\cdots ,m}||{\boldsymbol {e}}_{i}^{*}{\boldsymbol {A}}||_{b}^{*}\,,\ \ ||{\boldsymbol {v}}||_{b}^{*}\ :=\ \operatorname *{sup}_{||{\boldsymbol {u}}||_{b}\leq 1}\langle {\boldsymbol {u}},{\boldsymbol {v}}\rangle \,,}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>677</fr:anchor><fr:addr
type="user">kak-003H</fr:addr><fr:route>kak-003H.xml</fr:route><fr:title
text="Unitary Invariant Matrix Norm">Unitary Invariant Matrix Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}.]]></fr:tex> We say the matrix norm is unitary invariant if <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{\sharp }\ =\ \left ||\mathbf {PAQ}\right ||_{\sharp },\quad \forall \ \mathbf {P}\in  O(m),\ \mathbf {Q}\in  O(n).]]></fr:tex></fr:p><fr:p>Eg.
  <fr:ul><fr:li><fr:strong>Spectral norm</fr:strong> <fr:tex
display="block"><![CDATA[||A||_{2 \to  2}=\sigma _{1}(A)=||\sigma (A)||_{\infty }]]></fr:tex></fr:li>
    <fr:li><fr:strong>Frobenius norm</fr:strong> <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{F}\ =\ \sqrt {\sum _{i=1}^{\min \{m,n\}}\sigma _{i}^{2}(\mathbf {A})}\ =\ \left ||\mathbf {\sigma }(\mathbf {A})\right ||_{2}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>678</fr:anchor><fr:addr
type="user">kak-003I</fr:addr><fr:route>kak-003I.xml</fr:route><fr:title
text="Schatten p-norm">Schatten <fr:tex
display="inline"><![CDATA[p]]></fr:tex>-norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[p \in  [1,+\infty ]]]></fr:tex>, the function <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}|\right |_{\mathrm {S}_{p}}\,:=\,\left ||\mathbf {\sigma }(\mathbf {A})|\right |_{p}]]></fr:tex> is a norm on <fr:tex
display="inline"><![CDATA[\,\mathbb {R}^{m\times  n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>679</fr:anchor><fr:addr
type="machine">#313</fr:addr><fr:route>unstable-313.xml</fr:route><fr:title
text="Taylor Expansion and Lipschitz Functions">Taylor Expansion and Lipschitz Functions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>681</fr:anchor><fr:addr
type="user">kak-003J</fr:addr><fr:route>kak-003J.xml</fr:route><fr:title
text="Lipschitz Continous">Lipschitz Continous</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f:\mathcal {X}\mapsto \mathcal {Y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> being open sets;</fr:li> 
  <fr:li><fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {X}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {Y}}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex>, respectively.</fr:li></fr:ul>
<fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex> is Lipschitz continuous over <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\exists  L<\infty \,,]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||f(\boldsymbol {y})-f(\boldsymbol {x})||_{\mathcal {Y}}\ \leq \ L(\boldsymbol {x})\,||\boldsymbol {y}-\boldsymbol {x}||_{\mathcal {X}}\,,\quad \forall \boldsymbol {x},\ \boldsymbol {y}\in \mathcal {X}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>682</fr:anchor><fr:addr
type="user">kak-003K</fr:addr><fr:route>kak-003K.xml</fr:route><fr:title
text="Smooth Function">Smooth Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A differentiable function <fr:tex
display="inline"><![CDATA[f(\mathbf {x})]]></fr:tex> is called smooth iff it has a Lipschitz continuous gradient, i.e., iff <fr:tex
display="inline"><![CDATA[L< \infty ]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x})-\nabla  f(\mathbf {z}) ||_{2}\ \leq  L ||\mathbf {x}-\mathbf {z} ||_{2},\quad  \forall  \mathbf {x},\ \mathbf {z}\in \mathbb {R}^{n}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>683</fr:anchor><fr:addr
type="user">kak-003L</fr:addr><fr:route>kak-003L.xml</fr:route><fr:title
text="Mean Value Theorem I">Mean Value Theorem I</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\,f(\mathbf {y})\,=\,f(\mathbf {x})\,+\,\langle \nabla  f(\mathbf {z}(t_{L})),\mathbf {y}-\mathbf {x}\rangle \,]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t_{L})=(1-t_{L})\cdot \mathbf {x}+t_{L}\cdot \mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t_{L}\in (0,1)\,]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>684</fr:anchor><fr:addr
type="machine">#312</fr:addr><fr:route>unstable-312.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^n\mapsto \mathbb {R}]]></fr:tex> is continuously differentiable, <fr:tex
display="block"><![CDATA[\begin {aligned}      |f(\pmb {x})-f(\pmb {y})| &\leq  & \sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2 \, ||\pmb {x}-\pmb {y}||_2   \end {aligned}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2]]></fr:tex>.</fr:li>
          <fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is twice continuously differentiable, <fr:tex
display="block"><![CDATA[||\nabla  f(\boldsymbol {x})-\nabla  f(\boldsymbol {y})||_{2}\ \leq \ \sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}\,||\boldsymbol {x}-\boldsymbol {y}||_{2}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}]]></fr:tex></fr:li></fr:ul>
      </fr:mainmatter><fr:backmatter /></fr:tree>

      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>686</fr:anchor><fr:addr
type="user">kak-003M</fr:addr><fr:route>kak-003M.xml</fr:route><fr:title
text="Mean Value Theorem II">Mean Value Theorem II</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be twice continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {y})\;=\;\nabla  f(\mathbf {x})\,+\,\int _{0}^{1}\nabla ^{2}f(\mathbf {z}(t))\cdot (\mathbf {y}-\mathbf {x})dt]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t)=(1-t)\mathbf {x}+t\mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t\in (0,1)\,,]]></fr:tex> and that <fr:tex
display="block"><![CDATA[\boxed {f(\mathbf {y})\;=\;f(\mathbf {x})+(\nabla  f(\mathbf {x}),\mathbf {y}-\mathbf {x})+\frac {1}{2}(\mathbf {y}-\mathbf {x})^{\top }\nabla ^{2}f(\mathbf {z}(t_{Q}))(\mathbf {y}-\mathbf {x})}]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[t_{Q}\in (0,1)\,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>687</fr:anchor><fr:addr
type="user">kak-003N</fr:addr><fr:route>kak-003N.xml</fr:route><fr:title
text="First-order approximation">First-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be continuously differentiable, and <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{L}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{L}(\mathbf {x}_{0})}{2}\,||\mathbf {x}-\mathbf {x}_{0}||_{2}^{2}\,,]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\ :=\ f(\mathbf {x}_{0})\ +\ \langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle \,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>688</fr:anchor><fr:addr
type="user">kak-003O</fr:addr><fr:route>kak-003O.xml</fr:route><fr:title
text="Second-order approximation">Second-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be twice continuously differentiable, and suppose <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{Q}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{Q}(\mathbf {x}_{0})}{6}\left ||\mathbf {x}-\mathbf {x}_{0}\right ||_{2}^{3},]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0}):=f(\mathbf {x}_{0})+\langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle ]]></fr:tex> <fr:tex
display="block"><![CDATA[+\frac {1}{2}(\mathbf {x}-\mathbf {x}_{0})^{\top }\nabla ^{2}f(\mathbf {x}_{0})(\mathbf {x}-\mathbf {x}_{0}).]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>689</fr:anchor><fr:addr
type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title
text="Optimality Conditions">Optimality Conditions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>691</fr:anchor><fr:addr
type="user">kak-003P</fr:addr><fr:route>kak-003P.xml</fr:route><fr:title
text="Stationary point">Stationary point</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A point <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a stationary point of <fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex>, if <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.]]></fr:tex> Here, <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is also known as a critical point.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:ul><fr:li><fr:strong>First order necessary condition</fr:strong>:
    If <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[\ f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is continuously differentiable in an open neighborhood of <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[\boxed {\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.}]]></fr:tex>
    <fr:li><fr:strong>Second order necessary condition:</fr:strong>
    If <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is twice continuously differentiable in an open neighborhood around <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[(i)\ \nabla  f(\mathbf {x_{\star }})=\mathbf {0};]]></fr:tex> <fr:tex
display="block"><![CDATA[(ii)\ \nabla ^{2}f(\mathbf {x_{\star }})\succeq \mathbf {0}.]]></fr:tex>
    <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x_{\star }})\succ \mathbf {0}]]></fr:tex> then the above is a sufficient condition.</fr:li></fr:ul></fr:li></fr:li></fr:ul>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>692</fr:anchor><fr:addr
type="machine">#314</fr:addr><fr:route>unstable-314.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be a convex function, then 
  <fr:ul><fr:li>A local minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is also its global minimizer. If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is strictly convex, the global minimizer is unique</fr:li>
    <fr:li>A point is a global minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> iff <fr:tex
display="block"><![CDATA[\mathbf {0}\ \in \ \partial  f(\mathbf {x_{\star }}).]]></fr:tex></fr:li></fr:ul>
  If <fr:tex
display="inline"><![CDATA[f\in \mathcal {C}^{1}]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x_{\star }})=\mathbf {0}]]></fr:tex> implies that <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a global minimizer.
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>694</fr:anchor><fr:addr
type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title
text="Constrained Case">Constrained Case</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider a smooth contained problem with <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}}f(\mathbf {x}),\quad  \text {s.t.} \quad  r_{i}(\mathbf {x})\ =\ 0,\ 1\leq  i\leq  p,]]></fr:tex> <fr:tex
display="block"><![CDATA[h_{j}(\mathbf {x})\ \leq \ 0,\ 1\leq  j\leq  q.]]></fr:tex> Consider its Lagrangian function <fr:tex
display="block"><![CDATA[\mathscr {L}(\mathbf {x},\mathbf {u},\mathbf {v})\ =\ f(\mathbf {x})+\sum _{i=1}^{p}u_{i}\cdot  r_{i}(\mathbf {x})+\sum _{j=1}^{q}v_{j}\cdot  h_{j}(\mathbf {x}).]]></fr:tex>
    <fr:strong>KKT-conditions:</fr:strong>
    <fr:ul><fr:li>Stationary <fr:tex
display="block"><![CDATA[\nabla _{\mathbf {x}}{\mathcal {L}}(\mathbf {x_*},\mathbf {u_*},\mathbf {v_*})\;=\;\mathbf {0}]]></fr:tex></fr:li>
    <fr:li>Primal Feasibility: <fr:tex
display="block"><![CDATA[\begin {array}{l}{{r_{i}(x_{\star })\ =\ 0,\ 1\leq  i\leq  p,}}\\ {{h_{j}(x_{\star })\ \leq \ 0,\ 1\leq  j\leq  q.}}\end {array}]]></fr:tex></fr:li>
    <fr:li>Dual Feasibility: <fr:tex
display="block"><![CDATA[v_{\star }\geq  0.]]></fr:tex></fr:li>
    <fr:li>Complimentary slackness: <fr:tex
display="block"><![CDATA[h_{j}(x_{\star })\cdot  v_{\star  j}\ =\ 0,\quad \forall \ 1\leq  j\leq  q.]]></fr:tex></fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>696</fr:anchor><fr:addr
type="machine">#317</fr:addr><fr:route>unstable-317.xml</fr:route><fr:title
text="Rate of Convergence">Rate of Convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Want to find
<fr:tex
display="block"><![CDATA[\operatorname *{min}_{\mathbf {x}}\ f(\mathbf {x}),\quad \text {s.t.}\quad \mathbf {x}\ \in \ \mathcal {C}.]]></fr:tex> Solve the problem via iterative methods of optimization, which produce a sequence of points <fr:tex
display="block"><![CDATA[\mathbf {x}_{1},\ \mathbf {x}_{2},\ \cdots ,\mathbf {x}_{k},\cdots ]]></fr:tex> starting from an initialization <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>.</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>698</fr:anchor><fr:addr
type="user">kak-003R</fr:addr><fr:route>kak-003R.xml</fr:route><fr:title
text="First-order convergence">First-order convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>First-order function value convergence 
     <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x}_k)||_2 \; \leq  \; \varepsilon .]]></fr:tex>
       <fr:ul><fr:li>For convex functions, this also means convergence to the global minimizer</fr:li>
        <fr:li>For nonconvex functions, this only means   convergence to a <fr:link
type="local"
href="kak-003P.xml"
addr="kak-003P"
title="Stationary point">Stationary point</fr:link> (e.g., a local minimizer or a saddle point).</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>699</fr:anchor><fr:addr
type="user">kak-003Q</fr:addr><fr:route>kak-003Q.xml</fr:route><fr:title
text="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[(p \geq 1)]]></fr:tex> and with factor <fr:tex
display="inline"><![CDATA[(\gamma  > 0)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[\exists  k_{0}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\forall  k\geq  k_{0}]]></fr:tex>: <fr:tex
display="block"><![CDATA[\boxed {\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k}}-\mathbf {x_{*}}||_{2}\ \leq \ \gamma \cdot \left (\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k-1}}-\mathbf {x_{*}}||_{2}\right )^{p}.}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>700</fr:anchor><fr:addr
type="user">kak-003S</fr:addr><fr:route>kak-003S.xml</fr:route><fr:title
text="R-convergence"><fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[p\;(\geq 1)]]></fr:tex>, <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}_{*}\in \mathcal {X}}||\mathbf {x}_{k}-\mathbf {x}_{*}||_{2}\;\leq \;\rho _{k},]]></fr:tex> if the sequence <fr:tex
display="inline"><![CDATA[\{\rho _{k}\}_{k\geq 1}]]></fr:tex> is <fr:link
type="local"
href="kak-003Q.xml"
addr="kak-003Q"
title="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:link> of the order <fr:tex
display="inline"><![CDATA[p]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>701</fr:anchor><fr:addr
type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:title
text="Iterative Methods">Iterative Methods</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:strong>Assume:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">Convex Function</fr:link> and a <fr:link
type="local"
href="kak-003K.xml"
addr="kak-003K"
title="Smooth Function">Smooth Function</fr:link>.</fr:li>
      <fr:li>The gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>.</fr:li></fr:ul>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>703</fr:anchor><fr:addr
type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title
text="Convergence of Gradient Descent">Convergence of Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>705</fr:anchor><fr:addr
type="user">kak-004L</fr:addr><fr:route>kak-004L.xml</fr:route><fr:title
text="Sufficient Value">Sufficient Value</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>With step size <fr:tex
display="inline"><![CDATA[\tau _{k}=1/L\,,]]></fr:tex> the gradient descent iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathbf {x}_{k}\ -\ \tau _{k}\cdot \nabla  f(\mathbf {x}_{k})]]></fr:tex>

satisfy the following:

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k+1})\ \leq \ f(\mathbf {x}_{k})\ -\ \frac {1}{2L}\,||\nabla  f(\mathbf {x}_{k})||_{2}^{2}]]></fr:tex> <fr:tex
display="block"><![CDATA[<\ f(\mathbf {x}_{k})\quad (||\nabla  f(\mathbf {x}_{k})||_{2}\neq 0)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>656</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Because <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is Lipschitz, by 1st-order Taylor approximation

<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})+\langle \nabla  f(\mathbf {x}),\mathbf {x}^{\prime }-\mathbf {x}\rangle +\frac {L}{2}\left ||\mathbf {x}^{\prime }-\mathbf {x}\right ||_{2}^{2},\quad \forall \ \mathbf {x}^{\prime },\mathbf {x}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \tau  \nabla  f( \mathbf {x})]]></fr:tex>. Then
<fr:tex
display="block"><![CDATA[   \begin {align*}     f(\mathbf {x}^{\prime }) &\leq  f(\mathbf {x})+ \tau  ||\nabla  f( \mathbf {x} )||_2^2 + \frac {\tau ^2 L}{2} ||\nabla  f( \mathbf {x})||_2^2 \\     &= f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2   \end {align*} ]]></fr:tex>
  Take <fr:tex
display="inline"><![CDATA[\tau  = \frac {1}{L}]]></fr:tex>, such that
<fr:tex
display="block"><![CDATA[     \begin {align*} f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2 &= f( \mathbf {x}) - \frac {1}{2L}||\nabla  f( \mathbf {x})||_2^2     \end {align*}   ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>706</fr:anchor><fr:addr
type="user">kak-004M</fr:addr><fr:route>kak-004M.xml</fr:route><fr:title
text="Sublinear convergence of GD">Sublinear convergence of GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. If we run GD for <fr:tex
display="inline"><![CDATA[k]]></fr:tex> iterations with a fixed step size <fr:tex
display="inline"><![CDATA[\tau =1/L]]></fr:tex>, it will yield a sequence <fr:tex
display="inline"><![CDATA[\left \{\mathbf {x}_{k}\right \}_{k\geq 1}]]></fr:tex> such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}\ =\ O(\frac {1}{k}),]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>653</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Given <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex and smooth, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_*]]></fr:tex> is an optimal solution, then
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{\star })\geq  f(\mathbf {x})+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}_{\star }-\mathbf {x})]]></fr:tex>
Flipping the inequality yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x})\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })]]></fr:tex>
By <fr:link
type="local"
href="kak-004L.xml"
addr="kak-004L"
title="Sufficient Value">previous lemma</fr:link>, taking <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \frac {1}{L} \nabla  f( \mathbf {x})]]></fr:tex> yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
such that
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
Equivalently,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })\leq {\frac {L}{2}}\left [{\frac {2}{L}}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{L^{2}}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ]]]></fr:tex>
Completing the square,
<fr:tex
display="block"><![CDATA[ \begin {align*}  f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })&\leq \frac {L}{2}\left [\frac {2}{L}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-\frac {1}{L^{2}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}-\frac {1}{L}\nabla  f(\mathbf {x})-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}^{\prime }-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \end {align*} ]]></fr:tex>
Let <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}=\mathbf {x}_{k-1}-\frac {1}{L}\nabla  f(\mathbf {x}_{k-1})]]></fr:tex>, then we have

<fr:tex
display="block"><![CDATA[ \begin {align*}  \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right ) &\leq  \frac {L}{2}\sum _{i=1}^{k}\left [\left ||\mathbf {x}_{i-1}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{i}-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]  \\ &=\frac {L}{2}\left [\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{k}-\mathbf {x}_{0}\right ||_{2}^{2}\right ] \\   &\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}  \end {align*} ]]></fr:tex>
Therefore, given <fr:tex
display="inline"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\leq  f(\mathbf {x}_{i})-f(\mathbf {x}_{*}) \text { for } \forall  i\leq  k\,,]]></fr:tex>

<fr:tex
display="block"><![CDATA[k\left (f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\right )\leq \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right )\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>707</fr:anchor><fr:addr
type="user">kak-004N</fr:addr><fr:route>kak-004N.xml</fr:route><fr:title
text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose the iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <fr:em>black-box model</fr:em>:

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></fr:p><fr:p>For every positive <fr:tex
display="inline"><![CDATA[L]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">convex</fr:link> differentiable <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>708</fr:anchor><fr:addr
type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title
text="Accelerated Gradient Descent">Accelerated Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>710</fr:anchor><fr:addr
type="user">kak-004O</fr:addr><fr:route>kak-004O.xml</fr:route><fr:title
text="Nesterov's Method">Nesterov's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Generate two sequences <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}{\mathrm {~and~}}\{\mathbf {p}_{k}\}_{k\geq 1}]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*} {\mathbf {\mathit {p}}}_{k+1}\ &=\ {\mathbf {\mathit {x}}}_{k}\ +\ \beta _{k}\cdot ({\mathbf {\mathit {x}}}_{k}-{\mathbf {\mathit {x}}}_{k-1}), \\ x_{k+1} &= p_{k+1}-\alpha \nabla  f(p_{k+1}) \end {align*} ]]></fr:tex>
<fr:ul><fr:li><fr:strong>Not</fr:strong> a descent method.</fr:li>
<fr:li>With properly chosen <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\beta ]]></fr:tex> can achieve <fr:link
type="local"
href="kak-004N.xml"
addr="kak-004N"
title="Suboptimality of Gradient Descent">optimal</fr:link> convergence rate <fr:tex
display="inline"><![CDATA[O(1/k^2)]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>711</fr:anchor><fr:addr
type="user">kak-004P</fr:addr><fr:route>kak-004P.xml</fr:route><fr:title
text="Convergence of accelerated GD">Convergence of accelerated GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. The iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by the accelerated GD method satisfy

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2(k+1)^{2}}\ ||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}^{2}\ =\ O(\frac {1}{k^{2}}).]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>712</fr:anchor><fr:addr
type="machine">#324</fr:addr><fr:route>unstable-324.xml</fr:route><fr:title
text="Line Search">Line Search</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr
type="user">kak-004Q</fr:addr><fr:route>kak-004Q.xml</fr:route><fr:title
text="Exact Linesearch">Exact Linesearch</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For 
<fr:tex
display="block"><![CDATA[x_{k+1}\ =\ x_{k}\ -\ \tau _{k}\cdot \nabla  f(x_{k})]]></fr:tex>
Choose step size by solving
<fr:tex
display="block"><![CDATA[\tau _{k}\;=\;\arg \operatorname *{min}_{t\geq 0}\;f({\mathbf {x}}_{k}-t\cdot \nabla  f({\mathbf {x}}_{k}))]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>715</fr:anchor><fr:addr
type="machine">#321</fr:addr><fr:route>unstable-321.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Way to computationally expensive to use in practice.</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>717</fr:anchor><fr:addr
type="user">kak-004R</fr:addr><fr:route>kak-004R.xml</fr:route><fr:title
text="Armijo Condition">Armijo Condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[c_1 \in  (0,1)]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f( \mathbf {x}_k + \tau _k \cdot  \mathbf {d}_k) < f( \mathbf {x}_k) + c_1 \cdot  \tau _k \cdot  \mathbf {d}_{k}^{\top } \nabla  f(\mathbf {x}_k)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr
type="user">kak-004S</fr:addr><fr:route>kak-004S.xml</fr:route><fr:title
text="Wolfe condition">Wolfe condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[0 < c_1 < c_2 < 1]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k}+\tau _{k}\cdot \mathbf {d}_{k})\ <\ f(\mathbf {x}_{k})+c_{1}\cdot \tau _{k}\cdot \mathbf {d}_{k}^{\intercal }\nabla  f(\mathbf {x}_{k})]]></fr:tex>
<fr:tex
display="block"><![CDATA[d_{k}^{\top }\nabla  f({\mathbf {x}}_{k}+\tau _{k}{\mathbf {d}}_{k})\ \geq \ c_{2}{\mathbf {d}}_{k}^{\top }\nabla  f({\mathbf {x}}_{k})]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>719</fr:anchor><fr:addr
type="machine">#322</fr:addr><fr:route>unstable-322.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Wolfe condition requires evaluating gradient of function each update to <fr:tex
display="inline"><![CDATA[\tau _k]]></fr:tex>. However,  <fr:link
type="local"
href="kak-004R.xml"
addr="kak-004R"
title="Armijo Condition">Armijo Condition</fr:link> only requires evaluating gradient once. Therefore, it is primarily used in practice.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr
type="machine">#323</fr:addr><fr:route>unstable-323.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Backtracking is not used in optimizing DNNs because even function evaluation is very expensive.
      </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>723</fr:anchor><fr:addr
type="user">kak-004T</fr:addr><fr:route>kak-004T.xml</fr:route><fr:title
text="Convergence of GD with backtracking">Convergence of GD with backtracking</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let the function <fr:tex
display="inline"><![CDATA[f(\pmb {x})]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex and <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-smooth. With backtracking

linesearch, the GD method converges with

<fr:tex
display="block"><![CDATA[f(\pmb {x}_k)-f(\pmb {x}_\star )\ \le \ \left (1-\min \left \{2c_1\mu ,\dfrac {2\alpha  c_1\mu }{L}\right \}\right )^k(f(\pmb {x}_0)-f(\pmb {x}_\star ))]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\pmb {x}_\star ]]></fr:tex> is the unique minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>724</fr:anchor><fr:addr
type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title
text="How function properties affect convergence">How function properties affect convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>726</fr:anchor><fr:addr
type="user">kak-004U</fr:addr><fr:route>kak-004U.xml</fr:route><fr:title
text="Linear convergence for strong convexity">Linear convergence for strong convexity</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be smooth and <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity"><fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex</fr:link>, and suppose its gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>. Choose a fixed step size <fr:tex
display="inline"><![CDATA[\tau _{k}\equiv \tau =\frac {2}{\mu +L}]]></fr:tex>, then

<fr:tex
display="block"><![CDATA[\left ||\mathbf {x}_{k}-\mathbf {x}_{\star }\right ||_{2}\ \leq \ \left (\frac {\kappa -1}{\kappa +1}\right )^{k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2},]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\kappa =\frac {L}{\mu }]]></fr:tex> is the condition number, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_{\star }]]></fr:tex> is the minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>727</fr:anchor><fr:addr
type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity">Strong convexity</fr:link> is a sufficient but not necessary condition for linear convergene of gradient descent.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>729</fr:anchor><fr:addr
type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:title
text="Newton and Quasi-Newton Method">Newton and Quasi-Newton Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>731</fr:anchor><fr:addr
type="user">kak-004V</fr:addr><fr:route>kak-004V.xml</fr:route><fr:title
text="Newton's Method">Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Consider <fr:link
type="local"
href="kak-003O.xml"
addr="kak-003O"
title="Second-order approximation">second-order taylor approximation</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>
<fr:tex
display="block"><![CDATA[ f(\mathbf {x}_{k}+\mathbf {d})\ \approx \ \underbrace {f(\mathbf {x}_{k})+\mathbf {d}^{\top }\nabla  f(\mathbf {x}_{k})+{\frac {1}{2}}\mathbf {d}^{\top }\nabla ^{2}f(\mathbf {x}_{k})\mathbf {d}}_{Q_k( \mathbf {d})}]]></fr:tex>
Then setting <fr:tex
display="inline"><![CDATA[\nabla  Q_k( \mathbf {d})]]></fr:tex> and solving for <fr:tex
display="inline"><![CDATA[\mathbf {d}]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[   \nabla  f( \mathbf {x}_k) + \frac {1}{2}\nabla ^2 f( \mathbf {x}_k) \mathbf {d} = 0 ]]></fr:tex>
Thus, take <fr:em>Newton's direction</fr:em>
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{N}=-\left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}\nabla  f(\mathbf {x}_{k}).]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>650</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Some notes
    <fr:ul><fr:li><fr:strong>Fast convergence:</fr:strong> Newton's method usually has local quadratic convergence.</fr:li>
      <fr:li><fr:strong>Expensive:</fr:strong> requires storing and inverting <fr:tex
display="inline"><![CDATA[\nabla ^2 f( \mathbf {x})]]></fr:tex>.</fr:li>
      <fr:li><fr:strong>Unstable:</fr:strong> <fr:tex
display="inline"><![CDATA[\nabla ^2 f \succ  0]]></fr:tex> might not hold for general nonlinear problems.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>732</fr:anchor><fr:addr
type="user">kak-004W</fr:addr><fr:route>kak-004W.xml</fr:route><fr:title
text="Quasi-Newton's Method">Quasi-Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Get around computing and inverting hessian by using a surrogate i.e. 
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{QN}=-\underbrace {\mathbf {H}_k}_{\text {surrogate for } \left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}} \nabla  f(\mathbf {x}_{k}).]]></fr:tex>
Want
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}^{-1}\cdot \underbrace {({\mathbf {x}}_{k+1}-{\mathbf {x}}_{k})}_{{\mathbf {s}}_{k}}\;=\;\underbrace {\nabla  f({\mathbf {x}}_{k+1})-\nabla  f({\mathbf {x}}_{k})}_{{\mathbf {y}}_{k}}]]></fr:tex>
BFGS rank-2 update:
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}\ =\ {\mathbf {H}}_{k}+{\frac {\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}+{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}{\mathbf {y}}_{k}\right ){\mathbf {s}}_{k}{\mathbf {s}}_{k}^{\top }}{\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}\right )^{2}}}-{\frac {{\mathbf {H}}_{k}{\mathbf {y}}_{k}{\mathbf {s}}_{k}^{\top }+{\mathbf {s}}_{k}{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}}{{\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}}}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3591</fr:anchor><fr:addr
type="user">kak-0031</fr:addr><fr:route>kak-0031.xml</fr:route><fr:title
text="Probability">Probability</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1653</fr:anchor><fr:addr
type="user">kak-003Z</fr:addr><fr:route>kak-003Z.xml</fr:route><fr:title
text="Stochastic Processes">Stochastic Processes</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:title
text="Markov Chains">Markov Chains</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>578</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:title
text="Definitions">Definitions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>580</fr:anchor><fr:addr
type="user">kak-0040</fr:addr><fr:route>kak-0040.xml</fr:route><fr:title
text="Markov Chain">Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say a stochastic process <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> is a Markov chain (MC) with transition matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> if for any <fr:tex
display="inline"><![CDATA[n \in  \mathcal {N}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{0}, \ldots  x_{n - 1}]]></fr:tex>
  <fr:tex
display="block"><![CDATA[ 		\mathbb {P}(X_{n + 1} = y \mid  X_{n} = x, X_{n - 1} = x_{n - 1}, \ldots , X_0 = x_0) = \mathbb {P}(X_{n + 1} = y \mid  X_n = x) = p(x, y)   ]]></fr:tex>
	whenever conditional probability is well-defined. 
	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>581</fr:anchor><fr:addr
type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Moreover, any matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[\sum _{y \in  \mathcal {S}} p(x, y) = 1]]></fr:tex> is called a stochastic matrix. Given any stochastic matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, one can create a MC.
</fr:mainmatter><fr:backmatter /></fr:tree>

	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>582</fr:anchor><fr:addr
type="machine">#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
		This is called a temporally homogeneous discrete Markov chain because <fr:tex
display="inline"><![CDATA[p]]></fr:tex> does not depend on time.
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>583</fr:anchor><fr:addr
type="user">kak-0041</fr:addr><fr:route>kak-0041.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th step transition probability <fr:tex
display="inline"><![CDATA[\mathbb {P}(X_{n + m} = y \mid  X_{n} = x)]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th power of transition matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, computed at <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>584</fr:anchor><fr:addr
type="user">kak-0042</fr:addr><fr:route>kak-0042.xml</fr:route><fr:title
text="Chapman-Kolmogorov Equation">Chapman-Kolmogorov Equation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[p^{m + n}(x,y) = \sum _{z \in  S} p^{m}(x,z) p^{n}(z,y)]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>585</fr:anchor><fr:addr
type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Note that
<fr:tex
display="block"><![CDATA[       \begin {align*}         p^{m + n}(x, y) &= \mathbb {P}(X_{m+n} = y \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y, X_{m} = z \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z, X_{0} = x) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} p^{n}(z, y) p^{m}(x, z)       \end {align*}     ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>586</fr:anchor><fr:addr
type="user">kak-0043</fr:addr><fr:route>kak-0043.xml</fr:route><fr:title
text="Stopping time">Stopping time</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[T : \Omega  \to  \mathbb {N} \cup  \{\infty \}]]></fr:tex> is a stopping time with respect to <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\{T = k\}]]></fr:tex> can be determined by <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{k}\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>587</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:title
text="Classification of States">Classification of States</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>589</fr:anchor><fr:addr
type="user">kak-0044</fr:addr><fr:route>kak-0044.xml</fr:route><fr:title
text="Strong Markov Property">Strong Markov Property</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> be a stopping time with respect to <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>, given <fr:tex
display="inline"><![CDATA[\{T < \infty , X_{T} = x\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X_{T + k}]]></fr:tex> is independent of <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{T}\}]]></fr:tex>. Moreover, 
<fr:tex
display="block"><![CDATA[\mathbb {P}(X_{T + k} \mid  T < \infty , X_T = x) = p^k(x,y)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>590</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  TODO
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>591</fr:anchor><fr:addr
type="user">kak-0045</fr:addr><fr:route>kak-0045.xml</fr:route><fr:title
text="Transient and recurrent states">Transient and recurrent states</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex> is recurrent if <fr:tex
display="inline"><![CDATA[\rho _{xx} = 1]]></fr:tex> and transient if <fr:tex
display="inline"><![CDATA[\rho _{xx} < 1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>592</fr:anchor><fr:addr
type="user">kak-0048</fr:addr><fr:route>kak-0048.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say <fr:tex
display="inline"><![CDATA[T_y]]></fr:tex> is a return time if <fr:tex
display="inline"><![CDATA[T_y = \inf  \{n \geq  1 \mid  X_n = y\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\rho _{xy} = \mathbb {P}(T_y < \infty )]]></fr:tex>. We write the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th return time as 
	<fr:tex
display="block"><![CDATA[T_{y}^{k} = \min  \{n > T_y^{k - 1} \mid  X_{n} = y\}]]></fr:tex>
  with <fr:tex
display="inline"><![CDATA[T_y^{1} \coloneqq  T_{y}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>593</fr:anchor><fr:addr
type="user">kak-0046</fr:addr><fr:route>kak-0046.xml</fr:route><fr:title
text="Communicates">Communicates</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x]]></fr:tex> communicates with <fr:tex
display="inline"><![CDATA[y]]></fr:tex> and denote it by <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\rho _{xy} > 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>594</fr:anchor><fr:addr
type="user">kak-0047</fr:addr><fr:route>kak-0047.xml</fr:route><fr:title
text="Transitivity of communcation">Transitivity of communcation</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	If <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y \to  z]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[x \to  z]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>595</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	By assumption, there exists <fr:tex
display="inline"><![CDATA[m, n \leq  t]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[p^{m}(x,y) > 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[p^n(y,z) > 0]]></fr:tex>. Then 
  <fr:tex
display="block"><![CDATA[ 	\begin {align*} 		p^{m + n}(x, z) &= \sum _{k \in  S} p^{m}(x, k)p^{n}(k,z) \\ 										&\geq  p^{m}(x,y)p^{n}(y,z) \quad  \quad  (\text {Strong Markov})\\  										&> 0 	\end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>596</fr:anchor><fr:addr
type="user">kak-0049</fr:addr><fr:route>kak-0049.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Suppose <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_{y} \leq  k) \geq  a > 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_y \geq  mk) \leq  (1-a)^m]]></fr:tex>, <fr:tex
display="inline"><![CDATA[m \in  \mathbb {N}]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>597</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Define <fr:tex
display="inline"><![CDATA[X_{n}^{(1)} = X_{k + n}, \ldots , X_{n}^{(m-1)} = X_{(m-1)k + n}]]></fr:tex>. Then define <fr:tex
display="inline"><![CDATA[T_{y}^{(1)}, \ldots , T_{y}^{(m-1)}]]></fr:tex> as the corresponding hitting times of state <fr:tex
display="inline"><![CDATA[y]]></fr:tex>. We have
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}_x(T_y > km) &= \mathbb {P}_{x}(T_y > k, T_y^{(1)} > k, \ldots , T_y^{(m-1)} > k) \\                             &\leq  \mathbb {P}_x(T_y > k, \ldots , T_y^{(m-1)} > k \mid  X_{k} \neq  y, \ldots , X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}_{x}(T_y > k)\mathbb {P}_x(T_y^{(1)} > k \mid  X_{k} \neq  y) \cdots  \mathbb {P}_x(T_y^{(m-1)} > k \mid  X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}(T_y > k)\left (\sum _{z \neq  y}\underbrace {\mathbb {P}_z(T_y > k)}_{\leq  (1-a)} \mathbb {P}_x(X_{k} = z \mid  X_{k} \neq  y)\right ) \\                             &\leq  (1-a)^{m}\underbrace {\sum _{z \neq  y}\mathbb {P}_x \left (X_k = z \mid  X_k \neq   y \right )}_{=1}     \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr
type="user">kak-0058</fr:addr><fr:route>kak-0058.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a finite closed and irreducible set, then all states in <fr:tex
display="inline"><![CDATA[C]]></fr:tex> are recurrent.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>599</fr:anchor><fr:addr
type="user">kak-0057</fr:addr><fr:route>kak-0057.xml</fr:route><fr:title
text="Decomposition Theorem">Decomposition Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is finite, then <fr:tex
display="inline"><![CDATA[S]]></fr:tex> can be written as a disjoint union <fr:tex
display="inline"><![CDATA[T\cup  R_{1}\cup \cdots \cup  R_{k}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[T]]></fr:tex> is a set of transient states and the <fr:tex
display="inline"><![CDATA[R_{i},\ 1\leq  i\leq  k]]></fr:tex>, are closed irreducible sets of recurrent states.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1655</fr:anchor><fr:addr
type="user">kak-0007</fr:addr><fr:route>kak-0007.xml</fr:route><fr:title
text="Notes on Probability and Measure">Notes on <fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">Probability and Measure</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For these notes, I will attempt to refresh my knowledge of measure-theoretic probability along with learning stochastic processes for the first time. I will be following <fr:link
type="external"
href="https://link.springer.com/book/10.1007/978-0-387-87859-1">Probability and Stochastics</fr:link> by Cinlar. Unfortunately, there are no solutions to exercises, but it is by far the best written book I have found.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1657</fr:anchor><fr:addr
type="machine">#381</fr:addr><fr:route>unstable-381.xml</fr:route><fr:title
text="Borel's Normal Number Theorem">Borel's Normal Number Theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1659</fr:anchor><fr:addr
type="user">kak-000S</fr:addr><fr:route>kak-000S.xml</fr:route><fr:title
text="Additivity of Intervals">Additivity of Intervals</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We have the following properties
  <fr:ol><fr:li>If <fr:tex
display="inline"><![CDATA[\bigcup _{k}I_{k}\subset  I]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[\sum _{k}|I_{k}|\leq |I|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I\subset \bigcup _{k}I_{k}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> need not be disjoint), then <fr:tex
display="inline"><![CDATA[|I|\leq \sum _{k}|I_{k}|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I=\bigcup _{k}I_{k}]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[|I|=\sum _{k}|I_{k}|]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1660</fr:anchor><fr:addr
type="machine">#380</fr:addr><fr:route>unstable-380.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  The important takeaway from <fr:link
type="local"
href="kak-000S.xml"
addr="kak-000S"
title="Additivity of Intervals">Additivity of Intervals</fr:link> is that extending (2) from finite to countable unions requires Heine-Borel theorem, illustrating that this extension is non-trivial. This will be important to remember as we continue to extend the Lebesgue measure to <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras. 
  </fr:mainmatter><fr:backmatter /></fr:tree>

  This section aims to motivate why we need to approach probability from a measure theoretic point of view.
  As an example, we will do the first exercise for this section.
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1662</fr:anchor><fr:addr
type="user">kak-000L</fr:addr><fr:route>kak-000L.xml</fr:route><fr:title
text="Dyadic Intervals">Dyadic Intervals</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Represent coin toss as dyadic expansion consider the set</fr:p><fr:tex
display="block"><![CDATA[\left [\omega :\ d_{i}(\omega )=u_{i},\,i=1,\ldots ,n \right ]=\Big (\sum _{i=1}^{n} \frac {u_{i}}{2^{i}},\ \sum _{i=1}^{n}\frac {u_{i}}{2^{i}} + \frac {1}{2^{n}}\Big ).]]></fr:tex><fr:p>More stuff</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1663</fr:anchor><fr:addr
type="user">kak-000N</fr:addr><fr:route>kak-000N.xml</fr:route><fr:title
text="Problem 1.1 Billingsley">Problem 1.1 Billingsley</fr:title><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:ol><fr:li>A discrete probability space cannot contain an infinite sequence of independent events <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> each with probability <fr:tex
display="inline"><![CDATA[1/2]]></fr:tex>. To see this, denote the event space as <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>. Note that 
    <fr:tex
display="block"><![CDATA[P(A_1 \cap  A_2) + P(A_1 \cap  A_2^c) + P(A_1^c \cap  A_2) + P(A_1^c \cap  A_2^c) = 1]]></fr:tex>
    Therefore, every <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex> must be in one of those four events and have probability at most <fr:tex
display="inline"><![CDATA[1/4]]></fr:tex>. Similarly, we can construct <fr:tex
display="inline"><![CDATA[n]]></fr:tex> disjoint sets in the same manner and bound <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\})]]></fr:tex> by <fr:tex
display="inline"><![CDATA[1/n]]></fr:tex>. Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex>, we have that <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is a discrete probability space, we must have that 
    <fr:tex
display="block"><![CDATA[\sum _{x \in  \mathcal {X}} \mathbb {P}(\{x\}) = 1]]></fr:tex>
    However, we have just shown that for each <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Thus, we have reached a contradiction.</fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree>
  
  I think my main takeaway from this is that infinite sequences break discrete probability because each discrete event will have probability zero. This is not actually a problem because in an infinite sequence the occurence of any such sequence "feasibly" has zero probability. However, we still want to reason about probabilistic things like the convergence of the average of the sequence. Since discrete probability is broken, we cannot even use it for these things. This is why we need to use measure theory to allow for zero probability sequences, but still provide information about these more "general" events. Who knows if this intuition is right though?
</fr:mainmatter><fr:backmatter /></fr:tree>
  
<fr:p><fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1664</fr:anchor><fr:addr
type="machine">#382</fr:addr><fr:route>unstable-382.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>After a bit more digging, the main culprit here is the countable subadditivity condition of measure.</fr:li>
      <fr:li>In a discrete probability space, the entire space is at most countable. Therefore, if each individual event has zero probability then the countable union i.e. the whole space will have zero probability.</fr:li>
      <fr:li>In measure theoretic probability, we are able to accumulate non-zero probability mass from an <fr:strong>uncountable</fr:strong> union of zero measure events.</fr:li>
      <fr:li>I guess the canonical example of this is that each point on a line has length 0, but the line itself (an uncountable union of points) has non-zero length.</fr:li>
      <fr:li>In the dyadic intervals example, each event of an arbitrary discrete probability space can be identified with a point on the line of probability zero.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1666</fr:anchor><fr:addr
type="machine">#385</fr:addr><fr:route>unstable-385.xml</fr:route><fr:title
text="Probability Measures">Probability Measures</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1668</fr:anchor><fr:addr
type="user">kak-000O</fr:addr><fr:route>kak-000O.xml</fr:route><fr:title
text="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class of subsets <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field if the following holds
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots  \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\bigcup _{i = 1}^{\infty } A_i \in  \mathscr {F}]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>It seems, in this section, we aim to answer why certain decisions were made regarding what can be analyzed. For example,</fr:p>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1669</fr:anchor><fr:addr
type="machine">#383</fr:addr><fr:route>unstable-383.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Why do we only allow consider countable unions in the definition of a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>?</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1671</fr:anchor><fr:addr
type="machine">#384</fr:addr><fr:route>unstable-384.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Because this is what god intended.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1673</fr:anchor><fr:addr
type="user">kak-000P</fr:addr><fr:route>kak-000P.xml</fr:route><fr:title
text="Probability Measure">Probability Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A set function is a real-valued function defined on some class of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. A set function <fr:tex
display="inline"><![CDATA[P]]></fr:tex> on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a probability measure if it satisfies these conditions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[0\leq  P(A)\leq 1]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A\in \mathscr {F}]]></fr:tex>;</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[P(\varnothing )=0]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(\Omega )=1]]></fr:tex>;</fr:li>
  <fr:li>if <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> is a disjoint sequence of <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> sets and if <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}\in \mathscr {F}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[P\Big (\bigcup _{k=1}^{\infty }A_{k}\Big )=\sum _{k=1}^{\infty }P(A_{k}).]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1674</fr:anchor><fr:addr
type="user">kak-000Q</fr:addr><fr:route>kak-000Q.xml</fr:route><fr:title
text="Probability Space">Probability Space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field in <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a probability measure on <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, the triple <fr:tex
display="inline"><![CDATA[(\Omega ,\mathscr {F},P)]]></fr:tex> is called a probability measure space, or simply a probability space. A support of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> for which <fr:tex
display="inline"><![CDATA[P(A)=1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1675</fr:anchor><fr:addr
type="user">kak-000R</fr:addr><fr:route>kak-000R.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>.

<fr:ol><fr:li><fr:em>Continuity from below</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathscr {A}_{n}\uparrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\uparrow  P(A)]]></fr:tex>.</fr:li>

<fr:li><fr:em>Continuity from above</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\downarrow  P(A)]]></fr:tex>.</fr:li>
<fr:li><fr:em>Countable subadditivity</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[A_{k}]]></fr:tex> need not be disjoint), then

<fr:tex
display="block"><![CDATA[P\left (\bigcup _{k=1}^{\infty }A_{k}\right )\leq \sum _{k=1}^{\infty }P(A_{k})]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1676</fr:anchor><fr:addr
type="machine">#388</fr:addr><fr:route>unstable-388.xml</fr:route><fr:title
text="Existence and Extension">Existence and Extension</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Here we will see how we can define a probability measure on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex> and get a unique extension to the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {F} = \sigma (\mathscr {F}_0)]]></fr:tex>. I guess the key here is uniqueness?</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1678</fr:anchor><fr:addr
type="user">kak-000T</fr:addr><fr:route>kak-000T.xml</fr:route><fr:title
text="Outer Measure">Outer Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="block"><![CDATA[P^{*}(A)=\mathrm {inf}\,\sum _{n}P(A_{n}),]]></fr:tex> where <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1679</fr:anchor><fr:addr
type="machine">#386</fr:addr><fr:route>unstable-386.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Taking <fr:tex
display="inline"><![CDATA[P_*(A) = 1 - P^*(A^c)]]></fr:tex> gives the inner measure. This is just analogously approximating from the inside.</fr:mainmatter><fr:backmatter /></fr:tree>

    Intuition is that the sets that are "measurable" should be sets that can be arbitrarily approximated from the inside and outside, or equivalently
<fr:tex
display="block"><![CDATA[P^*(A) + P^*(A^c) = 1]]></fr:tex>
    <fr:ol><fr:li>My intution for this is that if a set is not arbitrarily well approximated by countable other sets from our algebra then we cannot hope to get an accurate measure from our measure defined on only the algebra.</fr:li>
      <fr:li>The countableness is just from the definition of the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
    <fr:p>Then we can use <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> as our measure. To do this, we will need to show that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is countable additive as one might expect. The rest of the properties of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> are trivial.</fr:p>

    
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1681</fr:anchor><fr:addr
type="machine">#387</fr:addr><fr:route>unstable-387.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n]]></fr:tex>. By the definition of <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">Outer Measure</fr:link>, we can find some <fr:tex
display="inline"><![CDATA[B_{nk}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[A_n \subset  \bigcup _{k = 1}^{\infty } B_{nk}]]></fr:tex> where 
<fr:tex
display="block"><![CDATA[\sum _{k} P(B_{nk}) < P^*(A_n) + \epsilon  2^{-k}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[C_n = \bigcup _{k} B_{nk}]]></fr:tex>, so that <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n \subset  \bigcup _{n} C_n]]></fr:tex> and
<fr:tex
display="block"><![CDATA[P^*\left (\bigcup _n A_n\right ) < \sum _{n} P(C_n) = \sum _{n} \sum _{k} P(B_{nk}) < \sum _{n} P^*(A_n) + \epsilon ]]></fr:tex></fr:p>
      Since <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n = A]]></fr:tex>, we have achieved the desired result.
    </fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:p>It turns out that for some reason only enforcing <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and its complement to sum to <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is not restrictive enough? From this, we end up with the final condition</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1683</fr:anchor><fr:addr
type="user">kak-000U</fr:addr><fr:route>kak-000U.xml</fr:route><fr:title
text="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable if for every <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>, we have that 
<fr:tex
display="block"><![CDATA[P^*(A \cap  E) + P^*(A^c \cap  E) = P^*(E)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:p>You then only need to show two things:
        <fr:ol><fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets contains <fr:tex
display="inline"><![CDATA[\mathscr {F_0}]]></fr:tex>,</fr:li>
            <fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets is a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
        From these, we can conclude that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is at least defined on a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> containing <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>. Restricting <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>, then yields the desired extension.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1684</fr:anchor><fr:addr
type="machine">#393</fr:addr><fr:route>unstable-393.xml</fr:route><fr:title
text="Uniqueness">Uniqueness</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>We now want to show that the extension we developed in the previous section is actually unique. The first question we have is what do we mean by unique? To answer this, we need to remember what we have done so far.
    <fr:ol><fr:li>We have a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, defined on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>.</fr:li>
        <fr:li>We then extended <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex> via <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>, so that for every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[P(A) = P^*(A)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex></fr:li></fr:ol>
      From this, our only restriction is that <fr:tex
display="inline"><![CDATA[P^*(A) = P(A)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Therefore, uniqueness here means that if <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> and every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[A \in  \sigma (\mathscr {F}_0)]]></fr:tex>.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1686</fr:anchor><fr:addr
type="user">kak-0018</fr:addr><fr:route>kak-0018.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathcal {P}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system if it is closed under the formation of finite intersections:
<fr:tex
display="block"><![CDATA[A,B\in \mathcal {P} \implies  A\cap  B\in \mathcal {P}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1687</fr:anchor><fr:addr
type="user">kak-0019</fr:addr><fr:route>kak-0019.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system if it contains <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and is closed under the formation of complements and of finite and countable disjoint unions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega \in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A\in \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[A^{c}\in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ,\in \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\cap  A_{m}=\varnothing ]]></fr:tex> for <fr:tex
display="inline"><![CDATA[m\neq  n]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[\bigcup _{n}A_{n}\in \mathscr {L}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>I was a bit unsure that a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> is not a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, but the author provided an example that I will walk through to understand the distinction</fr:p>


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1688</fr:anchor><fr:addr
type="machine">#389</fr:addr><fr:route>unstable-389.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
Consider a four point space <fr:tex
display="inline"><![CDATA[\Omega  = \{x_1, x_2, x_3, x_4\}]]></fr:tex>. We can define a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> by taking <fr:tex
display="inline"><![CDATA[\mathscr {L} = \emptyset , \Omega ,]]></fr:tex> and the six two point sets. The union of any two disjoint two point sets will be <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. However, a non-disjoint union of two disjoint sets can result in a three point set, which is not in <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex>. These non-disjoint unions would be covered in a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


<fr:p>To remedy this disconnect, we have the following lemma:</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1690</fr:anchor><fr:addr
type="user">kak-001A</fr:addr><fr:route>kak-001A.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class that is both a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>In our example, we could take the intersection of say <fr:tex
display="inline"><![CDATA[\{x_1, x_2\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2, x_3\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex>. We could then take a disjoint union of <fr:tex
display="inline"><![CDATA[\{x_1, x_3\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_1, x_2, x_3\}]]></fr:tex>.</fr:p> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1691</fr:anchor><fr:addr
type="user">kak-001B</fr:addr><fr:route>kak-001B.xml</fr:route><fr:title
text="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system, then <fr:tex
display="inline"><![CDATA[\mathscr {P}\subset \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})\subset \mathscr {L}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Now we will see how this allows us to prove our desired result i.e. the uniqueness of our extension of a probability on an algebra to the <fr:link
type="external"
href="kak-0000">kak-0000</fr:link> via the outer measure.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1692</fr:anchor><fr:addr
type="user">kak-001C</fr:addr><fr:route>kak-001C.xml</fr:route><fr:title
text="Uniqueness of Extension">Uniqueness of Extension</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> are probability measures on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system. If <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> agree on <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex>, then they agree on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1693</fr:anchor><fr:addr
type="machine">#335</fr:addr><fr:route>unstable-335.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Take <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> to be the class of sets such that <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L} \implies  P_1(A) = P_2(A)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system, from <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, it is sufficient to show that <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. Since <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {P}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {L}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L}]]></fr:tex>, then
<fr:tex
display="block"><![CDATA[P_1(A^c) = 1 - P_1(A) = 1 - P_2(A) = P_2(A^c).]]></fr:tex>
Therefore, <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {L}]]></fr:tex>. Finally, if <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> disjoint then
<fr:tex
display="block"><![CDATA[   P_1\left (\bigcup _{n = 1} A_n\right ) = \sum _{n = 1} P_1(A_n) = \sum _{n = 1}P_2 (A_n) = P_2\left (\bigcup _{n = 1}A_n\right ) ]]></fr:tex>
Thus, <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. From <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P}) \subset  \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_2]]></fr:tex> agree on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>An (important?) note is that this works due to our definition of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link>. Namely, countable additivity is really a condition on countable disjoint unions, meaning that the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> induced by a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> does not make full use of the generality allowed under arbitrary countable unions because it must satisfy countable additivity.</fr:p>

<fr:p>For completeness and future use, we introduce here the notion of monotone classes and Halmo's useful <fr:link
type="local"
href="kak-001E.xml"
addr="kak-001E"
title="Halmo's Monotone Class Theorem">theorem</fr:link>.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1694</fr:anchor><fr:addr
type="user">kak-001D</fr:addr><fr:route>kak-001D.xml</fr:route><fr:title
text="Monotone Class">Monotone Class</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {M}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is monotone if it is closed under the formation of monotone unions and intersections:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\uparrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>;</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ \ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1695</fr:anchor><fr:addr
type="user">kak-001E</fr:addr><fr:route>kak-001E.xml</fr:route><fr:title
text="Halmo's Monotone Class Theorem">Halmo's Monotone Class Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> is a field and <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> is a monotone class, then <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}\subset \mathscr {A}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_{0})\subset \mathscr {A}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Also for completeness, we introduce completeness lol.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1696</fr:anchor><fr:addr
type="user">kak-001F</fr:addr><fr:route>kak-001F.xml</fr:route><fr:title
text="Completeness of a measure">Completeness of a measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A probability measure <fr:tex
display="inline"><![CDATA[(\Omega , \mathcal {F}, P)]]></fr:tex> is <fr:em>complete</fr:em> if for <fr:tex
display="inline"><![CDATA[A \subset  B]]></fr:tex> if <fr:tex
display="inline"><![CDATA[P(B) = 0]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P(A) = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>You might be wondering when this is not the case because we have subadditivity. However, it is not the case that <fr:tex
display="inline"><![CDATA[P(A) > 0]]></fr:tex> but instead that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is not measurable. As an example,</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1697</fr:anchor><fr:addr
type="user">kak-001G</fr:addr><fr:route>kak-001G.xml</fr:route><fr:title
text="Vitali Sets">Vitali Sets</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If we consider <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>, then we can partition <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> into equivalent classes as <fr:tex
display="inline"><![CDATA[x \sim  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x - y = r]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[r \in  \mathbb {Q} \cap  [0, 1]]]></fr:tex>. Denote each of these as <fr:tex
display="inline"><![CDATA[V_{r}]]></fr:tex>. By the <fr:link
type="local"
href="kak-001H.xml"
addr="kak-001H"
title="Axiom of Choice">Axiom of Choice</fr:link>, we can choose one representative from each <fr:tex
display="inline"><![CDATA[V_r]]></fr:tex>. We call the set of these representatives <fr:tex
display="inline"><![CDATA[V]]></fr:tex>. Therefore, we can write <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> as a countable union via <fr:tex
display="inline"><![CDATA[[0,1] = \bigcup _{r \in  \mathbb {Q}} V + r]]></fr:tex>. For the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>, each <fr:tex
display="inline"><![CDATA[\lambda (V + r) = \lambda (V)]]></fr:tex>. Since each <fr:tex
display="inline"><![CDATA[V + r]]></fr:tex> is disjoint, we have 
<fr:tex
display="block"><![CDATA[\lambda \left (\bigcup _{r \in  \mathbb {Q}} V + r\right ) = \sum _{r \in  \mathbb {Q}} \lambda (V)]]></fr:tex>
If <fr:tex
display="inline"><![CDATA[\lambda (V) = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\lambda ([0,1]) \leq  \lambda (V) = 0]]></fr:tex> which is a contradiction. Otherwise <fr:tex
display="inline"><![CDATA[\lambda  ([0,1]) = \sum _{r \in  \mathbb {Q}} k = \infty ]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[k \in  \mathbb {R}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[V]]></fr:tex> is not Lebesgue measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1698</fr:anchor><fr:addr
type="machine">#390</fr:addr><fr:route>unstable-390.xml</fr:route><fr:title
text=" [billingsley1986, 3.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.2"
refid="billingsley1986"><fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">[billingsley1986, 3.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> and for every subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> define <fr:tex
display="inline"><![CDATA[P^{\star }(A)]]></fr:tex> by <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">(3.1)</fr:link>. Denote also by <fr:tex
display="inline"><![CDATA[P]]></fr:tex> the extension of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathscr {F}=\sigma (\mathscr {F}_{0})]]></fr:tex>.
  <fr:ol><fr:li>Show that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> if and only if <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>.</fr:li></fr:ol>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1700</fr:anchor><fr:addr
type="machine">#391</fr:addr><fr:route>unstable-391.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>First suppose that <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>. We must show that 
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) = P^*(E)]]></fr:tex>
  From part (1) and our hypothesis, <fr:tex
display="inline"><![CDATA[\exists  \overline {A}, \underline {A} \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\underline {A} \subset  A \subset  \overline {A}]]></fr:tex> and <fr:tex
display="block"><![CDATA[P(\overline {A}) = P^*(A) = P_*(A) = P(\underline {A})]]></fr:tex>. Additionally, <fr:tex
display="inline"><![CDATA[\exists  B \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[E \subset  B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*(E) = P(B)]]></fr:tex>. Then we have that
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) \leq  P^*(B \cap  \overline {A}) = P(B \cap  \overline {A})]]></fr:tex>
  and
<fr:tex
display="block"><![CDATA[P^*(B \cap  A) \leq  P^*(B \cap  \underline {A}^c) = P(B \cap  \underline {A}^c)]]></fr:tex>
  Thus,
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) \leq  P(B \cap  \underline {A}^c) + P(B \cap  \overline {A}) = P^*(E)]]></fr:tex>
  as desired.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1702</fr:anchor><fr:addr
type="machine">#392</fr:addr><fr:route>unstable-392.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>I really struggled for a minute on even understanding this problem. The import thing to understand for this problem is what space everything is defined on.
<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> is defined on the initial field <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>, which is the closure over finite unions and complements of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on the powerset <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex>. <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily a measure on all of these subsets though.
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[E]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> hence the need for <fr:tex
display="inline"><![CDATA[B]]></fr:tex>.</fr:li></fr:ul></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> (abuse of notation) is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> restricted to the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li></fr:ol>
  Common question is why we cannot just apply finite additivity and have everything <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link>? The answer is that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is not countably subadditive on <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex> but only the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> sets.
</fr:mainmatter><fr:backmatter /></fr:tree>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1704</fr:anchor><fr:addr
type="machine">#399</fr:addr><fr:route>unstable-399.xml</fr:route><fr:title
text="Denumerable Probabilities">Denumerable Probabilities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
The results of this section concern infinite sequences of events in a probability space. They will be illustrated by examples in the unit interval. By this will always be meant the triple (<fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P]]></fr:tex>) for which <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is (0,1), <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field <fr:tex
display="inline"><![CDATA[\mathscr {B}]]></fr:tex> of Borel sets there, and <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is for <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda (A)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. 
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1706</fr:anchor><fr:addr
type="user">kak-001J</fr:addr><fr:route>kak-001J.xml</fr:route><fr:title
text="Conditional Probability">Conditional Probability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A | B) = \frac {P(A \cap  B)}{P(B)}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1707</fr:anchor><fr:addr
type="user">kak-001I</fr:addr><fr:route>kak-001I.xml</fr:route><fr:title
text="Chain Rule of Probability">Chain Rule of Probability</fr:title><fr:taxon>Proposition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A \cap  B \cap  C) = P(A)P(B | A)P(C | B \cap  A)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1708</fr:anchor><fr:addr
type="user">kak-001M</fr:addr><fr:route>kak-001M.xml</fr:route><fr:title
text="Limsup of sets">Limsup of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \sup _{n} A_n = \bigcap _{n = 1}^{\infty } \bigcup _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \sup _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> infinitely often.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1709</fr:anchor><fr:addr
type="user">kak-001N</fr:addr><fr:route>kak-001N.xml</fr:route><fr:title
text="Liminf of sets">Liminf of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \inf _{n} A_n = \bigcup _{n = 1}^{\infty } \bigcap _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in all but finitely many <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1710</fr:anchor><fr:addr
type="user">kak-001K</fr:addr><fr:route>kak-001K.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each sequence <fr:tex
display="inline"><![CDATA[\{A_{n}\}]]></fr:tex>,

<fr:tex
display="block"><![CDATA[P\left (\lim \inf _{n}A_{n}\right )\leq \lim _{n}\inf _{n}P\left (\,A_{n}\right ) \leq \lim _{n}\sup _{n}P\left (\,A_{n}\right )\leq  P\left (\lim _{n}\sup _{n}A_{n}\right ).]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1711</fr:anchor><fr:addr
type="machine">#334</fr:addr><fr:route>unstable-334.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We define <fr:tex
display="inline"><![CDATA[B_n \coloneqq  \bigcup _{k = n}^{\infty } A_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> as <fr:tex
display="inline"><![CDATA[C_n = \bigcap _{k = n}^{\infty } A_k]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[\{B_n\}]]></fr:tex> is a monotonically decreasing sequence to <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> monotonically increases to <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_n]]></fr:tex>. Therefore, we can apply continuity from below / above such that
<fr:tex
display="block"><![CDATA[     \begin {align*}     \inf _n P(A_n) \geq  P(C_n) \iff  \lim _n \inf _n P(A_n) &\geq  \lim _n P(C_n) \\      &= P(\lim _n C_n) \\      &= P(\lim \inf _n A_n)     \end {align*} ]]></fr:tex>
      Similarly,
<fr:tex
display="block"><![CDATA[       \begin {align*}       \sup _n P(A_n) \leq  P(B_n) \iff  \lim _n \sup _n P(A_n) &\leq  \lim _n P(B_n) \\        &= P(\lim _n B_n) \\        &= P(\lim \sup _n A_n)       \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1712</fr:anchor><fr:addr
type="user">kak-001O</fr:addr><fr:route>kak-001O.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Independence evolves in the following manner:
  <fr:ol><fr:li>Events <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> are independent if <fr:tex
display="inline"><![CDATA[P(A \cap  B) = P(A)P(B)]]></fr:tex>.</fr:li>
    <fr:li>A finite collection of events are independent if
    <fr:tex
display="block"><![CDATA[P(A_{k_1} \cap  \cdots  \cap  A_{k_j}) = P(A_{k_1}) \cdots  P(A_{k_j})]]></fr:tex></fr:li>
    <fr:li>A infinite collection of sets is defined to be independent if every finite subcollection is independent.</fr:li>
    <fr:li>Classes <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent if for any events <fr:tex
display="inline"><![CDATA[A_1 \in  \mathscr {A}_1, \ldots , A_n \in  \mathscr {A}_n]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_1, \ldots , A_n]]></fr:tex> are independent.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1713</fr:anchor><fr:addr
type="user">kak-001P</fr:addr><fr:route>kak-001P.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent and each <fr:tex
display="inline"><![CDATA[\mathscr {A}_i]]></fr:tex> is a <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> then <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1), \ldots , \sigma (\mathscr {A}_n)]]></fr:tex> are independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1714</fr:anchor><fr:addr
type="machine">#333</fr:addr><fr:route>unstable-333.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
We have sequence of independent classes and want to show that their respective <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras are also independent. The idea is to take the class of events <fr:tex
display="inline"><![CDATA[B_1]]></fr:tex> that are independent with <fr:tex
display="inline"><![CDATA[\mathscr {A}_2, \ldots , \mathscr {A}_n]]></fr:tex>, and show that <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1)]]></fr:tex> is a subset of this class. To do this, we use <fr:link
type="local"
href="kak-001B.xml"
addr="kak-001B"
title="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:link> by noticing that this class is a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> that contains the <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {A}_1]]></fr:tex>.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Meaning in english:</fr:strong> In the book, they give the example of even and odd numbered coin tosses. We want to know when a new event only depends on even or odd coin tosses. Concretely, we know that even and odd coin tosses are independent, and we want to know if, for example, the outcome of every fourth coin toss is independent of odd tosses. We can do this rigorously by showing that this event is in the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra of even coin tosses. Then by <fr:link
type="local"
href="kak-001P.xml"
addr="kak-001P">Theorem 5.7</fr:link>, we know that this event is also independent of odd coin tosses.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1715</fr:anchor><fr:addr
type="user">kak-001R</fr:addr><fr:route>kak-001R.xml</fr:route><fr:title
text="Array Method">Array Method</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that the array
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} A_{11} & A_{12} & \cdots  \\ A_{21} & A_{22} & \cdots  \\ \vdots  & \vdots  &  \end {array} ]]></fr:tex>
of events is independent. If <fr:tex
display="inline"><![CDATA[\mathscr {F}_1]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra generated
by the first row then <fr:tex
display="inline"><![CDATA[\mathscr {F}_1, \mathscr {F}_2, \ldots ]]></fr:tex> are
independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1716</fr:anchor><fr:addr
type="machine">#331</fr:addr><fr:route>unstable-331.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>Can write events of flip <fr:tex
display="inline"><![CDATA[i]]></fr:tex> as <fr:tex
display="inline"><![CDATA[H_i]]></fr:tex> such that the following array
satisfies the above
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} H_{2} & H_{4} & \cdots  \\ H_{1} & H_3 & \cdots  \\ \end {array} ]]></fr:tex>
Then row 1 and row 2 are independent from above. Therefore, we have shown that
even and odd numbered flips' <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>'s are independent.
</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1717</fr:anchor><fr:addr
type="machine">#395</fr:addr><fr:route>unstable-395.xml</fr:route><fr:title
text="Subfields">Subfields</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1719</fr:anchor><fr:addr
type="machine">#394</fr:addr><fr:route>unstable-394.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Intuition of subfields are spaces with partial information. My best
memory of this coming up in probability was conditional expectation.
Esssentially, we need to consider the subfield of events conditioned on some
event that already occured.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1721</fr:anchor><fr:addr
type="user">kak-001S</fr:addr><fr:route>kak-001S.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say that points <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\omega ']]></fr:tex> are <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> equivalent if for
every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {A}]]></fr:tex>,
<fr:tex
display="block"><![CDATA[I_A(\omega ) = I_A(\omega ')]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>From this definition, we can conclude an observer with the information of
<fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A})]]></fr:tex> has only the information of the equivalence class but
cannot identify a specific point from this class.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1722</fr:anchor><fr:addr
type="machine">#396</fr:addr><fr:route>unstable-396.xml</fr:route><fr:title
text="The Borel-Cantelli Lemmas">The Borel-Cantelli Lemmas</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1724</fr:anchor><fr:addr
type="user">kak-001Q</fr:addr><fr:route>kak-001Q.xml</fr:route><fr:title
text="Borel-Cantelli One">Borel-Cantelli One</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> converges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 0]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1725</fr:anchor><fr:addr
type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n \subset  \bigcup _{k = n}^{\infty } A_k]]></fr:tex>.
    Therefore,
      <fr:tex
display="block"><![CDATA[P(\lim \sup _n A_n) \leq  P\left (\bigcup _{k = n}^{\infty } A_k\right ) \leq        \sum _{k = n}^{\infty } P(A_k)]]></fr:tex>
      Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1726</fr:anchor><fr:addr
type="user">kak-001T</fr:addr><fr:route>kak-001T.xml</fr:route><fr:title
text="Borel-Cantelli Two">Borel-Cantelli Two</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex> is an independent sequence of events and <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> diverges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 1]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1727</fr:anchor><fr:addr
type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Consider the complement. By independence, we have
<fr:tex
display="block"><![CDATA[P(\bigcap _{k = n}^{n + m} A_k^c) = \prod _{k = n}^{n + m}(1 - P(A_k)) \leq      \exp (-\sum _{k = n}^{n + m} P(A_k)),]]></fr:tex>
    where the last inequality comes from <fr:tex
display="inline"><![CDATA[1 - x \leq  e^{-x}]]></fr:tex>. Since the series diverges, taking <fr:tex
display="inline"><![CDATA[m \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:addr
type="machine">#398</fr:addr><fr:route>unstable-398.xml</fr:route><fr:title
text="Zero-one Law">Zero-one Law</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:addr
type="user">kak-001U</fr:addr><fr:route>kak-001U.xml</fr:route><fr:title
text="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of events in a probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> consider the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-fields <fr:tex
display="inline"><![CDATA[\sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
then their intersection
<fr:tex
display="block"><![CDATA[\mathscr {T} = \bigcap _{n = 1}^{\infty } \sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
is the <fr:em>tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:em> associated with the sequence <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1731</fr:anchor><fr:addr
type="machine">#397</fr:addr><fr:route>unstable-397.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>The <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim \inf _n A_n]]></fr:tex> are both tail events.</fr:mainmatter><fr:backmatter /></fr:tree>
 

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1733</fr:anchor><fr:addr
type="user">kak-001V</fr:addr><fr:route>kak-001V.xml</fr:route><fr:title
text="Kolmogorov's Zero-one Law">Kolmogorov's Zero-one Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> is an independent sequence of events, then for each
event <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in the <fr:link
type="local"
href="kak-001U.xml"
addr="kak-001U"
title="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is either <fr:tex
display="inline"><![CDATA[0]]></fr:tex> or <fr:tex
display="inline"><![CDATA[1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1734</fr:anchor><fr:addr
type="machine">#410</fr:addr><fr:route>unstable-410.xml</fr:route><fr:title
text="Random Variables">Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:addr
type="user">kak-001W</fr:addr><fr:route>kak-001W.xml</fr:route><fr:title
text="Simple Random Variable">Simple Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> be an arbitrary probability space, and let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a real-valued function on <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a simple random variable if it has finite range and if 
<fr:tex
display="block"><![CDATA[\left [\omega  \mid  X(\omega ) = x \right ] \in  \mathscr {F}]]></fr:tex>
for each <fr:tex
display="inline"><![CDATA[x]]></fr:tex> in its finite range.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1737</fr:anchor><fr:addr
type="machine">#400</fr:addr><fr:route>unstable-400.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider the function 
    <fr:tex
display="block"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex>
    If <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> are finite partition of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> into <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-sets, then inverse image is at most countable union of the A_i's, which is an <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set. Therefore, this function is measurable.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1739</fr:anchor><fr:addr
type="user">kak-0022</fr:addr><fr:route>kak-0022.xml</fr:route><fr:title
text="Finite Sequence Measurability">Finite Sequence Measurability</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, \ldots , X_n]]></fr:tex> be <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s
<fr:ol><fr:li>The <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> consists of the sets
<fr:tex
display="block"><![CDATA[\left [(X_1, \ldots , X_n) \in  H\right ] = \left [\omega  \mid  (X_1(\omega ), \ldots , X_n(\omega )) \in  H\right ]]]></fr:tex>
    for <fr:tex
display="inline"><![CDATA[H \subset  \mathbb {R}^n]]></fr:tex>.</fr:li>
    <fr:li>A simple random variable <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is measurable <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> if and only if 
<fr:tex
display="block"><![CDATA[Y = f(X_1, \ldots , X_n)]]></fr:tex>
    for some <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1740</fr:anchor><fr:addr
type="user">kak-001X</fr:addr><fr:route>kak-001X.xml</fr:route><fr:title
text="-Field of RV"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field of RV</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field generated by a <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is the smallest <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field such that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">measurable</fr:link>. For a sequence of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s, the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> generated by them is the smallest <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, such that each of the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s is measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1741</fr:anchor><fr:addr
type="machine">#404</fr:addr><fr:route>unstable-404.xml</fr:route><fr:title
text="Convergence of Random Variables">Convergence of Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
In probability, rather than standard convergence, we actually can consider convergence with high probability or almost surely (should come up later). Formally, we care about measuring the probability of the event <fr:tex
display="inline"><![CDATA[\{\omega  \mid  \lim _n X_n(\omega ) \to  X(\omega )\}]]></fr:tex>. The first question we must ask is whether this set is measurable. They do not really cover this in the textbook, but it is an important trick that comes up a lot.

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1743</fr:anchor><fr:addr
type="machine">#401</fr:addr><fr:route>unstable-401.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
We consider the complement. Note that the sequence of random variables not converging can be written as <fr:tex
display="inline"><![CDATA[\forall  \epsilon , \exists  n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[|X_n(\omega ) - X(\omega )| \geq  \epsilon ]]></fr:tex>. For a fixed <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>, this is the <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of the sequence <fr:tex
display="inline"><![CDATA[A_n \coloneqq  [|X_n - X| \geq  \epsilon ]]]></fr:tex>. We know that <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of measurable sequence is measurable because it is a countable intersection of countable unions. Therefore, the last thing we need is to show for all <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>. This can be done just using rationals because <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is <fr:link
type="local"
href="kak-001Y.xml"
addr="kak-001Y"
title="Dense Subset">dense</fr:link> in <fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex>. Then we have a countable union of countable sets as desired.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1745</fr:anchor><fr:addr
type="user">kak-001Z</fr:addr><fr:route>kak-001Z.xml</fr:route><fr:title
text="Almost Sure Convergence">Almost Sure Convergence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>almost surely</fr:em> if 
<fr:tex
display="block"><![CDATA[P(X_n \to  X) = 1]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1746</fr:anchor><fr:addr
type="user">kak-0020</fr:addr><fr:route>kak-0020.xml</fr:route><fr:title
text="Convergence in Probability">Convergence in Probability</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>in probability</fr:em> if for every <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>
<fr:tex
display="block"><![CDATA[\lim _{n \to  \infty } P(|X_n - X| > \epsilon ) = 0]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1747</fr:anchor><fr:addr
type="machine">#402</fr:addr><fr:route>unstable-402.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        By <fr:link
type="local"
href="kak-001K.xml"
addr="kak-001K">Theorem 5.5</fr:link>, almost sure convergence <fr:tex
display="inline"><![CDATA[\implies ]]></fr:tex> convergence in probability. Converse is NOT true.
      </fr:mainmatter><fr:backmatter /></fr:tree>

      
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1749</fr:anchor><fr:addr
type="machine">#403</fr:addr><fr:route>unstable-403.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Can make array of rows, where the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>th row consists of <fr:tex
display="inline"><![CDATA[n]]></fr:tex> intervals that evenly divide <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P(A_n) \to  0]]></fr:tex> but <fr:tex
display="inline"><![CDATA[[A_n \text { i.o}] = [0,1]]]></fr:tex> </fr:mainmatter><fr:backmatter /></fr:tree>
 

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1751</fr:anchor><fr:addr
type="machine">#405</fr:addr><fr:route>unstable-405.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1753</fr:anchor><fr:addr
type="user">kak-0021</fr:addr><fr:route>kak-0021.xml</fr:route><fr:title
text="Independence of Random Variable">Independence of Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A sequence of random variables <fr:tex
display="inline"><![CDATA[X_1, X_2, \ldots ]]></fr:tex> is <fr:em>independent</fr:em> if the classes <fr:tex
display="inline"><![CDATA[\sigma (X_1), \sigma (X_2), \ldots ]]></fr:tex> are <fr:link
type="local"
href="kak-001O.xml"
addr="kak-001O"
title="Independence">independent</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1754</fr:anchor><fr:addr
type="machine">#407</fr:addr><fr:route>unstable-407.xml</fr:route><fr:title
text="Existence of Independent Sequences">Existence of Independent Sequences</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1756</fr:anchor><fr:addr
type="user">kak-0023</fr:addr><fr:route>kak-0023.xml</fr:route><fr:title
text="Distribution">Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>distribution</fr:em> of a simple random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the probability measure <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> defined for all subsets <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of the line by 
<fr:tex
display="block"><![CDATA[\mu (A) = P[X \in  A]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1757</fr:anchor><fr:addr
type="user">kak-0024</fr:addr><fr:route>kak-0024.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{\mu _n\}]]></fr:tex> be a sequence of probability measures on the class of all subsets of the line, each having finite support. There exists some probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> an independent sequence <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s such that <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> has distribution <fr:tex
display="inline"><![CDATA[\mu _n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Guess for english translation</fr:strong>: I think what this is saying is that rather than try to define a probability space for a random variable, we can instead just pick probability measures and know that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> come for free? i.e. (from the book) we can just define a trivial space <fr:tex
display="inline"><![CDATA[\Omega  = \{1, 0\}]]></fr:tex> and probability measure <fr:tex
display="inline"><![CDATA[P(1) = p]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(0) = 1 - p]]></fr:tex> and know that we can get a Bernoulli random variable? In this case <fr:tex
display="inline"><![CDATA[X(1) = 1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X(0) = 0]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P(X = 1) = p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P(X = 0) = 1 - p]]></fr:tex>?</fr:p>

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1758</fr:anchor><fr:addr
type="machine">#406</fr:addr><fr:route>unstable-406.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>In the text, they say that the underlying probability space does not really matter. Basically, all calculations are determined by the distribution in range space. So I guess that is also what this theorem is getting at? </fr:mainmatter><fr:backmatter /></fr:tree>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  


  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1760</fr:anchor><fr:addr
type="machine">#408</fr:addr><fr:route>unstable-408.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1762</fr:anchor><fr:addr
type="user">kak-0029</fr:addr><fr:route>kak-0029.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> of the form <fr:tex
display="inline"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex> is assigned expected value as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \mathbb {E}\left [\sum _i x_i I_{A_i} \right ] = \sum _i x_i P(A_i)]]></fr:tex>
More generally, if <fr:tex
display="inline"><![CDATA[f(X) = \sum _i f(x_i) I_{A_i}]]></fr:tex> then
<fr:tex
display="block"><![CDATA[\mathbb {E}\left [f(X)\right ] = \sum _i f(x_i) P(A_i) = \sum _x f(x) P[X = x]]]></fr:tex>
A useful identity is as follows:
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \int _0^{\infty } P[X \geq  x] \mathrm {d}x]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1763</fr:anchor><fr:addr
type="user">kak-002A</fr:addr><fr:route>kak-002A.xml</fr:route><fr:title
text="Kth Moment"><fr:tex
display="inline"><![CDATA[k]]></fr:tex>th Moment</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We define the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th moment of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X^k] = \sum _y y P[X^k = y]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1764</fr:anchor><fr:addr
type="user">kak-002B</fr:addr><fr:route>kak-002B.xml</fr:route><fr:title
text="Uniformly Bounded">Uniformly Bounded</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\exists  K]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X_n(\omega ) \leq  K]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> then the <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> are <fr:em>uniformly bounded</fr:em>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1765</fr:anchor><fr:addr
type="user">kak-002C</fr:addr><fr:route>kak-002C.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> is uniformly bounded, and if <fr:tex
display="inline"><![CDATA[X = \lim _n X_n]]></fr:tex> with probability <fr:tex
display="inline"><![CDATA[1]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbb {E}[X] = \lim _n \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1766</fr:anchor><fr:addr
type="machine">#409</fr:addr><fr:route>unstable-409.xml</fr:route><fr:title
text="Inequalities">Inequalities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1768</fr:anchor><fr:addr
type="user">kak-002E</fr:addr><fr:route>kak-002E.xml</fr:route><fr:title
text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[X \geq  \alpha ] \leq  \frac {1}{\alpha } \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1769</fr:anchor><fr:addr
type="user">kak-002F</fr:addr><fr:route>kak-002F.xml</fr:route><fr:title
text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[|X - m| \geq  \alpha ] \leq  \frac {1}{\alpha ^2} \mathrm {Var}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1770</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1771</fr:anchor><fr:addr
type="user">kak-002H</fr:addr><fr:route>kak-002H.xml</fr:route><fr:title
text="Holder's Inequality">Holder's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:tex
display="block"><![CDATA[\frac {1}{p} + \frac {1}{q} = 1, \quad  p > 1,\ q > 1]]></fr:tex>
Then <fr:em>Holder's inequality</fr:em> is
<fr:tex
display="block"><![CDATA[\mathbb {E}[XY] \leq  \left (\mathbb {E}[|X|^p]\right )^{1/p} \cdot  \left (\mathbb {E}[|Y|^q]\right )^{1/q}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  
 
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1772</fr:anchor><fr:addr
type="machine">#411</fr:addr><fr:route>unstable-411.xml</fr:route><fr:title
text="The Law of Large Numbers">The Law of Large Numbers</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3593</fr:anchor><fr:addr
type="user">kak-0030</fr:addr><fr:route>kak-0030.xml</fr:route><fr:title
text="Reinforcement Learning">Reinforcement Learning</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1776</fr:anchor><fr:addr
type="user">kak-0012</fr:addr><fr:route>kak-0012.xml</fr:route><fr:title
text="Notes on Reinforcement Learning: An Introduction">Notes on <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This won't really be notes, my lab has begun taking a few undergrads who are not familiar with RL. I will be onboarding them by going through <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link>. Specifically, I will be following the <fr:link
type="local"
href="richardsutton.xml"
addr="richardsutton"
title="Richard Sutton">Richard Sutton</fr:link> flavor of RL through his <fr:link
type="external"
href="https://drive.google.com/drive/folders/0B3w765rOKuKANmxNbXdwaE1YU1k?resourcekey=0-JZz-noRuJgogNsg1ljgV8w">CMPUT 609</fr:link> course. You know what the say: the best way to learn is to teach! Here, I will try to solve all the problems as we go and prepare some questions for the undergrads for when we meet. Additionally, I will document my foray into more advanced exploration of topics introduced in the textbook.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1778</fr:anchor><fr:addr
type="machine">#344</fr:addr><fr:route>unstable-344.xml</fr:route><fr:title
text="Multi-armed Bandits">Multi-armed Bandits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1780</fr:anchor><fr:addr
type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title
text=" [sutton2022, 2.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the case of two actions, (assuming that <fr:tex
display="inline"><![CDATA[Q_*(a_1) > Q_*(a_2)]]></fr:tex>) the probability of the greedy action being selected is <fr:tex
display="inline"><![CDATA[1 - \epsilon ]]></fr:tex> or 0.5.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1782</fr:anchor><fr:addr
type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title
text=" [sutton2022, 2.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the long run <fr:tex
display="inline"><![CDATA[\epsilon  = 0.01]]></fr:tex>, would achieve the highest reward. The expected reward can be written as
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* = \max _{a} q^*(a) + \frac {\epsilon }{n}\sum _{i \neq  a}^{n} q^*(i)     \end {align*}   ]]></fr:tex>
  The exception is that if <fr:tex
display="inline"><![CDATA[\epsilon  = 0]]></fr:tex>, then there are no guarantees. For example, if your initialization is zeros. Then you could have an empirical average of a suboptimal arm that is always positive and you would never deviate. Thus, to ensure you converge to the true optimal arm you need <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1784</fr:anchor><fr:addr
type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title
text=" [sutton2022, 2.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  TODO

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1786</fr:anchor><fr:addr
type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title
text=" [sutton2022, 2.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Following the steps in 2.6,
  <fr:tex
display="block"><![CDATA[       \begin {align*}         Q_{n + 1} &= Q_n + \alpha _n [R_n - Q_n] \\         &= Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}] + \alpha _n \Big [R_n - (Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}])\Big ] \\         &\vdots  \\         & = \left (\prod _{i = 1}^{n} (1 - \alpha _{i})\right ) Q_1 + \sum _{i = 1}^{n} \alpha _n \left (\prod _{i = 1}^{n} (1 - \alpha _{n - i})\right )R_i       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1788</fr:anchor><fr:addr
type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title
text=" [sutton2022, 2.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since all of the arms in the testbed have distributions with support less than 5, in the beginning the unpulled arm's optimistic estimates will be higher than the empirical estimates of the previously pulled arms. Therefore, in the early stages all of the arms will be pulled in a round robin fashion, and assuming deterministic rewards the optimal arm will keep being pulled until it falls below the other optimistic values.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1790</fr:anchor><fr:addr
type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title
text=" [sutton2022, 2.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since there are 10 arms (presumably with the same initialization), the UCB bonus will enforce that the first 10 pulls are round robin (uniform) pulling of each of the 10 arms. Then on the 11th step each will have the same UCB bonus term but the one with the highest empirical reward will be pulled, leading to a spike. It then drops in subsequent steps because the UCB bonus of that arm will decrease and other (possibly less optimal) arms are pulled in subsequent steps.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1792</fr:anchor><fr:addr
type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title
text=" [sutton2022, 2.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We can just expand the denominator as
<fr:tex
display="block"><![CDATA[     \begin {align*}       \Pr \{A_t = a\} &= \frac {e^{H_t(a)}}{e^{H_t(a)} + e^{H_t(b)}} \\       &= \frac {1}{1 + e^{\frac {H_t(b)}{H_t(a)}}} \\       &= \frac {1}{1 + e^{-\frac {H_t(a)}{H_t(b)}}} \\     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1794</fr:anchor><fr:addr
type="machine">#343</fr:addr><fr:route>unstable-343.xml</fr:route><fr:title
text=" [sutton2022, 2.10]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.10"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.10]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In case 1, the best you can hope to achieve is <fr:tex
display="inline"><![CDATA[\max _{a} \mathbb {E} [R(a)]]]></fr:tex>. In this case, we have
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R(1)] &= 0.5 \cdot  10 + 0.5 \cdot  90 = 50, \\       \mathbb {E}[R(2)] &= 0.5 \cdot  20 + 0.5 \cdot  80 = 50     \end {align*}   ]]></fr:tex>
  Therefore, the best we can hope to achieve is <fr:tex
display="inline"><![CDATA[50]]></fr:tex>. If we are given what case we are in, then we can achieve
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* &= 0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 1] +       0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 2] \\       &= 0.5 \cdot  20 + 0.5 \cdot  90 \\       &= 55     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1796</fr:anchor><fr:addr
type="machine">#357</fr:addr><fr:route>unstable-357.xml</fr:route><fr:title
text="Markov Decision Processes">Markov Decision Processes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1798</fr:anchor><fr:addr
type="machine">#345</fr:addr><fr:route>unstable-345.xml</fr:route><fr:title
text=" [sutton2022, 3.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  I think you draw the line at where you can already execute the necessary behavior to get from one state to another. This is eerily familiar to the line of work known as hierarchical reinforcement learning, where you gradually learn higher level of abstraction by executing subpolicies.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1800</fr:anchor><fr:addr
type="machine">#346</fr:addr><fr:route>unstable-346.xml</fr:route><fr:title
text=" [sutton2022, 3.5]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.5"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.5]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We need to add the notion of a terminal state. This can be done by just adding some <fr:tex
display="inline"><![CDATA[t]]></fr:tex> to the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. Then
  <fr:tex
display="block"><![CDATA[       \begin {cases}         p(t, 0 \mid  s, a) = 1, &\text { if } s = t\\         \sum _{s^{\prime }\in \mathcal {S}}\sum _{r\in \mathcal {R}}p(s^{\prime },r|s,a)=1,\mathrm {~for~all~}s\in \mathcal {S},a\in \mathcal {A}(s), &\text { if } s \neq  t       \end {cases} ]]></fr:tex>
I think the idea is just that when you hit a terminal state you no longer can reach other states.
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1802</fr:anchor><fr:addr
type="machine">#347</fr:addr><fr:route>unstable-347.xml</fr:route><fr:title
text=" [sutton2022, 3.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> denote the length of the episode. Then the return <fr:tex
display="inline"><![CDATA[G_t]]></fr:tex> would be 
<fr:tex
display="block"><![CDATA[   \begin {align*} G_t &= R_{t+1} + \gamma  R_{t + 2} + \cdots  + \gamma ^{T - {t + 1}} R_T = - \gamma ^{T - {t + 1}}   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1804</fr:anchor><fr:addr
type="machine">#348</fr:addr><fr:route>unstable-348.xml</fr:route><fr:title
text=" [sutton2022, 3.7]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.7"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.7]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  You have not effectively communicated the task. The agent has no incentive to solve the maze as fast as possible. This means that no matter the duration it took to solve the task the agent would receive the same reward. To fix this, you can give -1 reward at each time step, or use a discount factor to capture the time.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1806</fr:anchor><fr:addr
type="machine">#349</fr:addr><fr:route>unstable-349.xml</fr:route><fr:title
text=" [sutton2022, 3.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Due to the recursive relationship, we will start from the back
<fr:tex
display="block"><![CDATA[     \begin {align*}       G_5 &= 0 \\       G_4 &= R_{5} + \gamma  G_5 = 2 \\       G_3 &= R_{4} + \gamma  G_4 = 4 \\       G_2 &= R_{3} + \gamma  G_3 = 8 \\       G_1 &= R_{2} + \gamma  G_2 = 6 \\       G_0 &= R_{1} + \gamma  G_1 = 2     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1808</fr:anchor><fr:addr
type="machine">#350</fr:addr><fr:route>unstable-350.xml</fr:route><fr:title
text=" [sutton2022, 3.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
From the definition,
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_0 &= R_{1} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 2 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 2 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 2} \\ &= 2 + \frac {7 \gamma }{1 - \gamma } \\ &= 65 \end {align*} ]]></fr:tex>
and 
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_1 &= R_{2} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 7 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 7 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 3} \\ &= 7 + \frac {7 \gamma }{1 - \gamma } \\ &= 70 \end {align*} ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1810</fr:anchor><fr:addr
type="machine">#351</fr:addr><fr:route>unstable-351.xml</fr:route><fr:title
text=" [sutton2022, 3.11]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.11"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.11]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  By just expanding,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R_{t + 1} \mid  S_{t} = s] = \sum _{a} \pi (a \mid  s) \sum _{s'} \sum _{r} p(s', r \mid  s, a) \cdot  r     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1812</fr:anchor><fr:addr
type="machine">#352</fr:addr><fr:route>unstable-352.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  <fr:tex
display="block"><![CDATA[       \begin {align*}         v_{\pi }(s) &= \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1814</fr:anchor><fr:addr
type="machine">#353</fr:addr><fr:route>unstable-353.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
<fr:tex
display="block"><![CDATA[ \begin {align*}   q_{\pi }(s, a) = \sum _{s', r} p(s', r \mid  s, a) \big (r + \gamma  v_{\pi }(s')\big ) \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1816</fr:anchor><fr:addr
type="machine">#354</fr:addr><fr:route>unstable-354.xml</fr:route><fr:title
text=" [sutton2022, 3.15]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.15"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.15]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Recall that 
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }(s) = \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1} \mid  S_t = s]     \end {align*}   ]]></fr:tex>
  Adding a constant <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }'(s) &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } \gamma ^{k} R_{t + k + 1} + c \mid  S_t = s] \\       &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1}\mid  S_t = s] + \sum _{k = 0}^{\infty } \gamma ^{k} c \\       &= v_{\pi }(s) + \frac {c}{1 - \gamma }     \end {align*}   ]]></fr:tex>
  Therefore, <fr:tex
display="inline"><![CDATA[v_c = \frac {c}{1 - \gamma }]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1818</fr:anchor><fr:addr
type="machine">#355</fr:addr><fr:route>unstable-355.xml</fr:route><fr:title
text=" [sutton2022, 3.16]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.16"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.16]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the episodic case, this would not be the same. In the maze running example, <fr:tex
display="inline"><![CDATA[v_c]]></fr:tex> would be larger for longer episodes. This would then incentivize the agent to actually take LONGER, where as we want the agent to solve the maze as fast as possible.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1820</fr:anchor><fr:addr
type="machine">#356</fr:addr><fr:route>unstable-356.xml</fr:route><fr:title
text=" [sutton2022, 3.18]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.18"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.18]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  This is similar to exercise 3.12. Namely, 
<fr:tex
display="block"><![CDATA[v_{\pi }(s) = \mathbb {E}_{\pi }[q_{\pi }(s, a)] = \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1822</fr:anchor><fr:addr
type="machine">#362</fr:addr><fr:route>unstable-362.xml</fr:route><fr:title
text="Dynamic Programming">Dynamic Programming</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1824</fr:anchor><fr:addr
type="machine">#358</fr:addr><fr:route>unstable-358.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>Value Iteration as Linear Algebra:</fr:strong> During my brief stint at <fr:link
type="external"
href="https://www.ipam.ucla.edu/">IPAM</fr:link>, I spent a lot of time focused on <fr:link
type="local"
href="kanariosdas2023.xml"
addr="kanariosdas2023"
title="Parallel Algebraic Multigrid for Higher Order PDEs">solving large systems for discretized PDEs</fr:link>. From this, I learned about iterative methods, such as Gauss-Jacobi and Gauss-Seidel. Interestingly, these methods can be used to interpret some of RL's most fundamental algorithms. If we define the following matrices,
<fr:tex
display="block"><![CDATA[   \begin {align*}         R &= \begin {bmatrix}         \mathbb {E}[r(s = 1)]\\         \vdots  \\         \mathbb {E}[r(s = n)]         \end {bmatrix}, \quad  P = \begin {bmatrix}         P_{\pi }(s'=1 | s=1) & \cdots  & P_{\pi }(s'=n | s=1) \\         \vdots  & \ddots  & \vdots  \\         P_{\pi }(s'=1 | s=n) & \cdots  & P_{\pi }(s'=n | s=n)         \end {bmatrix}, \\           V_k &= \begin {bmatrix}         V_k(s = 1)\\         \vdots  \\         V_k(s = n)         \end {bmatrix}   \end {align*}       ]]></fr:tex>
      Then we can write the value function <fr:tex
display="inline"><![CDATA[V_{\pi }]]></fr:tex> as the solution to the linear system
      <fr:tex
display="block"><![CDATA[           V_{\pi } = R + PV_{\pi } \iff  V_{\pi } = (1 - P)^{-1} R         ]]></fr:tex>
    This is just inverting a matrix! Updating one state with the canonical update
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{k + 1}(s) = \sum _{a}\pi (a|s)\sum _{s^{\prime },r}p(s^{\prime },r\,|\,s,a)\Big [r+\gamma  v_{k}(s^{\prime })\Big ]     \end {align*} ]]></fr:tex>
Is actually just one iteration of Gauss-Seidel!
    </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1826</fr:anchor><fr:addr
type="machine">#359</fr:addr><fr:route>unstable-359.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>(Number of updates as pseudo discount factor). </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1828</fr:anchor><fr:addr
type="machine">#360</fr:addr><fr:route>unstable-360.xml</fr:route><fr:title
text=" [sutton2022, 4.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    We have that
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(11, \mathrm {down}) &= -1,       \end {align*}     ]]></fr:tex>
    where there is no recursion because the episode ends.
    Next,
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(7, \mathrm {down}) &= -1 + v(11) \\         &= -1 - 14 \\          &= -15       \end {align*}     ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1830</fr:anchor><fr:addr
type="machine">#361</fr:addr><fr:route>unstable-361.xml</fr:route><fr:title
text=" [sutton2022, 4.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  

  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:addr
type="machine">#365</fr:addr><fr:route>unstable-365.xml</fr:route><fr:title
text="Review Question">Review Question</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1834</fr:anchor><fr:addr
type="machine">#363</fr:addr><fr:route>unstable-363.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Review the methods discussed in the first part of the book. What are their strengths and weaknesses? When should they be used?</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
style="white-space: nowrap">
    
 
   
   <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1836</fr:anchor><fr:addr
type="machine">#364</fr:addr><fr:route>unstable-364.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
        
  <html:tr>
          
  <html:td />

          
  <html:td><fr:strong>Strength</fr:strong></html:td>

          
  <html:td><fr:strong>Weakness</fr:strong></html:td>

          
  <html:td><fr:strong>Use case</fr:strong></html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Bandits</fr:strong></html:td>

          
  <html:td>Simplest case. Can isolate exploration problem.</html:td>

          
  <html:td>No credit assignment. Action only effect next timestep.</html:td>

          
  <html:td>Clinical trials. Things without temporally extended outcomes.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dynamic Programming</fr:strong></html:td>

          
  <html:td>Exact solution.</html:td>

          
  <html:td>Complexity blows up with state and action space. Model-based.</html:td>

          
  <html:td>Tabular MDPs.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Monte Carlo</fr:strong></html:td>

          
  <html:td>Unbiased estimator. Model-free.</html:td>

          
  <html:td>Extremely high variance. Must wait till end of episode.</html:td>

          
  <html:td>When interacting with environment is inexpensive, episode length is short.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>TD methods</fr:strong></html:td>

          
  <html:td>Model-free. Online.</html:td>

          
  <html:td>Biased estimator.</html:td>

          
  <html:td>Environment interaction is cheap but also episode length is long or continuing.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>N step</fr:strong></html:td>

          
  <html:td>Balance bias-variance tradeoff.</html:td>

          
  <html:td>Must choose <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</html:td>

          
  <html:td>Lower variance continuing environments?</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dyna</fr:strong></html:td>

          
  <html:td>Sample efficiency.</html:td>

          
  <html:td>Model-based.</html:td>

          
  <html:td>When interacting with environment is costly i.e. driving.</html:td>

        </html:tr>

      </html:table>

    </fr:mainmatter><fr:backmatter /></fr:tree>
 

  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1838</fr:anchor><fr:addr
type="user">kak-000G</fr:addr><fr:route>kak-000G.xml</fr:route><fr:title
text="On-policy Prediction with Approximation">On-policy Prediction with Approximation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In my opinion, the most important part of this chapter is now that when we update say a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function for a specific state action pair <fr:tex
display="inline"><![CDATA[(s,a)]]></fr:tex>, then this update can affect the value of the <fr:tex
display="inline"><![CDATA[Q(s', a')]]></fr:tex> due to the reuse of the internal parameters.</fr:p>
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1839</fr:anchor><fr:addr
type="machine">#367</fr:addr><fr:route>unstable-367.xml</fr:route><fr:title
text=" [sutton2022, 9.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Show that tabular methods are a special case of linear function approximation. What would the feature vectors be?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1840</fr:anchor><fr:addr
type="machine">#368</fr:addr><fr:route>unstable-368.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
<fr:p>As a linear function approximation method, we have two quantities <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {x}(s)]]></fr:tex>. We make the update
<fr:tex
display="block"><![CDATA[w_{t + 1} = w_{t} + \alpha (r_t + \gamma  w_{t}^{\top } x_{t+1} - w_t^{\top } x_t) x_t]]></fr:tex>
In the tabular setting, we just assume that we have the capacity to represent every possible state. This means that <fr:tex
display="inline"><![CDATA[x(s) \in  \mathbb {R}^{|S|}]]></fr:tex>. Therefore, if we define the features as <fr:tex
display="inline"><![CDATA[x : s_i \mapsto  \boldsymbol {e}_i]]></fr:tex> then we can recover policy evaluation by taking,
<fr:tex
display="block"><![CDATA[r_i = \mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)], \quad  w_i = v_{\pi }(s_i)]]></fr:tex></fr:p>
Substituting, we get 
<fr:tex
display="block"><![CDATA[ w_{t + 1} = w_{t} + \alpha (\mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)] + v(s_{t + 1}) - v(s_{t})) \cdot  \boldsymbol {e}_i ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> is our vector of values, updating the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>th entry is exactly performing exactly one update to <fr:tex
display="inline"><![CDATA[v_{\pi }(s_i)]]></fr:tex> in the tabular setting.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1841</fr:anchor><fr:addr
type="machine">#369</fr:addr><fr:route>unstable-369.xml</fr:route><fr:title
text=" [sutton2022, 9.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Why does (9.17) define <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> distinct features for dimension k?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1842</fr:anchor><fr:addr
type="machine">#370</fr:addr><fr:route>unstable-370.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each <fr:tex
display="inline"><![CDATA[s_j]]></fr:tex>, there are <fr:tex
display="inline"><![CDATA[n + 1]]></fr:tex> options for <fr:tex
display="inline"><![CDATA[c_{i, j}]]></fr:tex>. Since there are <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_{j}]]></fr:tex>'s, there are <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> total possible features for <fr:tex
display="inline"><![CDATA[x_i]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1843</fr:anchor><fr:addr
type="machine">#371</fr:addr><fr:route>unstable-371.xml</fr:route><fr:title
text=" [sutton2022, 9.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
<fr:p>What <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{i,j}]]></fr:tex> produce the feature vectors <fr:tex
display="block"><![CDATA[\mathbf {x}(s)=(1,s_{1},s_{2},s_{1}s_{2},s_{1}^{2},s_{2}^{2},s_{1}^{2}s_{2}^{2},s_{1}s_{2}^{2},s_{1}^{2}s_{2}^{2})^{\top }?]]></fr:tex></fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1844</fr:anchor><fr:addr
type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p><fr:tex
display="inline"><![CDATA[n = 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{ij}]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\boldsymbol {c_0} = [0, 0], \quad    \boldsymbol {c_1} = [1, 0] \\   \boldsymbol {c_2} = [0, 1], \quad    \boldsymbol {c_3} = [1, 1] \\   \boldsymbol {c_4} = [2, 0], \quad    \boldsymbol {c_5} = [0, 2] \\   \boldsymbol {c_6} = [2, 2], \quad    \boldsymbol {c_7} = [1, 2], \quad    \boldsymbol {c_8} = [2, 2]   ]]></fr:tex></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1845</fr:anchor><fr:addr
type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In section 9.5.2, what do they mean when they say you can select <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so all the fourier features can be used?
    <fr:ol><fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k < mk^2]]></fr:tex>.</fr:li>
        <fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> is reasonable.</fr:li></fr:ol></fr:li>
    <fr:p>In the tabular case, I think (a) is correct. My initial understanding of state representation is as a representation learning i.e. compression type objective. If we assume that <fr:tex
display="inline"><![CDATA[s_i \in  [m]]]></fr:tex>, then we do not gain anything in the tabular setting if our value function vector is the same size as the underlying transition kernel. When in the continuous state space regime i.e. <fr:tex
display="inline"><![CDATA[s_i \in  [0,1]]]></fr:tex>, there is no amount of features that would overfit the transition kernel. Therefore, it is just about trying to learn as much as possible about the underlying relations of the state dimensions.</fr:p>
    <fr:p>In the <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-dimensional case, the feature vector <fr:tex
display="inline"><![CDATA[c_i = [1,1]]]></fr:tex> would provide information on how <fr:tex
display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_2]]></fr:tex> relate not just their specific values. You want the learning algorithm to understand the relationships, so that it can make better use of the internal parameters when learning something like a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. This is basically just SVD but instead of classification you are learning a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. The compression</fr:p></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1846</fr:anchor><fr:addr
type="machine">#374</fr:addr><fr:route>unstable-374.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In Figure 9.5, why do fourier features outperform polynomial features?
    <fr:ol><fr:li>The fourier features got lucky on the seeds (lol).</fr:li>
        <fr:li>The choice of <fr:tex
display="inline"><![CDATA[\boldsymbol {c}]]></fr:tex> is not specified. A good choice can provide improvement specific to the problem?</fr:li>
        <fr:li>Polynomial features range is very large. Can suffer from blowup or vanishing of features.</fr:li></fr:ol></fr:li>
    One of the advantages of fourier features mentioned previously is the ability to select which features to serve as your basis. However, for this setup I assume they just use all of the fourier features. This likely means it is more of an issue with the polynomial features and (c). If you have a large polynomial then even relative similar states <fr:tex
display="inline"><![CDATA[s_1 = 1.1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_2 = 0.9]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ldots ]]></fr:tex> can blow up or vanish making them likely more unstable when using gradient-based methods.</fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1847</fr:anchor><fr:addr
type="machine">#375</fr:addr><fr:route>unstable-375.xml</fr:route><fr:title
text=" [sutton2022, 9.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>You could do anisotropic (big word for asymmetric) tile partitioning. If we consider the two state dimensions as (x,y) coordinates and suppose that we want to only generalize across the <fr:tex
display="inline"><![CDATA[y]]></fr:tex>-direction i.e. we want states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate to have similar values then we would tile with long thin tiles. Therefore, states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate would lie in the same vertical tile and if the tiles are very thin any change in <fr:tex
display="inline"><![CDATA[x]]></fr:tex>-coordinate would lie in disjoint tiles.</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1848</fr:anchor><fr:addr
type="machine">#376</fr:addr><fr:route>unstable-376.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>I think that RBF as a continuous generalization coarse-coding is a nice intuition I want to remember here. Essentially, you just weight a state by how close it is to the center of the receptive field. This weighting is done via a Gaussian kernel, which I believe is arbitrary and can be any distance measure of choice.</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3595</fr:anchor><fr:addr
type="user">kak-0032</fr:addr><fr:route>kak-0032.xml</fr:route><fr:title
text="Systems Programming">Systems Programming</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1851</fr:anchor><fr:addr
type="user">kak-004H</fr:addr><fr:route>kak-004H.xml</fr:route><fr:title
text="Notes on Systems Programming">Notes on Systems Programming</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>782</fr:anchor><fr:addr
type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:title
text="Reading List / Useful Resources">Reading List / Useful Resources</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:link
type="external"
href="https://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc_tutorial.pdf">A Malloc Tutorial</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://github.com/DoctorWkt/acwj">A compiler writing journey</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://www.jmeiners.com/lc3-vm/">Writing your own Virtual Machine</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="http://www.catb.org/esr/structure-packing/">Struct alignment in C</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://maplant.com/2020-04-25-Writing-a-Simple-Garbage-Collector-in-C.html">Write a Simple Garbage Collector</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c">Virual function explanation</fr:link></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>783</fr:anchor><fr:addr
type="user">kak-004I</fr:addr><fr:route>kak-004I.xml</fr:route><fr:title
text="Virtual Memory">Virtual Memory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In my foray into C programming, I have become thoroughly confused with virtual memory and the like. Mainly, what is malloc really doing? In the minimap2 library, they implement essentially their own memory management on top of malloc. The reason for this is what had me confused. I think the following summarizes my findings:
  <fr:ul><fr:li>When a process is started by the OS, it allocates virtual address space for the process.</fr:li>
    <fr:li>Within this virtual address space, malloc allocates memory on the heap. Namely, just returning a pointer (technically virtual address) to a block of memory of the desired size.</fr:li>
    <fr:ul><fr:li>Malloc is an OS system call and therefore stops execution of all threads.</fr:li>
      <fr:li>To get around this, they pre-allocate their own intra-thread memory (a large contiguous chunk) then allocate memory within this chunk throughout the program.</fr:li></fr:ul></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>785</fr:anchor><fr:addr
type="user">kak-0025</fr:addr><fr:route>kak-0025.xml</fr:route><fr:title
text="Stack vs. Heap">Stack vs. Heap</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>I often hear this question come up amongst performance-driven developers, and for the longest time I could never get a straight answer as to why the stack was so much better? After a long foray into the inner workings of how memory allocation is actually done, I think I finally have an answer. I do not want to forget this, so I am doing a quick write up here.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>786</fr:anchor><fr:addr
type="machine">#329</fr:addr><fr:route>unstable-329.xml</fr:route><fr:title
text="Why stack is faster.">Why stack is faster.</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
This all comes down to memory allocation. Prior to actually running the program, the operating system allocates some amount of memory for both the stack and the heap (I think around 2-4MB?).
<fr:ul><fr:li>Stack just increments stack pointer.</fr:li>
    <fr:li>Heap searches through <fr:link
type="external"
href="https://gee.cs.oswego.edu/dl/html/malloc.html">bins</fr:link>. 
    <fr:ul><fr:li>Apparently malloc is implemented via the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">buddy algorithm</fr:link></fr:li>
        <fr:li>TODO: Look into this more.</fr:li></fr:ul></fr:li>
    <fr:li>Real speedup is when heap runs out of pre-allocated memory.
    <fr:ul><fr:li>Has to trap to OS to get more memory. Page-fault can result in write to disk and therefore eternal misery...</fr:li>
      <fr:li>Formally, this is known as "heap growth".</fr:li></fr:ul></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3597</fr:anchor><fr:addr
type="user">kak-0012</fr:addr><fr:route>kak-0012.xml</fr:route><fr:title
text="Notes on Reinforcement Learning: An Introduction">Notes on <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This won't really be notes, my lab has begun taking a few undergrads who are not familiar with RL. I will be onboarding them by going through <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link>. Specifically, I will be following the <fr:link
type="local"
href="richardsutton.xml"
addr="richardsutton"
title="Richard Sutton">Richard Sutton</fr:link> flavor of RL through his <fr:link
type="external"
href="https://drive.google.com/drive/folders/0B3w765rOKuKANmxNbXdwaE1YU1k?resourcekey=0-JZz-noRuJgogNsg1ljgV8w">CMPUT 609</fr:link> course. You know what the say: the best way to learn is to teach! Here, I will try to solve all the problems as we go and prepare some questions for the undergrads for when we meet. Additionally, I will document my foray into more advanced exploration of topics introduced in the textbook.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1778</fr:anchor><fr:addr
type="machine">#344</fr:addr><fr:route>unstable-344.xml</fr:route><fr:title
text="Multi-armed Bandits">Multi-armed Bandits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1780</fr:anchor><fr:addr
type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title
text=" [sutton2022, 2.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the case of two actions, (assuming that <fr:tex
display="inline"><![CDATA[Q_*(a_1) > Q_*(a_2)]]></fr:tex>) the probability of the greedy action being selected is <fr:tex
display="inline"><![CDATA[1 - \epsilon ]]></fr:tex> or 0.5.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1782</fr:anchor><fr:addr
type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title
text=" [sutton2022, 2.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the long run <fr:tex
display="inline"><![CDATA[\epsilon  = 0.01]]></fr:tex>, would achieve the highest reward. The expected reward can be written as
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* = \max _{a} q^*(a) + \frac {\epsilon }{n}\sum _{i \neq  a}^{n} q^*(i)     \end {align*}   ]]></fr:tex>
  The exception is that if <fr:tex
display="inline"><![CDATA[\epsilon  = 0]]></fr:tex>, then there are no guarantees. For example, if your initialization is zeros. Then you could have an empirical average of a suboptimal arm that is always positive and you would never deviate. Thus, to ensure you converge to the true optimal arm you need <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1784</fr:anchor><fr:addr
type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title
text=" [sutton2022, 2.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  TODO

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1786</fr:anchor><fr:addr
type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title
text=" [sutton2022, 2.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Following the steps in 2.6,
  <fr:tex
display="block"><![CDATA[       \begin {align*}         Q_{n + 1} &= Q_n + \alpha _n [R_n - Q_n] \\         &= Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}] + \alpha _n \Big [R_n - (Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}])\Big ] \\         &\vdots  \\         & = \left (\prod _{i = 1}^{n} (1 - \alpha _{i})\right ) Q_1 + \sum _{i = 1}^{n} \alpha _n \left (\prod _{i = 1}^{n} (1 - \alpha _{n - i})\right )R_i       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1788</fr:anchor><fr:addr
type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title
text=" [sutton2022, 2.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since all of the arms in the testbed have distributions with support less than 5, in the beginning the unpulled arm's optimistic estimates will be higher than the empirical estimates of the previously pulled arms. Therefore, in the early stages all of the arms will be pulled in a round robin fashion, and assuming deterministic rewards the optimal arm will keep being pulled until it falls below the other optimistic values.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1790</fr:anchor><fr:addr
type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title
text=" [sutton2022, 2.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since there are 10 arms (presumably with the same initialization), the UCB bonus will enforce that the first 10 pulls are round robin (uniform) pulling of each of the 10 arms. Then on the 11th step each will have the same UCB bonus term but the one with the highest empirical reward will be pulled, leading to a spike. It then drops in subsequent steps because the UCB bonus of that arm will decrease and other (possibly less optimal) arms are pulled in subsequent steps.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1792</fr:anchor><fr:addr
type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title
text=" [sutton2022, 2.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We can just expand the denominator as
<fr:tex
display="block"><![CDATA[     \begin {align*}       \Pr \{A_t = a\} &= \frac {e^{H_t(a)}}{e^{H_t(a)} + e^{H_t(b)}} \\       &= \frac {1}{1 + e^{\frac {H_t(b)}{H_t(a)}}} \\       &= \frac {1}{1 + e^{-\frac {H_t(a)}{H_t(b)}}} \\     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1794</fr:anchor><fr:addr
type="machine">#343</fr:addr><fr:route>unstable-343.xml</fr:route><fr:title
text=" [sutton2022, 2.10]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.10"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.10]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In case 1, the best you can hope to achieve is <fr:tex
display="inline"><![CDATA[\max _{a} \mathbb {E} [R(a)]]]></fr:tex>. In this case, we have
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R(1)] &= 0.5 \cdot  10 + 0.5 \cdot  90 = 50, \\       \mathbb {E}[R(2)] &= 0.5 \cdot  20 + 0.5 \cdot  80 = 50     \end {align*}   ]]></fr:tex>
  Therefore, the best we can hope to achieve is <fr:tex
display="inline"><![CDATA[50]]></fr:tex>. If we are given what case we are in, then we can achieve
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* &= 0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 1] +       0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 2] \\       &= 0.5 \cdot  20 + 0.5 \cdot  90 \\       &= 55     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1796</fr:anchor><fr:addr
type="machine">#357</fr:addr><fr:route>unstable-357.xml</fr:route><fr:title
text="Markov Decision Processes">Markov Decision Processes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1798</fr:anchor><fr:addr
type="machine">#345</fr:addr><fr:route>unstable-345.xml</fr:route><fr:title
text=" [sutton2022, 3.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  I think you draw the line at where you can already execute the necessary behavior to get from one state to another. This is eerily familiar to the line of work known as hierarchical reinforcement learning, where you gradually learn higher level of abstraction by executing subpolicies.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1800</fr:anchor><fr:addr
type="machine">#346</fr:addr><fr:route>unstable-346.xml</fr:route><fr:title
text=" [sutton2022, 3.5]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.5"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.5]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We need to add the notion of a terminal state. This can be done by just adding some <fr:tex
display="inline"><![CDATA[t]]></fr:tex> to the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. Then
  <fr:tex
display="block"><![CDATA[       \begin {cases}         p(t, 0 \mid  s, a) = 1, &\text { if } s = t\\         \sum _{s^{\prime }\in \mathcal {S}}\sum _{r\in \mathcal {R}}p(s^{\prime },r|s,a)=1,\mathrm {~for~all~}s\in \mathcal {S},a\in \mathcal {A}(s), &\text { if } s \neq  t       \end {cases} ]]></fr:tex>
I think the idea is just that when you hit a terminal state you no longer can reach other states.
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1802</fr:anchor><fr:addr
type="machine">#347</fr:addr><fr:route>unstable-347.xml</fr:route><fr:title
text=" [sutton2022, 3.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> denote the length of the episode. Then the return <fr:tex
display="inline"><![CDATA[G_t]]></fr:tex> would be 
<fr:tex
display="block"><![CDATA[   \begin {align*} G_t &= R_{t+1} + \gamma  R_{t + 2} + \cdots  + \gamma ^{T - {t + 1}} R_T = - \gamma ^{T - {t + 1}}   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1804</fr:anchor><fr:addr
type="machine">#348</fr:addr><fr:route>unstable-348.xml</fr:route><fr:title
text=" [sutton2022, 3.7]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.7"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.7]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  You have not effectively communicated the task. The agent has no incentive to solve the maze as fast as possible. This means that no matter the duration it took to solve the task the agent would receive the same reward. To fix this, you can give -1 reward at each time step, or use a discount factor to capture the time.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1806</fr:anchor><fr:addr
type="machine">#349</fr:addr><fr:route>unstable-349.xml</fr:route><fr:title
text=" [sutton2022, 3.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Due to the recursive relationship, we will start from the back
<fr:tex
display="block"><![CDATA[     \begin {align*}       G_5 &= 0 \\       G_4 &= R_{5} + \gamma  G_5 = 2 \\       G_3 &= R_{4} + \gamma  G_4 = 4 \\       G_2 &= R_{3} + \gamma  G_3 = 8 \\       G_1 &= R_{2} + \gamma  G_2 = 6 \\       G_0 &= R_{1} + \gamma  G_1 = 2     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1808</fr:anchor><fr:addr
type="machine">#350</fr:addr><fr:route>unstable-350.xml</fr:route><fr:title
text=" [sutton2022, 3.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
From the definition,
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_0 &= R_{1} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 2 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 2 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 2} \\ &= 2 + \frac {7 \gamma }{1 - \gamma } \\ &= 65 \end {align*} ]]></fr:tex>
and 
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_1 &= R_{2} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 7 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 7 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 3} \\ &= 7 + \frac {7 \gamma }{1 - \gamma } \\ &= 70 \end {align*} ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1810</fr:anchor><fr:addr
type="machine">#351</fr:addr><fr:route>unstable-351.xml</fr:route><fr:title
text=" [sutton2022, 3.11]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.11"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.11]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  By just expanding,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R_{t + 1} \mid  S_{t} = s] = \sum _{a} \pi (a \mid  s) \sum _{s'} \sum _{r} p(s', r \mid  s, a) \cdot  r     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1812</fr:anchor><fr:addr
type="machine">#352</fr:addr><fr:route>unstable-352.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  <fr:tex
display="block"><![CDATA[       \begin {align*}         v_{\pi }(s) &= \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1814</fr:anchor><fr:addr
type="machine">#353</fr:addr><fr:route>unstable-353.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
<fr:tex
display="block"><![CDATA[ \begin {align*}   q_{\pi }(s, a) = \sum _{s', r} p(s', r \mid  s, a) \big (r + \gamma  v_{\pi }(s')\big ) \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1816</fr:anchor><fr:addr
type="machine">#354</fr:addr><fr:route>unstable-354.xml</fr:route><fr:title
text=" [sutton2022, 3.15]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.15"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.15]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Recall that 
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }(s) = \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1} \mid  S_t = s]     \end {align*}   ]]></fr:tex>
  Adding a constant <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }'(s) &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } \gamma ^{k} R_{t + k + 1} + c \mid  S_t = s] \\       &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1}\mid  S_t = s] + \sum _{k = 0}^{\infty } \gamma ^{k} c \\       &= v_{\pi }(s) + \frac {c}{1 - \gamma }     \end {align*}   ]]></fr:tex>
  Therefore, <fr:tex
display="inline"><![CDATA[v_c = \frac {c}{1 - \gamma }]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1818</fr:anchor><fr:addr
type="machine">#355</fr:addr><fr:route>unstable-355.xml</fr:route><fr:title
text=" [sutton2022, 3.16]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.16"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.16]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the episodic case, this would not be the same. In the maze running example, <fr:tex
display="inline"><![CDATA[v_c]]></fr:tex> would be larger for longer episodes. This would then incentivize the agent to actually take LONGER, where as we want the agent to solve the maze as fast as possible.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1820</fr:anchor><fr:addr
type="machine">#356</fr:addr><fr:route>unstable-356.xml</fr:route><fr:title
text=" [sutton2022, 3.18]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.18"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.18]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  This is similar to exercise 3.12. Namely, 
<fr:tex
display="block"><![CDATA[v_{\pi }(s) = \mathbb {E}_{\pi }[q_{\pi }(s, a)] = \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1822</fr:anchor><fr:addr
type="machine">#362</fr:addr><fr:route>unstable-362.xml</fr:route><fr:title
text="Dynamic Programming">Dynamic Programming</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1824</fr:anchor><fr:addr
type="machine">#358</fr:addr><fr:route>unstable-358.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>Value Iteration as Linear Algebra:</fr:strong> During my brief stint at <fr:link
type="external"
href="https://www.ipam.ucla.edu/">IPAM</fr:link>, I spent a lot of time focused on <fr:link
type="local"
href="kanariosdas2023.xml"
addr="kanariosdas2023"
title="Parallel Algebraic Multigrid for Higher Order PDEs">solving large systems for discretized PDEs</fr:link>. From this, I learned about iterative methods, such as Gauss-Jacobi and Gauss-Seidel. Interestingly, these methods can be used to interpret some of RL's most fundamental algorithms. If we define the following matrices,
<fr:tex
display="block"><![CDATA[   \begin {align*}         R &= \begin {bmatrix}         \mathbb {E}[r(s = 1)]\\         \vdots  \\         \mathbb {E}[r(s = n)]         \end {bmatrix}, \quad  P = \begin {bmatrix}         P_{\pi }(s'=1 | s=1) & \cdots  & P_{\pi }(s'=n | s=1) \\         \vdots  & \ddots  & \vdots  \\         P_{\pi }(s'=1 | s=n) & \cdots  & P_{\pi }(s'=n | s=n)         \end {bmatrix}, \\           V_k &= \begin {bmatrix}         V_k(s = 1)\\         \vdots  \\         V_k(s = n)         \end {bmatrix}   \end {align*}       ]]></fr:tex>
      Then we can write the value function <fr:tex
display="inline"><![CDATA[V_{\pi }]]></fr:tex> as the solution to the linear system
      <fr:tex
display="block"><![CDATA[           V_{\pi } = R + PV_{\pi } \iff  V_{\pi } = (1 - P)^{-1} R         ]]></fr:tex>
    This is just inverting a matrix! Updating one state with the canonical update
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{k + 1}(s) = \sum _{a}\pi (a|s)\sum _{s^{\prime },r}p(s^{\prime },r\,|\,s,a)\Big [r+\gamma  v_{k}(s^{\prime })\Big ]     \end {align*} ]]></fr:tex>
Is actually just one iteration of Gauss-Seidel!
    </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1826</fr:anchor><fr:addr
type="machine">#359</fr:addr><fr:route>unstable-359.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>(Number of updates as pseudo discount factor). </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1828</fr:anchor><fr:addr
type="machine">#360</fr:addr><fr:route>unstable-360.xml</fr:route><fr:title
text=" [sutton2022, 4.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    We have that
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(11, \mathrm {down}) &= -1,       \end {align*}     ]]></fr:tex>
    where there is no recursion because the episode ends.
    Next,
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(7, \mathrm {down}) &= -1 + v(11) \\         &= -1 - 14 \\          &= -15       \end {align*}     ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1830</fr:anchor><fr:addr
type="machine">#361</fr:addr><fr:route>unstable-361.xml</fr:route><fr:title
text=" [sutton2022, 4.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  

  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:addr
type="machine">#365</fr:addr><fr:route>unstable-365.xml</fr:route><fr:title
text="Review Question">Review Question</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1834</fr:anchor><fr:addr
type="machine">#363</fr:addr><fr:route>unstable-363.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Review the methods discussed in the first part of the book. What are their strengths and weaknesses? When should they be used?</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
style="white-space: nowrap">
    
 
   
   <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1836</fr:anchor><fr:addr
type="machine">#364</fr:addr><fr:route>unstable-364.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
        
  <html:tr>
          
  <html:td />

          
  <html:td><fr:strong>Strength</fr:strong></html:td>

          
  <html:td><fr:strong>Weakness</fr:strong></html:td>

          
  <html:td><fr:strong>Use case</fr:strong></html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Bandits</fr:strong></html:td>

          
  <html:td>Simplest case. Can isolate exploration problem.</html:td>

          
  <html:td>No credit assignment. Action only effect next timestep.</html:td>

          
  <html:td>Clinical trials. Things without temporally extended outcomes.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dynamic Programming</fr:strong></html:td>

          
  <html:td>Exact solution.</html:td>

          
  <html:td>Complexity blows up with state and action space. Model-based.</html:td>

          
  <html:td>Tabular MDPs.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Monte Carlo</fr:strong></html:td>

          
  <html:td>Unbiased estimator. Model-free.</html:td>

          
  <html:td>Extremely high variance. Must wait till end of episode.</html:td>

          
  <html:td>When interacting with environment is inexpensive, episode length is short.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>TD methods</fr:strong></html:td>

          
  <html:td>Model-free. Online.</html:td>

          
  <html:td>Biased estimator.</html:td>

          
  <html:td>Environment interaction is cheap but also episode length is long or continuing.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>N step</fr:strong></html:td>

          
  <html:td>Balance bias-variance tradeoff.</html:td>

          
  <html:td>Must choose <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</html:td>

          
  <html:td>Lower variance continuing environments?</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dyna</fr:strong></html:td>

          
  <html:td>Sample efficiency.</html:td>

          
  <html:td>Model-based.</html:td>

          
  <html:td>When interacting with environment is costly i.e. driving.</html:td>

        </html:tr>

      </html:table>

    </fr:mainmatter><fr:backmatter /></fr:tree>
 

  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1838</fr:anchor><fr:addr
type="user">kak-000G</fr:addr><fr:route>kak-000G.xml</fr:route><fr:title
text="On-policy Prediction with Approximation">On-policy Prediction with Approximation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In my opinion, the most important part of this chapter is now that when we update say a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function for a specific state action pair <fr:tex
display="inline"><![CDATA[(s,a)]]></fr:tex>, then this update can affect the value of the <fr:tex
display="inline"><![CDATA[Q(s', a')]]></fr:tex> due to the reuse of the internal parameters.</fr:p>
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1839</fr:anchor><fr:addr
type="machine">#367</fr:addr><fr:route>unstable-367.xml</fr:route><fr:title
text=" [sutton2022, 9.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Show that tabular methods are a special case of linear function approximation. What would the feature vectors be?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1840</fr:anchor><fr:addr
type="machine">#368</fr:addr><fr:route>unstable-368.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
<fr:p>As a linear function approximation method, we have two quantities <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {x}(s)]]></fr:tex>. We make the update
<fr:tex
display="block"><![CDATA[w_{t + 1} = w_{t} + \alpha (r_t + \gamma  w_{t}^{\top } x_{t+1} - w_t^{\top } x_t) x_t]]></fr:tex>
In the tabular setting, we just assume that we have the capacity to represent every possible state. This means that <fr:tex
display="inline"><![CDATA[x(s) \in  \mathbb {R}^{|S|}]]></fr:tex>. Therefore, if we define the features as <fr:tex
display="inline"><![CDATA[x : s_i \mapsto  \boldsymbol {e}_i]]></fr:tex> then we can recover policy evaluation by taking,
<fr:tex
display="block"><![CDATA[r_i = \mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)], \quad  w_i = v_{\pi }(s_i)]]></fr:tex></fr:p>
Substituting, we get 
<fr:tex
display="block"><![CDATA[ w_{t + 1} = w_{t} + \alpha (\mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)] + v(s_{t + 1}) - v(s_{t})) \cdot  \boldsymbol {e}_i ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> is our vector of values, updating the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>th entry is exactly performing exactly one update to <fr:tex
display="inline"><![CDATA[v_{\pi }(s_i)]]></fr:tex> in the tabular setting.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1841</fr:anchor><fr:addr
type="machine">#369</fr:addr><fr:route>unstable-369.xml</fr:route><fr:title
text=" [sutton2022, 9.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Why does (9.17) define <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> distinct features for dimension k?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1842</fr:anchor><fr:addr
type="machine">#370</fr:addr><fr:route>unstable-370.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each <fr:tex
display="inline"><![CDATA[s_j]]></fr:tex>, there are <fr:tex
display="inline"><![CDATA[n + 1]]></fr:tex> options for <fr:tex
display="inline"><![CDATA[c_{i, j}]]></fr:tex>. Since there are <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_{j}]]></fr:tex>'s, there are <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> total possible features for <fr:tex
display="inline"><![CDATA[x_i]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1843</fr:anchor><fr:addr
type="machine">#371</fr:addr><fr:route>unstable-371.xml</fr:route><fr:title
text=" [sutton2022, 9.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
<fr:p>What <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{i,j}]]></fr:tex> produce the feature vectors <fr:tex
display="block"><![CDATA[\mathbf {x}(s)=(1,s_{1},s_{2},s_{1}s_{2},s_{1}^{2},s_{2}^{2},s_{1}^{2}s_{2}^{2},s_{1}s_{2}^{2},s_{1}^{2}s_{2}^{2})^{\top }?]]></fr:tex></fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1844</fr:anchor><fr:addr
type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p><fr:tex
display="inline"><![CDATA[n = 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{ij}]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\boldsymbol {c_0} = [0, 0], \quad    \boldsymbol {c_1} = [1, 0] \\   \boldsymbol {c_2} = [0, 1], \quad    \boldsymbol {c_3} = [1, 1] \\   \boldsymbol {c_4} = [2, 0], \quad    \boldsymbol {c_5} = [0, 2] \\   \boldsymbol {c_6} = [2, 2], \quad    \boldsymbol {c_7} = [1, 2], \quad    \boldsymbol {c_8} = [2, 2]   ]]></fr:tex></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1845</fr:anchor><fr:addr
type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In section 9.5.2, what do they mean when they say you can select <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so all the fourier features can be used?
    <fr:ol><fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k < mk^2]]></fr:tex>.</fr:li>
        <fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> is reasonable.</fr:li></fr:ol></fr:li>
    <fr:p>In the tabular case, I think (a) is correct. My initial understanding of state representation is as a representation learning i.e. compression type objective. If we assume that <fr:tex
display="inline"><![CDATA[s_i \in  [m]]]></fr:tex>, then we do not gain anything in the tabular setting if our value function vector is the same size as the underlying transition kernel. When in the continuous state space regime i.e. <fr:tex
display="inline"><![CDATA[s_i \in  [0,1]]]></fr:tex>, there is no amount of features that would overfit the transition kernel. Therefore, it is just about trying to learn as much as possible about the underlying relations of the state dimensions.</fr:p>
    <fr:p>In the <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-dimensional case, the feature vector <fr:tex
display="inline"><![CDATA[c_i = [1,1]]]></fr:tex> would provide information on how <fr:tex
display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_2]]></fr:tex> relate not just their specific values. You want the learning algorithm to understand the relationships, so that it can make better use of the internal parameters when learning something like a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. This is basically just SVD but instead of classification you are learning a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. The compression</fr:p></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1846</fr:anchor><fr:addr
type="machine">#374</fr:addr><fr:route>unstable-374.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In Figure 9.5, why do fourier features outperform polynomial features?
    <fr:ol><fr:li>The fourier features got lucky on the seeds (lol).</fr:li>
        <fr:li>The choice of <fr:tex
display="inline"><![CDATA[\boldsymbol {c}]]></fr:tex> is not specified. A good choice can provide improvement specific to the problem?</fr:li>
        <fr:li>Polynomial features range is very large. Can suffer from blowup or vanishing of features.</fr:li></fr:ol></fr:li>
    One of the advantages of fourier features mentioned previously is the ability to select which features to serve as your basis. However, for this setup I assume they just use all of the fourier features. This likely means it is more of an issue with the polynomial features and (c). If you have a large polynomial then even relative similar states <fr:tex
display="inline"><![CDATA[s_1 = 1.1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_2 = 0.9]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ldots ]]></fr:tex> can blow up or vanish making them likely more unstable when using gradient-based methods.</fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1847</fr:anchor><fr:addr
type="machine">#375</fr:addr><fr:route>unstable-375.xml</fr:route><fr:title
text=" [sutton2022, 9.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>You could do anisotropic (big word for asymmetric) tile partitioning. If we consider the two state dimensions as (x,y) coordinates and suppose that we want to only generalize across the <fr:tex
display="inline"><![CDATA[y]]></fr:tex>-direction i.e. we want states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate to have similar values then we would tile with long thin tiles. Therefore, states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate would lie in the same vertical tile and if the tiles are very thin any change in <fr:tex
display="inline"><![CDATA[x]]></fr:tex>-coordinate would lie in disjoint tiles.</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1848</fr:anchor><fr:addr
type="machine">#376</fr:addr><fr:route>unstable-376.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>I think that RBF as a continuous generalization coarse-coding is a nice intuition I want to remember here. Essentially, you just weight a state by how close it is to the center of the receptive field. This weighting is done via a Gaussian kernel, which I believe is arbitrary and can be any distance measure of choice.</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3599</fr:anchor><fr:addr
type="user">kak-0007</fr:addr><fr:route>kak-0007.xml</fr:route><fr:title
text="Notes on Probability and Measure">Notes on <fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">Probability and Measure</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For these notes, I will attempt to refresh my knowledge of measure-theoretic probability along with learning stochastic processes for the first time. I will be following <fr:link
type="external"
href="https://link.springer.com/book/10.1007/978-0-387-87859-1">Probability and Stochastics</fr:link> by Cinlar. Unfortunately, there are no solutions to exercises, but it is by far the best written book I have found.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1657</fr:anchor><fr:addr
type="machine">#381</fr:addr><fr:route>unstable-381.xml</fr:route><fr:title
text="Borel's Normal Number Theorem">Borel's Normal Number Theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1659</fr:anchor><fr:addr
type="user">kak-000S</fr:addr><fr:route>kak-000S.xml</fr:route><fr:title
text="Additivity of Intervals">Additivity of Intervals</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We have the following properties
  <fr:ol><fr:li>If <fr:tex
display="inline"><![CDATA[\bigcup _{k}I_{k}\subset  I]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[\sum _{k}|I_{k}|\leq |I|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I\subset \bigcup _{k}I_{k}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> need not be disjoint), then <fr:tex
display="inline"><![CDATA[|I|\leq \sum _{k}|I_{k}|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I=\bigcup _{k}I_{k}]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[|I|=\sum _{k}|I_{k}|]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1660</fr:anchor><fr:addr
type="machine">#380</fr:addr><fr:route>unstable-380.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  The important takeaway from <fr:link
type="local"
href="kak-000S.xml"
addr="kak-000S"
title="Additivity of Intervals">Additivity of Intervals</fr:link> is that extending (2) from finite to countable unions requires Heine-Borel theorem, illustrating that this extension is non-trivial. This will be important to remember as we continue to extend the Lebesgue measure to <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras. 
  </fr:mainmatter><fr:backmatter /></fr:tree>

  This section aims to motivate why we need to approach probability from a measure theoretic point of view.
  As an example, we will do the first exercise for this section.
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1662</fr:anchor><fr:addr
type="user">kak-000L</fr:addr><fr:route>kak-000L.xml</fr:route><fr:title
text="Dyadic Intervals">Dyadic Intervals</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Represent coin toss as dyadic expansion consider the set</fr:p><fr:tex
display="block"><![CDATA[\left [\omega :\ d_{i}(\omega )=u_{i},\,i=1,\ldots ,n \right ]=\Big (\sum _{i=1}^{n} \frac {u_{i}}{2^{i}},\ \sum _{i=1}^{n}\frac {u_{i}}{2^{i}} + \frac {1}{2^{n}}\Big ).]]></fr:tex><fr:p>More stuff</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1663</fr:anchor><fr:addr
type="user">kak-000N</fr:addr><fr:route>kak-000N.xml</fr:route><fr:title
text="Problem 1.1 Billingsley">Problem 1.1 Billingsley</fr:title><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:ol><fr:li>A discrete probability space cannot contain an infinite sequence of independent events <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> each with probability <fr:tex
display="inline"><![CDATA[1/2]]></fr:tex>. To see this, denote the event space as <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>. Note that 
    <fr:tex
display="block"><![CDATA[P(A_1 \cap  A_2) + P(A_1 \cap  A_2^c) + P(A_1^c \cap  A_2) + P(A_1^c \cap  A_2^c) = 1]]></fr:tex>
    Therefore, every <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex> must be in one of those four events and have probability at most <fr:tex
display="inline"><![CDATA[1/4]]></fr:tex>. Similarly, we can construct <fr:tex
display="inline"><![CDATA[n]]></fr:tex> disjoint sets in the same manner and bound <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\})]]></fr:tex> by <fr:tex
display="inline"><![CDATA[1/n]]></fr:tex>. Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex>, we have that <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is a discrete probability space, we must have that 
    <fr:tex
display="block"><![CDATA[\sum _{x \in  \mathcal {X}} \mathbb {P}(\{x\}) = 1]]></fr:tex>
    However, we have just shown that for each <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Thus, we have reached a contradiction.</fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree>
  
  I think my main takeaway from this is that infinite sequences break discrete probability because each discrete event will have probability zero. This is not actually a problem because in an infinite sequence the occurence of any such sequence "feasibly" has zero probability. However, we still want to reason about probabilistic things like the convergence of the average of the sequence. Since discrete probability is broken, we cannot even use it for these things. This is why we need to use measure theory to allow for zero probability sequences, but still provide information about these more "general" events. Who knows if this intuition is right though?
</fr:mainmatter><fr:backmatter /></fr:tree>
  
<fr:p><fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1664</fr:anchor><fr:addr
type="machine">#382</fr:addr><fr:route>unstable-382.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>After a bit more digging, the main culprit here is the countable subadditivity condition of measure.</fr:li>
      <fr:li>In a discrete probability space, the entire space is at most countable. Therefore, if each individual event has zero probability then the countable union i.e. the whole space will have zero probability.</fr:li>
      <fr:li>In measure theoretic probability, we are able to accumulate non-zero probability mass from an <fr:strong>uncountable</fr:strong> union of zero measure events.</fr:li>
      <fr:li>I guess the canonical example of this is that each point on a line has length 0, but the line itself (an uncountable union of points) has non-zero length.</fr:li>
      <fr:li>In the dyadic intervals example, each event of an arbitrary discrete probability space can be identified with a point on the line of probability zero.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1666</fr:anchor><fr:addr
type="machine">#385</fr:addr><fr:route>unstable-385.xml</fr:route><fr:title
text="Probability Measures">Probability Measures</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1668</fr:anchor><fr:addr
type="user">kak-000O</fr:addr><fr:route>kak-000O.xml</fr:route><fr:title
text="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class of subsets <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field if the following holds
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots  \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\bigcup _{i = 1}^{\infty } A_i \in  \mathscr {F}]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>It seems, in this section, we aim to answer why certain decisions were made regarding what can be analyzed. For example,</fr:p>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1669</fr:anchor><fr:addr
type="machine">#383</fr:addr><fr:route>unstable-383.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Why do we only allow consider countable unions in the definition of a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>?</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1671</fr:anchor><fr:addr
type="machine">#384</fr:addr><fr:route>unstable-384.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Because this is what god intended.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1673</fr:anchor><fr:addr
type="user">kak-000P</fr:addr><fr:route>kak-000P.xml</fr:route><fr:title
text="Probability Measure">Probability Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A set function is a real-valued function defined on some class of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. A set function <fr:tex
display="inline"><![CDATA[P]]></fr:tex> on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a probability measure if it satisfies these conditions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[0\leq  P(A)\leq 1]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A\in \mathscr {F}]]></fr:tex>;</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[P(\varnothing )=0]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(\Omega )=1]]></fr:tex>;</fr:li>
  <fr:li>if <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> is a disjoint sequence of <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> sets and if <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}\in \mathscr {F}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[P\Big (\bigcup _{k=1}^{\infty }A_{k}\Big )=\sum _{k=1}^{\infty }P(A_{k}).]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1674</fr:anchor><fr:addr
type="user">kak-000Q</fr:addr><fr:route>kak-000Q.xml</fr:route><fr:title
text="Probability Space">Probability Space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field in <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a probability measure on <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, the triple <fr:tex
display="inline"><![CDATA[(\Omega ,\mathscr {F},P)]]></fr:tex> is called a probability measure space, or simply a probability space. A support of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> for which <fr:tex
display="inline"><![CDATA[P(A)=1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1675</fr:anchor><fr:addr
type="user">kak-000R</fr:addr><fr:route>kak-000R.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>.

<fr:ol><fr:li><fr:em>Continuity from below</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathscr {A}_{n}\uparrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\uparrow  P(A)]]></fr:tex>.</fr:li>

<fr:li><fr:em>Continuity from above</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\downarrow  P(A)]]></fr:tex>.</fr:li>
<fr:li><fr:em>Countable subadditivity</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[A_{k}]]></fr:tex> need not be disjoint), then

<fr:tex
display="block"><![CDATA[P\left (\bigcup _{k=1}^{\infty }A_{k}\right )\leq \sum _{k=1}^{\infty }P(A_{k})]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1676</fr:anchor><fr:addr
type="machine">#388</fr:addr><fr:route>unstable-388.xml</fr:route><fr:title
text="Existence and Extension">Existence and Extension</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Here we will see how we can define a probability measure on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex> and get a unique extension to the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {F} = \sigma (\mathscr {F}_0)]]></fr:tex>. I guess the key here is uniqueness?</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1678</fr:anchor><fr:addr
type="user">kak-000T</fr:addr><fr:route>kak-000T.xml</fr:route><fr:title
text="Outer Measure">Outer Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="block"><![CDATA[P^{*}(A)=\mathrm {inf}\,\sum _{n}P(A_{n}),]]></fr:tex> where <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1679</fr:anchor><fr:addr
type="machine">#386</fr:addr><fr:route>unstable-386.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Taking <fr:tex
display="inline"><![CDATA[P_*(A) = 1 - P^*(A^c)]]></fr:tex> gives the inner measure. This is just analogously approximating from the inside.</fr:mainmatter><fr:backmatter /></fr:tree>

    Intuition is that the sets that are "measurable" should be sets that can be arbitrarily approximated from the inside and outside, or equivalently
<fr:tex
display="block"><![CDATA[P^*(A) + P^*(A^c) = 1]]></fr:tex>
    <fr:ol><fr:li>My intution for this is that if a set is not arbitrarily well approximated by countable other sets from our algebra then we cannot hope to get an accurate measure from our measure defined on only the algebra.</fr:li>
      <fr:li>The countableness is just from the definition of the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
    <fr:p>Then we can use <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> as our measure. To do this, we will need to show that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is countable additive as one might expect. The rest of the properties of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> are trivial.</fr:p>

    
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1681</fr:anchor><fr:addr
type="machine">#387</fr:addr><fr:route>unstable-387.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n]]></fr:tex>. By the definition of <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">Outer Measure</fr:link>, we can find some <fr:tex
display="inline"><![CDATA[B_{nk}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[A_n \subset  \bigcup _{k = 1}^{\infty } B_{nk}]]></fr:tex> where 
<fr:tex
display="block"><![CDATA[\sum _{k} P(B_{nk}) < P^*(A_n) + \epsilon  2^{-k}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[C_n = \bigcup _{k} B_{nk}]]></fr:tex>, so that <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n \subset  \bigcup _{n} C_n]]></fr:tex> and
<fr:tex
display="block"><![CDATA[P^*\left (\bigcup _n A_n\right ) < \sum _{n} P(C_n) = \sum _{n} \sum _{k} P(B_{nk}) < \sum _{n} P^*(A_n) + \epsilon ]]></fr:tex></fr:p>
      Since <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n = A]]></fr:tex>, we have achieved the desired result.
    </fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:p>It turns out that for some reason only enforcing <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and its complement to sum to <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is not restrictive enough? From this, we end up with the final condition</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1683</fr:anchor><fr:addr
type="user">kak-000U</fr:addr><fr:route>kak-000U.xml</fr:route><fr:title
text="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable if for every <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>, we have that 
<fr:tex
display="block"><![CDATA[P^*(A \cap  E) + P^*(A^c \cap  E) = P^*(E)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:p>You then only need to show two things:
        <fr:ol><fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets contains <fr:tex
display="inline"><![CDATA[\mathscr {F_0}]]></fr:tex>,</fr:li>
            <fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets is a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
        From these, we can conclude that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is at least defined on a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> containing <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>. Restricting <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>, then yields the desired extension.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1684</fr:anchor><fr:addr
type="machine">#393</fr:addr><fr:route>unstable-393.xml</fr:route><fr:title
text="Uniqueness">Uniqueness</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>We now want to show that the extension we developed in the previous section is actually unique. The first question we have is what do we mean by unique? To answer this, we need to remember what we have done so far.
    <fr:ol><fr:li>We have a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, defined on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>.</fr:li>
        <fr:li>We then extended <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex> via <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>, so that for every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[P(A) = P^*(A)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex></fr:li></fr:ol>
      From this, our only restriction is that <fr:tex
display="inline"><![CDATA[P^*(A) = P(A)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Therefore, uniqueness here means that if <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> and every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[A \in  \sigma (\mathscr {F}_0)]]></fr:tex>.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1686</fr:anchor><fr:addr
type="user">kak-0018</fr:addr><fr:route>kak-0018.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathcal {P}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system if it is closed under the formation of finite intersections:
<fr:tex
display="block"><![CDATA[A,B\in \mathcal {P} \implies  A\cap  B\in \mathcal {P}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1687</fr:anchor><fr:addr
type="user">kak-0019</fr:addr><fr:route>kak-0019.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system if it contains <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and is closed under the formation of complements and of finite and countable disjoint unions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega \in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A\in \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[A^{c}\in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ,\in \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\cap  A_{m}=\varnothing ]]></fr:tex> for <fr:tex
display="inline"><![CDATA[m\neq  n]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[\bigcup _{n}A_{n}\in \mathscr {L}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>I was a bit unsure that a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> is not a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, but the author provided an example that I will walk through to understand the distinction</fr:p>


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1688</fr:anchor><fr:addr
type="machine">#389</fr:addr><fr:route>unstable-389.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
Consider a four point space <fr:tex
display="inline"><![CDATA[\Omega  = \{x_1, x_2, x_3, x_4\}]]></fr:tex>. We can define a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> by taking <fr:tex
display="inline"><![CDATA[\mathscr {L} = \emptyset , \Omega ,]]></fr:tex> and the six two point sets. The union of any two disjoint two point sets will be <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. However, a non-disjoint union of two disjoint sets can result in a three point set, which is not in <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex>. These non-disjoint unions would be covered in a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


<fr:p>To remedy this disconnect, we have the following lemma:</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1690</fr:anchor><fr:addr
type="user">kak-001A</fr:addr><fr:route>kak-001A.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class that is both a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>In our example, we could take the intersection of say <fr:tex
display="inline"><![CDATA[\{x_1, x_2\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2, x_3\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex>. We could then take a disjoint union of <fr:tex
display="inline"><![CDATA[\{x_1, x_3\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_1, x_2, x_3\}]]></fr:tex>.</fr:p> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1691</fr:anchor><fr:addr
type="user">kak-001B</fr:addr><fr:route>kak-001B.xml</fr:route><fr:title
text="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system, then <fr:tex
display="inline"><![CDATA[\mathscr {P}\subset \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})\subset \mathscr {L}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Now we will see how this allows us to prove our desired result i.e. the uniqueness of our extension of a probability on an algebra to the <fr:link
type="external"
href="kak-0000">kak-0000</fr:link> via the outer measure.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1692</fr:anchor><fr:addr
type="user">kak-001C</fr:addr><fr:route>kak-001C.xml</fr:route><fr:title
text="Uniqueness of Extension">Uniqueness of Extension</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> are probability measures on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system. If <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> agree on <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex>, then they agree on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1693</fr:anchor><fr:addr
type="machine">#335</fr:addr><fr:route>unstable-335.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Take <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> to be the class of sets such that <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L} \implies  P_1(A) = P_2(A)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system, from <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, it is sufficient to show that <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. Since <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {P}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {L}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L}]]></fr:tex>, then
<fr:tex
display="block"><![CDATA[P_1(A^c) = 1 - P_1(A) = 1 - P_2(A) = P_2(A^c).]]></fr:tex>
Therefore, <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {L}]]></fr:tex>. Finally, if <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> disjoint then
<fr:tex
display="block"><![CDATA[   P_1\left (\bigcup _{n = 1} A_n\right ) = \sum _{n = 1} P_1(A_n) = \sum _{n = 1}P_2 (A_n) = P_2\left (\bigcup _{n = 1}A_n\right ) ]]></fr:tex>
Thus, <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. From <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P}) \subset  \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_2]]></fr:tex> agree on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>An (important?) note is that this works due to our definition of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link>. Namely, countable additivity is really a condition on countable disjoint unions, meaning that the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> induced by a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> does not make full use of the generality allowed under arbitrary countable unions because it must satisfy countable additivity.</fr:p>

<fr:p>For completeness and future use, we introduce here the notion of monotone classes and Halmo's useful <fr:link
type="local"
href="kak-001E.xml"
addr="kak-001E"
title="Halmo's Monotone Class Theorem">theorem</fr:link>.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1694</fr:anchor><fr:addr
type="user">kak-001D</fr:addr><fr:route>kak-001D.xml</fr:route><fr:title
text="Monotone Class">Monotone Class</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {M}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is monotone if it is closed under the formation of monotone unions and intersections:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\uparrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>;</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ \ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1695</fr:anchor><fr:addr
type="user">kak-001E</fr:addr><fr:route>kak-001E.xml</fr:route><fr:title
text="Halmo's Monotone Class Theorem">Halmo's Monotone Class Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> is a field and <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> is a monotone class, then <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}\subset \mathscr {A}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_{0})\subset \mathscr {A}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Also for completeness, we introduce completeness lol.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1696</fr:anchor><fr:addr
type="user">kak-001F</fr:addr><fr:route>kak-001F.xml</fr:route><fr:title
text="Completeness of a measure">Completeness of a measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A probability measure <fr:tex
display="inline"><![CDATA[(\Omega , \mathcal {F}, P)]]></fr:tex> is <fr:em>complete</fr:em> if for <fr:tex
display="inline"><![CDATA[A \subset  B]]></fr:tex> if <fr:tex
display="inline"><![CDATA[P(B) = 0]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P(A) = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>You might be wondering when this is not the case because we have subadditivity. However, it is not the case that <fr:tex
display="inline"><![CDATA[P(A) > 0]]></fr:tex> but instead that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is not measurable. As an example,</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1697</fr:anchor><fr:addr
type="user">kak-001G</fr:addr><fr:route>kak-001G.xml</fr:route><fr:title
text="Vitali Sets">Vitali Sets</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If we consider <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>, then we can partition <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> into equivalent classes as <fr:tex
display="inline"><![CDATA[x \sim  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x - y = r]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[r \in  \mathbb {Q} \cap  [0, 1]]]></fr:tex>. Denote each of these as <fr:tex
display="inline"><![CDATA[V_{r}]]></fr:tex>. By the <fr:link
type="local"
href="kak-001H.xml"
addr="kak-001H"
title="Axiom of Choice">Axiom of Choice</fr:link>, we can choose one representative from each <fr:tex
display="inline"><![CDATA[V_r]]></fr:tex>. We call the set of these representatives <fr:tex
display="inline"><![CDATA[V]]></fr:tex>. Therefore, we can write <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> as a countable union via <fr:tex
display="inline"><![CDATA[[0,1] = \bigcup _{r \in  \mathbb {Q}} V + r]]></fr:tex>. For the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>, each <fr:tex
display="inline"><![CDATA[\lambda (V + r) = \lambda (V)]]></fr:tex>. Since each <fr:tex
display="inline"><![CDATA[V + r]]></fr:tex> is disjoint, we have 
<fr:tex
display="block"><![CDATA[\lambda \left (\bigcup _{r \in  \mathbb {Q}} V + r\right ) = \sum _{r \in  \mathbb {Q}} \lambda (V)]]></fr:tex>
If <fr:tex
display="inline"><![CDATA[\lambda (V) = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\lambda ([0,1]) \leq  \lambda (V) = 0]]></fr:tex> which is a contradiction. Otherwise <fr:tex
display="inline"><![CDATA[\lambda  ([0,1]) = \sum _{r \in  \mathbb {Q}} k = \infty ]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[k \in  \mathbb {R}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[V]]></fr:tex> is not Lebesgue measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1698</fr:anchor><fr:addr
type="machine">#390</fr:addr><fr:route>unstable-390.xml</fr:route><fr:title
text=" [billingsley1986, 3.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.2"
refid="billingsley1986"><fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">[billingsley1986, 3.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> and for every subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> define <fr:tex
display="inline"><![CDATA[P^{\star }(A)]]></fr:tex> by <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">(3.1)</fr:link>. Denote also by <fr:tex
display="inline"><![CDATA[P]]></fr:tex> the extension of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathscr {F}=\sigma (\mathscr {F}_{0})]]></fr:tex>.
  <fr:ol><fr:li>Show that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> if and only if <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>.</fr:li></fr:ol>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1700</fr:anchor><fr:addr
type="machine">#391</fr:addr><fr:route>unstable-391.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>First suppose that <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>. We must show that 
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) = P^*(E)]]></fr:tex>
  From part (1) and our hypothesis, <fr:tex
display="inline"><![CDATA[\exists  \overline {A}, \underline {A} \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\underline {A} \subset  A \subset  \overline {A}]]></fr:tex> and <fr:tex
display="block"><![CDATA[P(\overline {A}) = P^*(A) = P_*(A) = P(\underline {A})]]></fr:tex>. Additionally, <fr:tex
display="inline"><![CDATA[\exists  B \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[E \subset  B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*(E) = P(B)]]></fr:tex>. Then we have that
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) \leq  P^*(B \cap  \overline {A}) = P(B \cap  \overline {A})]]></fr:tex>
  and
<fr:tex
display="block"><![CDATA[P^*(B \cap  A) \leq  P^*(B \cap  \underline {A}^c) = P(B \cap  \underline {A}^c)]]></fr:tex>
  Thus,
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) \leq  P(B \cap  \underline {A}^c) + P(B \cap  \overline {A}) = P^*(E)]]></fr:tex>
  as desired.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1702</fr:anchor><fr:addr
type="machine">#392</fr:addr><fr:route>unstable-392.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>I really struggled for a minute on even understanding this problem. The import thing to understand for this problem is what space everything is defined on.
<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> is defined on the initial field <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>, which is the closure over finite unions and complements of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on the powerset <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex>. <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily a measure on all of these subsets though.
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[E]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> hence the need for <fr:tex
display="inline"><![CDATA[B]]></fr:tex>.</fr:li></fr:ul></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> (abuse of notation) is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> restricted to the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li></fr:ol>
  Common question is why we cannot just apply finite additivity and have everything <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link>? The answer is that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is not countably subadditive on <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex> but only the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> sets.
</fr:mainmatter><fr:backmatter /></fr:tree>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1704</fr:anchor><fr:addr
type="machine">#399</fr:addr><fr:route>unstable-399.xml</fr:route><fr:title
text="Denumerable Probabilities">Denumerable Probabilities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
The results of this section concern infinite sequences of events in a probability space. They will be illustrated by examples in the unit interval. By this will always be meant the triple (<fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P]]></fr:tex>) for which <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is (0,1), <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field <fr:tex
display="inline"><![CDATA[\mathscr {B}]]></fr:tex> of Borel sets there, and <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is for <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda (A)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. 
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1706</fr:anchor><fr:addr
type="user">kak-001J</fr:addr><fr:route>kak-001J.xml</fr:route><fr:title
text="Conditional Probability">Conditional Probability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A | B) = \frac {P(A \cap  B)}{P(B)}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1707</fr:anchor><fr:addr
type="user">kak-001I</fr:addr><fr:route>kak-001I.xml</fr:route><fr:title
text="Chain Rule of Probability">Chain Rule of Probability</fr:title><fr:taxon>Proposition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A \cap  B \cap  C) = P(A)P(B | A)P(C | B \cap  A)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1708</fr:anchor><fr:addr
type="user">kak-001M</fr:addr><fr:route>kak-001M.xml</fr:route><fr:title
text="Limsup of sets">Limsup of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \sup _{n} A_n = \bigcap _{n = 1}^{\infty } \bigcup _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \sup _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> infinitely often.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1709</fr:anchor><fr:addr
type="user">kak-001N</fr:addr><fr:route>kak-001N.xml</fr:route><fr:title
text="Liminf of sets">Liminf of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \inf _{n} A_n = \bigcup _{n = 1}^{\infty } \bigcap _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in all but finitely many <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1710</fr:anchor><fr:addr
type="user">kak-001K</fr:addr><fr:route>kak-001K.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each sequence <fr:tex
display="inline"><![CDATA[\{A_{n}\}]]></fr:tex>,

<fr:tex
display="block"><![CDATA[P\left (\lim \inf _{n}A_{n}\right )\leq \lim _{n}\inf _{n}P\left (\,A_{n}\right ) \leq \lim _{n}\sup _{n}P\left (\,A_{n}\right )\leq  P\left (\lim _{n}\sup _{n}A_{n}\right ).]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1711</fr:anchor><fr:addr
type="machine">#334</fr:addr><fr:route>unstable-334.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We define <fr:tex
display="inline"><![CDATA[B_n \coloneqq  \bigcup _{k = n}^{\infty } A_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> as <fr:tex
display="inline"><![CDATA[C_n = \bigcap _{k = n}^{\infty } A_k]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[\{B_n\}]]></fr:tex> is a monotonically decreasing sequence to <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> monotonically increases to <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_n]]></fr:tex>. Therefore, we can apply continuity from below / above such that
<fr:tex
display="block"><![CDATA[     \begin {align*}     \inf _n P(A_n) \geq  P(C_n) \iff  \lim _n \inf _n P(A_n) &\geq  \lim _n P(C_n) \\      &= P(\lim _n C_n) \\      &= P(\lim \inf _n A_n)     \end {align*} ]]></fr:tex>
      Similarly,
<fr:tex
display="block"><![CDATA[       \begin {align*}       \sup _n P(A_n) \leq  P(B_n) \iff  \lim _n \sup _n P(A_n) &\leq  \lim _n P(B_n) \\        &= P(\lim _n B_n) \\        &= P(\lim \sup _n A_n)       \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1712</fr:anchor><fr:addr
type="user">kak-001O</fr:addr><fr:route>kak-001O.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Independence evolves in the following manner:
  <fr:ol><fr:li>Events <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> are independent if <fr:tex
display="inline"><![CDATA[P(A \cap  B) = P(A)P(B)]]></fr:tex>.</fr:li>
    <fr:li>A finite collection of events are independent if
    <fr:tex
display="block"><![CDATA[P(A_{k_1} \cap  \cdots  \cap  A_{k_j}) = P(A_{k_1}) \cdots  P(A_{k_j})]]></fr:tex></fr:li>
    <fr:li>A infinite collection of sets is defined to be independent if every finite subcollection is independent.</fr:li>
    <fr:li>Classes <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent if for any events <fr:tex
display="inline"><![CDATA[A_1 \in  \mathscr {A}_1, \ldots , A_n \in  \mathscr {A}_n]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_1, \ldots , A_n]]></fr:tex> are independent.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1713</fr:anchor><fr:addr
type="user">kak-001P</fr:addr><fr:route>kak-001P.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent and each <fr:tex
display="inline"><![CDATA[\mathscr {A}_i]]></fr:tex> is a <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> then <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1), \ldots , \sigma (\mathscr {A}_n)]]></fr:tex> are independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1714</fr:anchor><fr:addr
type="machine">#333</fr:addr><fr:route>unstable-333.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
We have sequence of independent classes and want to show that their respective <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras are also independent. The idea is to take the class of events <fr:tex
display="inline"><![CDATA[B_1]]></fr:tex> that are independent with <fr:tex
display="inline"><![CDATA[\mathscr {A}_2, \ldots , \mathscr {A}_n]]></fr:tex>, and show that <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1)]]></fr:tex> is a subset of this class. To do this, we use <fr:link
type="local"
href="kak-001B.xml"
addr="kak-001B"
title="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:link> by noticing that this class is a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> that contains the <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {A}_1]]></fr:tex>.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Meaning in english:</fr:strong> In the book, they give the example of even and odd numbered coin tosses. We want to know when a new event only depends on even or odd coin tosses. Concretely, we know that even and odd coin tosses are independent, and we want to know if, for example, the outcome of every fourth coin toss is independent of odd tosses. We can do this rigorously by showing that this event is in the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra of even coin tosses. Then by <fr:link
type="local"
href="kak-001P.xml"
addr="kak-001P">Theorem 5.7</fr:link>, we know that this event is also independent of odd coin tosses.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1715</fr:anchor><fr:addr
type="user">kak-001R</fr:addr><fr:route>kak-001R.xml</fr:route><fr:title
text="Array Method">Array Method</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that the array
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} A_{11} & A_{12} & \cdots  \\ A_{21} & A_{22} & \cdots  \\ \vdots  & \vdots  &  \end {array} ]]></fr:tex>
of events is independent. If <fr:tex
display="inline"><![CDATA[\mathscr {F}_1]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra generated
by the first row then <fr:tex
display="inline"><![CDATA[\mathscr {F}_1, \mathscr {F}_2, \ldots ]]></fr:tex> are
independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1716</fr:anchor><fr:addr
type="machine">#331</fr:addr><fr:route>unstable-331.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>Can write events of flip <fr:tex
display="inline"><![CDATA[i]]></fr:tex> as <fr:tex
display="inline"><![CDATA[H_i]]></fr:tex> such that the following array
satisfies the above
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} H_{2} & H_{4} & \cdots  \\ H_{1} & H_3 & \cdots  \\ \end {array} ]]></fr:tex>
Then row 1 and row 2 are independent from above. Therefore, we have shown that
even and odd numbered flips' <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>'s are independent.
</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1717</fr:anchor><fr:addr
type="machine">#395</fr:addr><fr:route>unstable-395.xml</fr:route><fr:title
text="Subfields">Subfields</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1719</fr:anchor><fr:addr
type="machine">#394</fr:addr><fr:route>unstable-394.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Intuition of subfields are spaces with partial information. My best
memory of this coming up in probability was conditional expectation.
Esssentially, we need to consider the subfield of events conditioned on some
event that already occured.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1721</fr:anchor><fr:addr
type="user">kak-001S</fr:addr><fr:route>kak-001S.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say that points <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\omega ']]></fr:tex> are <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> equivalent if for
every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {A}]]></fr:tex>,
<fr:tex
display="block"><![CDATA[I_A(\omega ) = I_A(\omega ')]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>From this definition, we can conclude an observer with the information of
<fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A})]]></fr:tex> has only the information of the equivalence class but
cannot identify a specific point from this class.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1722</fr:anchor><fr:addr
type="machine">#396</fr:addr><fr:route>unstable-396.xml</fr:route><fr:title
text="The Borel-Cantelli Lemmas">The Borel-Cantelli Lemmas</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1724</fr:anchor><fr:addr
type="user">kak-001Q</fr:addr><fr:route>kak-001Q.xml</fr:route><fr:title
text="Borel-Cantelli One">Borel-Cantelli One</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> converges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 0]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1725</fr:anchor><fr:addr
type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n \subset  \bigcup _{k = n}^{\infty } A_k]]></fr:tex>.
    Therefore,
      <fr:tex
display="block"><![CDATA[P(\lim \sup _n A_n) \leq  P\left (\bigcup _{k = n}^{\infty } A_k\right ) \leq        \sum _{k = n}^{\infty } P(A_k)]]></fr:tex>
      Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1726</fr:anchor><fr:addr
type="user">kak-001T</fr:addr><fr:route>kak-001T.xml</fr:route><fr:title
text="Borel-Cantelli Two">Borel-Cantelli Two</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex> is an independent sequence of events and <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> diverges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 1]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1727</fr:anchor><fr:addr
type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Consider the complement. By independence, we have
<fr:tex
display="block"><![CDATA[P(\bigcap _{k = n}^{n + m} A_k^c) = \prod _{k = n}^{n + m}(1 - P(A_k)) \leq      \exp (-\sum _{k = n}^{n + m} P(A_k)),]]></fr:tex>
    where the last inequality comes from <fr:tex
display="inline"><![CDATA[1 - x \leq  e^{-x}]]></fr:tex>. Since the series diverges, taking <fr:tex
display="inline"><![CDATA[m \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:addr
type="machine">#398</fr:addr><fr:route>unstable-398.xml</fr:route><fr:title
text="Zero-one Law">Zero-one Law</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:addr
type="user">kak-001U</fr:addr><fr:route>kak-001U.xml</fr:route><fr:title
text="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of events in a probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> consider the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-fields <fr:tex
display="inline"><![CDATA[\sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
then their intersection
<fr:tex
display="block"><![CDATA[\mathscr {T} = \bigcap _{n = 1}^{\infty } \sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
is the <fr:em>tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:em> associated with the sequence <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1731</fr:anchor><fr:addr
type="machine">#397</fr:addr><fr:route>unstable-397.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>The <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim \inf _n A_n]]></fr:tex> are both tail events.</fr:mainmatter><fr:backmatter /></fr:tree>
 

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1733</fr:anchor><fr:addr
type="user">kak-001V</fr:addr><fr:route>kak-001V.xml</fr:route><fr:title
text="Kolmogorov's Zero-one Law">Kolmogorov's Zero-one Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> is an independent sequence of events, then for each
event <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in the <fr:link
type="local"
href="kak-001U.xml"
addr="kak-001U"
title="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is either <fr:tex
display="inline"><![CDATA[0]]></fr:tex> or <fr:tex
display="inline"><![CDATA[1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1734</fr:anchor><fr:addr
type="machine">#410</fr:addr><fr:route>unstable-410.xml</fr:route><fr:title
text="Random Variables">Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:addr
type="user">kak-001W</fr:addr><fr:route>kak-001W.xml</fr:route><fr:title
text="Simple Random Variable">Simple Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> be an arbitrary probability space, and let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a real-valued function on <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a simple random variable if it has finite range and if 
<fr:tex
display="block"><![CDATA[\left [\omega  \mid  X(\omega ) = x \right ] \in  \mathscr {F}]]></fr:tex>
for each <fr:tex
display="inline"><![CDATA[x]]></fr:tex> in its finite range.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1737</fr:anchor><fr:addr
type="machine">#400</fr:addr><fr:route>unstable-400.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider the function 
    <fr:tex
display="block"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex>
    If <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> are finite partition of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> into <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-sets, then inverse image is at most countable union of the A_i's, which is an <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set. Therefore, this function is measurable.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1739</fr:anchor><fr:addr
type="user">kak-0022</fr:addr><fr:route>kak-0022.xml</fr:route><fr:title
text="Finite Sequence Measurability">Finite Sequence Measurability</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, \ldots , X_n]]></fr:tex> be <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s
<fr:ol><fr:li>The <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> consists of the sets
<fr:tex
display="block"><![CDATA[\left [(X_1, \ldots , X_n) \in  H\right ] = \left [\omega  \mid  (X_1(\omega ), \ldots , X_n(\omega )) \in  H\right ]]]></fr:tex>
    for <fr:tex
display="inline"><![CDATA[H \subset  \mathbb {R}^n]]></fr:tex>.</fr:li>
    <fr:li>A simple random variable <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is measurable <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> if and only if 
<fr:tex
display="block"><![CDATA[Y = f(X_1, \ldots , X_n)]]></fr:tex>
    for some <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1740</fr:anchor><fr:addr
type="user">kak-001X</fr:addr><fr:route>kak-001X.xml</fr:route><fr:title
text="-Field of RV"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field of RV</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field generated by a <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is the smallest <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field such that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">measurable</fr:link>. For a sequence of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s, the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> generated by them is the smallest <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, such that each of the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s is measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1741</fr:anchor><fr:addr
type="machine">#404</fr:addr><fr:route>unstable-404.xml</fr:route><fr:title
text="Convergence of Random Variables">Convergence of Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
In probability, rather than standard convergence, we actually can consider convergence with high probability or almost surely (should come up later). Formally, we care about measuring the probability of the event <fr:tex
display="inline"><![CDATA[\{\omega  \mid  \lim _n X_n(\omega ) \to  X(\omega )\}]]></fr:tex>. The first question we must ask is whether this set is measurable. They do not really cover this in the textbook, but it is an important trick that comes up a lot.

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1743</fr:anchor><fr:addr
type="machine">#401</fr:addr><fr:route>unstable-401.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
We consider the complement. Note that the sequence of random variables not converging can be written as <fr:tex
display="inline"><![CDATA[\forall  \epsilon , \exists  n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[|X_n(\omega ) - X(\omega )| \geq  \epsilon ]]></fr:tex>. For a fixed <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>, this is the <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of the sequence <fr:tex
display="inline"><![CDATA[A_n \coloneqq  [|X_n - X| \geq  \epsilon ]]]></fr:tex>. We know that <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of measurable sequence is measurable because it is a countable intersection of countable unions. Therefore, the last thing we need is to show for all <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>. This can be done just using rationals because <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is <fr:link
type="local"
href="kak-001Y.xml"
addr="kak-001Y"
title="Dense Subset">dense</fr:link> in <fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex>. Then we have a countable union of countable sets as desired.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1745</fr:anchor><fr:addr
type="user">kak-001Z</fr:addr><fr:route>kak-001Z.xml</fr:route><fr:title
text="Almost Sure Convergence">Almost Sure Convergence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>almost surely</fr:em> if 
<fr:tex
display="block"><![CDATA[P(X_n \to  X) = 1]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1746</fr:anchor><fr:addr
type="user">kak-0020</fr:addr><fr:route>kak-0020.xml</fr:route><fr:title
text="Convergence in Probability">Convergence in Probability</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>in probability</fr:em> if for every <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>
<fr:tex
display="block"><![CDATA[\lim _{n \to  \infty } P(|X_n - X| > \epsilon ) = 0]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1747</fr:anchor><fr:addr
type="machine">#402</fr:addr><fr:route>unstable-402.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        By <fr:link
type="local"
href="kak-001K.xml"
addr="kak-001K">Theorem 5.5</fr:link>, almost sure convergence <fr:tex
display="inline"><![CDATA[\implies ]]></fr:tex> convergence in probability. Converse is NOT true.
      </fr:mainmatter><fr:backmatter /></fr:tree>

      
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1749</fr:anchor><fr:addr
type="machine">#403</fr:addr><fr:route>unstable-403.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Can make array of rows, where the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>th row consists of <fr:tex
display="inline"><![CDATA[n]]></fr:tex> intervals that evenly divide <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P(A_n) \to  0]]></fr:tex> but <fr:tex
display="inline"><![CDATA[[A_n \text { i.o}] = [0,1]]]></fr:tex> </fr:mainmatter><fr:backmatter /></fr:tree>
 

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1751</fr:anchor><fr:addr
type="machine">#405</fr:addr><fr:route>unstable-405.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1753</fr:anchor><fr:addr
type="user">kak-0021</fr:addr><fr:route>kak-0021.xml</fr:route><fr:title
text="Independence of Random Variable">Independence of Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A sequence of random variables <fr:tex
display="inline"><![CDATA[X_1, X_2, \ldots ]]></fr:tex> is <fr:em>independent</fr:em> if the classes <fr:tex
display="inline"><![CDATA[\sigma (X_1), \sigma (X_2), \ldots ]]></fr:tex> are <fr:link
type="local"
href="kak-001O.xml"
addr="kak-001O"
title="Independence">independent</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1754</fr:anchor><fr:addr
type="machine">#407</fr:addr><fr:route>unstable-407.xml</fr:route><fr:title
text="Existence of Independent Sequences">Existence of Independent Sequences</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1756</fr:anchor><fr:addr
type="user">kak-0023</fr:addr><fr:route>kak-0023.xml</fr:route><fr:title
text="Distribution">Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>distribution</fr:em> of a simple random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the probability measure <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> defined for all subsets <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of the line by 
<fr:tex
display="block"><![CDATA[\mu (A) = P[X \in  A]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1757</fr:anchor><fr:addr
type="user">kak-0024</fr:addr><fr:route>kak-0024.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{\mu _n\}]]></fr:tex> be a sequence of probability measures on the class of all subsets of the line, each having finite support. There exists some probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> an independent sequence <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s such that <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> has distribution <fr:tex
display="inline"><![CDATA[\mu _n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Guess for english translation</fr:strong>: I think what this is saying is that rather than try to define a probability space for a random variable, we can instead just pick probability measures and know that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> come for free? i.e. (from the book) we can just define a trivial space <fr:tex
display="inline"><![CDATA[\Omega  = \{1, 0\}]]></fr:tex> and probability measure <fr:tex
display="inline"><![CDATA[P(1) = p]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(0) = 1 - p]]></fr:tex> and know that we can get a Bernoulli random variable? In this case <fr:tex
display="inline"><![CDATA[X(1) = 1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X(0) = 0]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P(X = 1) = p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P(X = 0) = 1 - p]]></fr:tex>?</fr:p>

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1758</fr:anchor><fr:addr
type="machine">#406</fr:addr><fr:route>unstable-406.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>In the text, they say that the underlying probability space does not really matter. Basically, all calculations are determined by the distribution in range space. So I guess that is also what this theorem is getting at? </fr:mainmatter><fr:backmatter /></fr:tree>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  


  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1760</fr:anchor><fr:addr
type="machine">#408</fr:addr><fr:route>unstable-408.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1762</fr:anchor><fr:addr
type="user">kak-0029</fr:addr><fr:route>kak-0029.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> of the form <fr:tex
display="inline"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex> is assigned expected value as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \mathbb {E}\left [\sum _i x_i I_{A_i} \right ] = \sum _i x_i P(A_i)]]></fr:tex>
More generally, if <fr:tex
display="inline"><![CDATA[f(X) = \sum _i f(x_i) I_{A_i}]]></fr:tex> then
<fr:tex
display="block"><![CDATA[\mathbb {E}\left [f(X)\right ] = \sum _i f(x_i) P(A_i) = \sum _x f(x) P[X = x]]]></fr:tex>
A useful identity is as follows:
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \int _0^{\infty } P[X \geq  x] \mathrm {d}x]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1763</fr:anchor><fr:addr
type="user">kak-002A</fr:addr><fr:route>kak-002A.xml</fr:route><fr:title
text="Kth Moment"><fr:tex
display="inline"><![CDATA[k]]></fr:tex>th Moment</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We define the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th moment of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X^k] = \sum _y y P[X^k = y]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1764</fr:anchor><fr:addr
type="user">kak-002B</fr:addr><fr:route>kak-002B.xml</fr:route><fr:title
text="Uniformly Bounded">Uniformly Bounded</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\exists  K]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X_n(\omega ) \leq  K]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> then the <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> are <fr:em>uniformly bounded</fr:em>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1765</fr:anchor><fr:addr
type="user">kak-002C</fr:addr><fr:route>kak-002C.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> is uniformly bounded, and if <fr:tex
display="inline"><![CDATA[X = \lim _n X_n]]></fr:tex> with probability <fr:tex
display="inline"><![CDATA[1]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbb {E}[X] = \lim _n \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1766</fr:anchor><fr:addr
type="machine">#409</fr:addr><fr:route>unstable-409.xml</fr:route><fr:title
text="Inequalities">Inequalities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1768</fr:anchor><fr:addr
type="user">kak-002E</fr:addr><fr:route>kak-002E.xml</fr:route><fr:title
text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[X \geq  \alpha ] \leq  \frac {1}{\alpha } \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1769</fr:anchor><fr:addr
type="user">kak-002F</fr:addr><fr:route>kak-002F.xml</fr:route><fr:title
text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[|X - m| \geq  \alpha ] \leq  \frac {1}{\alpha ^2} \mathrm {Var}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1770</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1771</fr:anchor><fr:addr
type="user">kak-002H</fr:addr><fr:route>kak-002H.xml</fr:route><fr:title
text="Holder's Inequality">Holder's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:tex
display="block"><![CDATA[\frac {1}{p} + \frac {1}{q} = 1, \quad  p > 1,\ q > 1]]></fr:tex>
Then <fr:em>Holder's inequality</fr:em> is
<fr:tex
display="block"><![CDATA[\mathbb {E}[XY] \leq  \left (\mathbb {E}[|X|^p]\right )^{1/p} \cdot  \left (\mathbb {E}[|Y|^q]\right )^{1/q}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  
 
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1772</fr:anchor><fr:addr
type="machine">#411</fr:addr><fr:route>unstable-411.xml</fr:route><fr:title
text="The Law of Large Numbers">The Law of Large Numbers</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3601</fr:anchor><fr:addr
type="user">kak-0002</fr:addr><fr:route>kak-0002.xml</fr:route><fr:title
text="Blog">Blog</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is my blog, in which I write about a variety of topics including computer science, mathematics, and more.</fr:p>


<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>436</fr:anchor><fr:addr
type="user">kak-0005</fr:addr><fr:route>kak-0005.xml</fr:route><fr:title
text="Contrastive Reinforcement Learning">Contrastive Reinforcement Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog post, we aim to demistify <fr:link
type="external"
href="gcrl"><fr:em>Contrastive Reinforcement Learning</fr:em></fr:link>. This term often gets thrown around in the dark inner circles of the reinforcement learning community. However, for those that are not familiar with contrastive learning, what does contrastive even mean? For those that are, how can reinforcement learning be contrastive? Throughout this blog post, we will answer these questions and many more.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>438</fr:anchor><fr:addr
type="user">kak-0009</fr:addr><fr:route>kak-0009.xml</fr:route><fr:title
text="Contrastive Learning">Contrastive Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Prior to understanding contrastive reinforcement learning, it is important to have an at least rudimentary understanding of contrastive learning. Historically, contrastive learning has been used to learn representations. The fundamental idea behind contrastive learning is to encourage the representations of similar outputs to be similar in representation space.</fr:p><fr:p><fr:strong>Supervised setting:</fr:strong> For now, assume we are in the supervised setting (we have access to lables). Suppose that we are learning a representation in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Our model is a classifier on dogs and cats. If we have two dogs <fr:tex
display="inline"><![CDATA[y_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y_2]]></fr:tex> then we want the learned representation map <fr:tex
display="block"><![CDATA[\phi : \{\text {dogs}, \text {cats}\} \to  \mathbb {R}^d]]></fr:tex> to be such that <fr:tex
display="inline"><![CDATA[\phi (y_1)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\phi (y_2)]]></fr:tex> are "close" in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Now the notion of "close" is to be determined by the user. An example could be to minimize the inner product between their representation maps i.e. we could learn a feature map parametrized by <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex> with the following objective <fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle .]]></fr:tex> Similarly, we want dissimilar outputs to be far apart in representation space. If <fr:tex
display="inline"><![CDATA[y_3]]></fr:tex> is a cat, then we can introduce a regularization to encourage this i.e.
<fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle  - \sum _{i \in  \{1, 2\}} \langle  \phi _{\theta }(y_i), \phi _{\theta }(y_3) \rangle .]]></fr:tex></fr:p><fr:p><fr:strong>Unsupervised setting:</fr:strong> Now suppose that we get rid of labels and are just given <fr:tex
display="inline"><![CDATA[n]]></fr:tex> dog samples <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> from some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {D}}]]></fr:tex>. We now want to be able to learn <fr:tex
display="inline"><![CDATA[p_{\theta }]]></fr:tex> to somehow estimate this distribution. An approach is to learn to distinguish the sample dogs given from random noise. To do so, we generate <fr:tex
display="inline"><![CDATA[n]]></fr:tex> random images <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> according to some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {R}}]]></fr:tex>. We can now return to the supervised learning setting, where we treat <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> as two classes. If we recall standard supervised learning practice, given a sample <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we then want to find <fr:tex
display="block"><![CDATA[p(\mathcal {D} \mid  x) = 1 - p(\mathcal {R} \mid  X).]]></fr:tex> 
As an explicit example, we will use logistic regression. Namely, we will model <fr:tex
display="inline"><![CDATA[p(x) = p(\mathcal {D} \mid  x)]]></fr:tex> as <fr:tex
display="block"><![CDATA[p_{\theta }(x) = \frac {1}{1 + e^{-G_{\theta }(x)}}.]]></fr:tex> However, <fr:tex
display="inline"><![CDATA[p_{\theta }(x)]]></fr:tex> is estimating <fr:tex
display="inline"><![CDATA[p(\mathcal {D} \mid  x)]]></fr:tex>, where we care about <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex>. To estimate the correct quantity, we need to leverage our knowledge of the noise distribution. Recall that if <fr:tex
display="inline"><![CDATA[p_{\theta }(x) = p(\mathcal {D} \mid  x)]]></fr:tex> then <fr:tex
display="inline"><![CDATA[G_{\theta }(x) = \log  \frac {p(x \mid  \mathcal {D})}{p(x \mid  \mathcal {R})}]]></fr:tex>. Since we generated the samples from <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex>, we have the explicit distribution i.e. <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {R}) = p_{\mathcal {R}}(x)]]></fr:tex>. Therefore, we can restrict <fr:tex
display="inline"><![CDATA[G_{\theta }]]></fr:tex> to explicitly learn <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex> by considering <fr:tex
display="block"><![CDATA[G_{\theta }(x) = \log  p_{\theta }(x \mid  \mathcal {D}) - \log  p_{\mathcal {R}}(x),]]></fr:tex> considering the cross entropy loss we get the <fr:link
type="external"
href="nce">NCE loss</fr:link></fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">kak-000E</fr:addr><fr:route>kak-000E.xml</fr:route><fr:title
text="NCE loss">NCE loss</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="external"
href="nce">NCE</fr:link></fr:em> loss aims to minimize the following objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \sum _{t} \log  \left [h(x_t; \theta )\right ] + \log \left [1 - h(y_t; \theta )\right ],]]></fr:tex> where <fr:tex
display="inline"><![CDATA[x_t]]></fr:tex> are samples from the data distribution and <fr:tex
display="inline"><![CDATA[y_t]]></fr:tex> are randomly generated samples and <fr:tex
display="block"><![CDATA[\begin {array}{r c l}{{h({\bf  u};\theta )}}&{{=}}&{{\frac {1}{1+\exp \left [-G({\bf  u};\theta )\right ]},}}\\ {{G({\bf  u};\theta )}}&{{=}}&{{\ln  p_{m}({\bf  u};\theta )-\ln  p_{n}({\bf  u}).}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In <fr:link
type="local"
href="gutmann2012.xml"
addr="gutmann2012"
title="Noise-contrastive Estimation">Noise-contrastive Estimation</fr:link>, they show under mild conditions that the estimator <fr:tex
display="inline"><![CDATA[p_{\theta }(x \mid  D) \to  p_{\mathcal {D}}(x)]]></fr:tex> in probability as the number of samples in the loss goes to infinity. Equivalently, the estimator is <fr:link
type="local"
href="kak-000F.xml"
addr="kak-000F"
title="Consistent estimator">consistent</fr:link>.</fr:p><fr:p><fr:strong>Time series:</fr:strong> Before we get to contrastive RL, it is a natural question to wonder how does this apply to temporal sequences? Concretely, we want to make predictions about the future given the current "context". However, we want to do so in an unsupervised way, meaning we are only given trajectories not a notion of what it means for a trajectory to be good. Naively, one can try to do this in a supervised manner. For a <fr:tex
display="inline"><![CDATA[k]]></fr:tex> step prediction, this would just be your model predicting what will happen in <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps then seeing if it matches what occured <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps in the future in the sample trajectory. However, if your sample space <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is very high-dimensional, modeling this relationship can require an exorbinant amount of trajectories.</fr:p><fr:p>Fast forwarding to contrastive RL, current work is primarily considered with a particular contrastive objective.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>440</fr:anchor><fr:addr
type="user">kak-000B</fr:addr><fr:route>kak-000B.xml</fr:route><fr:title
text="InfoNCE">InfoNCE</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">InfoNCE</fr:link></fr:em> loss aims to minimize the following information-theoretic objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \mathbb {E}_{\mathcal {X}} \left [\log  \frac {f_k(x_{t + k}, c_t)}{\sum _{x_j \in  \mathcal {X}} f_k(x_j, c_t)}\right ]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Now we need to unpack this very ominous loss. To start, what are <fr:tex
display="inline"><![CDATA[x_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>?</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">kak-000C</fr:addr><fr:route>kak-000C.xml</fr:route><fr:title
text="Maximize Mutual info">Maximize Mutual info</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\mathcal {L}_N]]></fr:tex> from <fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">Contrastive Predictive Decoding</fr:link> maximizes a lower bound on the <fr:link
type="local"
href="kak-000V.xml"
addr="kak-000V"
title="Mutual Information">Mutual Information</fr:link> between <fr:tex
display="inline"><![CDATA[x_{t + k}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>442</fr:anchor><fr:addr
type="machine">#377</fr:addr><fr:route>unstable-377.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>All we must do is plug <fr:tex
display="inline"><![CDATA[\frac {p(x \mid  c)}{p(x)}]]></fr:tex> back into the objective.
  <fr:tex
display="block"><![CDATA[\begin {align*}     \mathcal {L}_{\mathbb {N}}^{\text {opt}}&=-\,\mathbb {E}\log \left [\frac {\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}}{\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}+\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &\approx \mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}(N-1)\,\mathbb {E}\,\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k} \mid  c_t)}N\right ] \\     &\geq  \mathbb {E} \log  \left [\frac {p(x_{t + k})}{p(x_{t + k} \mid  c_t)}N \right ] \\     &= - I(x_{t + k}, c_t) + \log  N  \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree><fr:tex
display="block"><![CDATA[ \operatorname *{max}_{f(u,v)}\mathbb {E}_{(u,v^{+})\sim  p(u,v)}\left [\log \sigma (\underbrace {f(u,{\green  v^{+}})}_{\phi (u)^{T}\psi ({\green  v^{+}})})+\log (1-\sigma (\underbrace {f(u,{\red  v^{-}})}_{\phi (u)^{T}\psi ({\red  v^{-}})}))\right ] ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} &\operatorname *{max}_{f}\mathbb {E}_{(s,a)\sim  p(s,a),s_{f}^{-}\sim  p(s_{f})}\left [\mathcal {L}(s,a,s_{f}^{+},s_{f}^{-})\right ] \\ \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}_1(\theta ) = \log \sigma (f_{\theta }(s_1,a_1,{\color {green} s_{8}})) + \log (1-\sigma (f_{\theta }(s_1,a_1, {\color {red} s_3}))) ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} \widehat {\mathcal {L}}(\theta ) &= \frac {1}{n} \sum _{i = 1}^{n} \mathcal {L}_i \\ &= \frac {1}{n} \sum _{i = 1}^{n} \Big [\log \sigma (f_{\theta }(s_i,a_i,{\color {green} s_{f}^{+}})) + \log (1-\sigma (f_{\theta }(s_i,a_i, {\color {red} s_{f}^{-}})))\Big ] \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}(\theta ) = \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] ]]></fr:tex><fr:tex
display="block"><![CDATA[f^*(s, a, s_g) = \log \left (\frac {p^{\pi (\cdot  \mid  \cdot )}(s_g \mid  s, a)}{p(s_g)}\right )]]></fr:tex>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="machine">#378</fr:addr><fr:route>unstable-378.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We want to maximize
<fr:tex
display="block"><![CDATA[     \begin {align*} \mathcal {L}(\theta ) &= \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] \\ &= \int  \log \sigma (f_{\theta }(x)) P_X(x) + \int  \log (1-\sigma (f_{\theta }(y))) P_Y(y) \\ &= \int  \log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)     \end {align*}     ]]></fr:tex>
    Since we are maximizing <fr:tex
display="inline"><![CDATA[f(s)]]></fr:tex>, we can just maximize the integrand i.e.
<fr:tex
display="block"><![CDATA[       \begin {align*}         \frac {\mathrm {d}}{\mathrm {d}f(z)} \Big [\log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)\Big ] = 0       \end {align*}     ]]></fr:tex>
    Solving,
    <fr:tex
display="block"><![CDATA[         \begin {align*}           P_X(z)\big (1 - \sigma (f(z))\big ) - P_Y(z)\sigma (f(z)) = 0 &\iff  \sigma (f(z)) = \frac {P_X(z)}{P_X(z) + P_Y(z)} \\           &\iff  f(z) = \log \left (\frac {P_X(z)}{P_Y(z)}\right )         \end {align*}       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>444</fr:anchor><fr:addr
type="machine">#379</fr:addr><fr:route>unstable-379.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
The first step is to prove that the average Q-values are close to the task-conditioned Q-values. Below, we will use <fr:tex
display="inline"><![CDATA[R_{c}(\tau )\triangleq \sum _{\ell =0}^{\infty }\gamma ^{\ell }r_{\ell }(s_{\ell },a_{\ell })]]></fr:tex>:

<fr:tex
display="block"><![CDATA[ \begin {align*} \left |Q^{\beta (\cdot |\cdot ,a)}(s,a,e)-Q^{\beta (\cdot |\cdot ,\epsilon ^{\prime })}(s,a,e)\right |&=\left |\int \beta (\tau \mid  s,a,e)R_{e}(\tau )d\tau -\int \beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right |\\  &=\left |\int \beta (\tau \mid  s,a,e)-\beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right | \\ &=\left |\int \beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )R_{e}(\tau )d\tau \right | \\ &\leq \int \left |\beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )\right |d\tau \cdot \operatorname *{max}_{\tau }|R_{e}(\tau )d\tau | \\ &\leq \int \beta (\tau \mid  s,a,e)\left |1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right |d\tau \cdot  1 \\ &=\mathbb {E}_{\beta (\tau |s,a,e)}\left [\left |1-{\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}}\right |\right ] \\ &\leq  \epsilon . \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>445</fr:anchor><fr:addr
type="user">kak-005F</fr:addr><fr:route>kak-005F.xml</fr:route><fr:title
text="Rebuilding My (Neo)Vim Config From Scratch">Rebuilding My (Neo)Vim Config From Scratch</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>I have been using LazyVim for some time now, but I have now run into issues multiple times where understanding how LazyVim is doing something is far more difficult than if I had written my own setup. I allocated one day for this adventure and really just wanted to make sure I had support for <fr:tex
display="inline"><![CDATA[\TeX ]]></fr:tex>, python, forester, and C/C++. Due to my (self-imposed) time constraint, I do not have the associated resources linked for each of the things discussed below. At some point, I hope to come back and more thoroughly cover each of the components.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:title
text="Sane Defaults">Sane Defaults</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
To my surprise, a lot of the features that I had come to take for granted were actually options set up internally by Lazyvim. For example, I was shocked with 8 space indents!! and I could not even copy from one terminal instance to another... Due to this, I went and found all of the options I liked from Lazyvim and added them to my new configuration in <fr:code>configs/options.lua</fr:code>.
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>420</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:title
text="Installing a Plugin Manager">Installing a Plugin Manager</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
For this, we will be using the defacto standard <fr:code>lazy.nvim</fr:code>. This is actually straightforward and kind of "just works". Just follow the installation guide in their documentation.
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>421</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:title
text="Setting up Auto Complete">Setting up Auto Complete</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
This is one of the main motivations for me making the switch. It seems <fr:code>nvim-cmp</fr:code> has finally been replaced with a new <fr:code>blink.cmp</fr:code>, so that is what we will be using.


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:title
text="Language Server Protocol">Language Server Protocol</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
It turns out there is a lot that goes into getting LSP setup correctly.
<fr:ol><fr:li>First we must actually install the language servers. To do this the easiest way, we use the <fr:code>mason.nvim</fr:code> and <fr:code>mason.nvim-lspconfig</fr:code> plugins. At some point, I might actually figure out how to set up lsp myself without lspconfig but that point is not now.</fr:li>
<fr:li>Through <fr:code>nvim-lspconfig</fr:code>, we can set up each of the servers we want to have LSP support. I just set up clangd, pyright, and texlab.</fr:li></fr:ol>
This was a bit ridiculous. The first of many challenges was around import resolution in python. To remedy this, I needed to write a function to find the virtual environment directory and then set the <fr:code>pythonPath</fr:code> to the venv python binary. Previously, I think I was just using pylsp and installing it as a pip package to each python venv. I much prefer the new way, and I think pyright is overall a much better lsp.
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>423</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:title
text="Forester Completion">Forester Completion</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Another necessary completion source for me is the one provided by <fr:code>forester.nvim</fr:code>. Similar to vimtex, the reference completion support is VERY useful. Obviously, I need completion when I am writing this blog!!! This was a little more involved. The first difficulty was that the completion source provided by the <fr:code>forester.nvim</fr:code> plugin was for <fr:code>nvim-cmp</fr:code>. It turns out this is a prevalent enough problem that the author of <fr:code>blink.cmp</fr:code> wrote an additional plugin <fr:code>blink.compat</fr:code> to allow for <fr:code>nvim-cmp</fr:code> completion sources. While this sounds all fine and good, <fr:code>nvim-compat</fr:code> expects plugins that return the completion source themselves, whereas in <fr:code>forester.nvim</fr:code> the completion source is just one submodule of a more feature-rich plugin. To get around this, I needed to look into the <fr:code>blink.compat</fr:code> code and find how they are registering the sources and just do it myself.
</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:title
text="Snippets">Snippets</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Going all the way back to the <fr:link
type="external"
href="https://castel.dev/post/lecture-notes-1/">Gilles Castel blog post</fr:link>, I have always been partial to snippets that auto-expand. I had them set up prior to Lazyvim but with Lazyvim I had resigned to using friendly-snippets with native nvim snippets. Since I was already redoing everything, this time around I decided not to compromise. Once upon a time (right when it came out I think?) I tried out Luasnips, but it seems that they now have far more extensive features. They are also natively supported by <fr:code>blink.cmp</fr:code>!! It feels necessary that I plug the <fr:link
type="external"
href="https://github.com/iurimateus/luasnip-latex-snippets.nvim">awesome repo</fr:link> that ports the original Ultisnips snippets to Luasnip. With this, I was able to easily add my own forester snippets!!!</fr:p>
  <fr:p>A fun little thing that I had been hoping to do for awhile and is finally now possible - I can load latex snippets when inside math environments in forester!!!!</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>425</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:title
text="Treesitter">Treesitter</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:title
text="Formatters and Linters">Formatters and Linters</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:code>compat.nvim</fr:code>, <fr:code>mason.nvim</fr:code>, black, isort.
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:addr
type="user">loading</fr:addr><fr:route>loading.xml</fr:route><fr:title
text="Coming Soon!!!">Coming Soon!!!</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr
type="user">kak-005D</fr:addr><fr:route>kak-005D.xml</fr:route><fr:title
text="Optimization from a Deep Learning Perspective">Optimization from a Deep Learning Perspective</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr
type="user">kak-004X</fr:addr><fr:route>kak-004X.xml</fr:route><fr:title
text="A Note on Advantage Estimation">A Note on Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:title
text="What is it?">What is it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:title
text="Why do we do it?">Why do we do it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:title
text="Generalized Advantage Estimation">Generalized Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr
type="user">kak-003Y</fr:addr><fr:route>kak-003Y.xml</fr:route><fr:title
text="The History and Evolution of Policy Gradient Algorithms">The History and Evolution of Policy Gradient Algorithms</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Rough itinerary,
  <fr:ul><fr:li>Vanilla policy gradient
      <fr:ul><fr:li>Policy gradient theorem + proof</fr:li>
          <fr:li>Deterministic policy gradient theorem + (maybe)proof</fr:li></fr:ul></fr:li>
      <fr:li>Actor critic method
      <fr:ul><fr:li>A2C: Variance reduction method</fr:li>
        <fr:li>(Maybe) A3C: Asynchronous update</fr:li></fr:ul></fr:li>
      <fr:li>Trust region policy optimization</fr:li>
      <fr:li>Soft Actor Critic</fr:li>
      <fr:li><fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">Proximal Policy Optimization</fr:link></fr:li>
      <fr:li><fr:link
type="local"
href="kak-003X.xml"
addr="kak-003X"
title="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:link></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr
type="user">kak-003D</fr:addr><fr:route>kak-003D.xml</fr:route><fr:title
text="Deepseek v1 through R1: RL is back!">Deepseek v1 through R1: RL is back!</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog, we will aim to understand the key contributions of <fr:link
type="local"
href="deepseekai2025deepseekr1incentivizingreasoningcapability.xml"
addr="deepseekai2025deepseekr1incentivizingreasoningcapability"
title="DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning">DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning</fr:link>. It will serve as the complement to my group meeting presentation possibly consisting of more in-depth explanations. Time permitting, we might go over the engineering innovations introduced in <fr:link
type="local"
href="deepseekai2024deepseekv3technicalreport.xml"
addr="deepseekai2024deepseekv3technicalreport"
title="DeepSeek-V3 technical report">DeepSeek-V3 technical report</fr:link>.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:title
text="Background">Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    By request of my advisor, I will cover the basics of LLMs prior to the innovations in the Deepseek lineage. For those familiar with LLMs, please skip this section.
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">kak-004J</fr:addr><fr:route>kak-004J.xml</fr:route><fr:title
text="Word Embeddings">Word Embeddings</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tex
display="block"><![CDATA[\mathrm {Tok}(\mathbf {x})=\begin {bmatrix} 132\\ 17 \\ 87\\ 83\\ 184\end {bmatrix}]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>465</fr:anchor><fr:addr
type="user">kak-004G</fr:addr><fr:route>kak-004G.xml</fr:route><fr:title
text="Self-Attention">Self-Attention</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>TLDR: Learned weighting of token embeddings. Essentially, learning which words to "attend" to in the input sequence. Have matrices
<fr:tex
display="inline"><![CDATA[\mathbf {Q} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {q}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {q}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_q}]]></fr:tex>, 
<fr:tex
display="inline"><![CDATA[ \mathbf {K} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {k}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {k}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_k} ]]></fr:tex>
<fr:tex
display="inline"><![CDATA[ \mathbf {V} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_v} ]]></fr:tex></fr:p><fr:p><fr:strong>Intuition 1:</fr:strong> Convex re-weighting of input tokens.
  Note that
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_1 & p_2 & p_3   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} = p_1 \mathbf {v}^{(1)} + p_2 \mathbf {v}^{(2)} + p_3 \mathbf {v}^{(3)} \end {align*}   ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_{11} & 0 & 0 \\     p_{21} & p_{22} & 0 \\     p_{31} & p_{32} & p_{33}   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} =    \begin {bmatrix}   p_{11} \mathbf {v}^{(1)}  \\   p_{21} \mathbf {v}^{(1)} + p_{22} \mathbf {v}^{(2)} \\   p_{31} \mathbf {v}^{(1)} + p_{32} \mathbf {v}^{(2)} + p_{33} \mathbf {v}^{(3)}   \end {bmatrix} \end {align*}   ]]></fr:tex>
  <fr:strong>Intuition 2:</fr:strong> Context dependent re-weighting.
      If <fr:tex
display="inline"><![CDATA[\mathbf {p} = \mathbb {S}(\mathbf {Q} \mathbf {K}^T)]]></fr:tex> then
      <fr:tex
display="block"><![CDATA[         \begin {align*}           p_{ij} = \frac {\mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}{\sum _{j} \mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}         \end {align*}       ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Suppose that <fr:tex
display="inline"><![CDATA[\mathbf {x} = \text {I play with the ball}]]></fr:tex>. Then 
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``ball"})     \end {align*}   ]]></fr:tex>
  A feasible query for "ball" would be a verb describing the action of the ball, so maybe
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_q \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``play"})   \end {align*}   ]]></fr:tex>
  and a key for "play" would be what you are playing with like a ball, so 
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_k \mathbf {x}^{(2)} = \mathrm {Embed}(\text {``ball"})   \end {align*}   ]]></fr:tex>
  i.e.
<fr:tex
display="block"><![CDATA[   \begin {align*}     \mathrm {Query}(\text {``quantum"}) \cdot  \mathrm {Key}(\text {``mechanics"}) \approx      ||\mathrm {Query}(\text {``quantum"})|| \cdot  ||\mathrm {Key}(\text {``mechanics"})||   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
 
<fr:p><fr:tex
display="block"><![CDATA[   \begin {align*} \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} &= \mathbb {S}\left (\begin {bmatrix} \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(1)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(2)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(3)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(4)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(5)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(6)} \end {bmatrix} \right ) \\ &= \begin {bmatrix} 0 & 0.2 & 0.3 & 0.5 & 0 & 0 \end {bmatrix}   \end {align*} ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} \mathbf {V} = 0.2 \mathbf {v}^{(2)} + 0.3 \mathbf {v}^{(3)} + 0.5 \mathbf {v}^{(5)} ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:addr
type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:title
text="RLHF">RLHF</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tex
display="block"><![CDATA[\mathrm {loss}\left (\phi \right )=E_{\left (x,y\right )\sim  D_{\pi _{\phi }^{\mathrm {RL}}}}\left [r_\theta (x,y)-\beta \log \left (\pi _{\phi }^{\mathrm {RL}}(y\mid  x)/\pi ^{\mathrm {SFT}}(y\mid  x)\right )\right ] + \gamma  E_{x\sim  D_{\mathrm {pretrain}}}\left [\log (\pi _{\phi }^{\mathrm {RL}}(x))\right ]]]></fr:tex>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:title
text="Deepseek v2">Deepseek v2</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Paper 
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:title
text="Deepseek v3">Deepseek v3</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
TODO. Kinda wanna look into the architectural / training innovations from this paper.
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr
type="machine">#308</fr:addr><fr:route>unstable-308.xml</fr:route><fr:title
text="Deepseek R1">Deepseek R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:addr
type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:title
text="How is R1 different then previous iterations of models?">How is R1 different then previous iterations of models?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>In R1-Zero, they do <fr:strong>ZERO</fr:strong> SFT on the base model - directly apply reinforcement learning.</fr:li>
    <fr:li>Use PPO like policy optimization but do <fr:strong>NOT</fr:strong> learn a reward model.</fr:li>
    <fr:ul><fr:li>Use very simple reward: 
        <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[+1]]></fr:tex> for correct answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-0.5]]></fr:tex> for incorrect answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-1]]></fr:tex> for inability to answer.</fr:li></fr:ul></fr:li></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:addr
type="user">kak-003X</fr:addr><fr:route>kak-003X.xml</fr:route><fr:title
text="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Traditional actor critic RL algorithms, require training both an actor and a critic (as the name implies). Typically, these components are both of equal size. In the field of RL, this is non-problematic because models are typically rather small (at least in comparison to LLMs).
In <fr:link
type="local"
href="shao2024deepseekmathpushinglimitsmathematical.xml"
addr="shao2024deepseekmathpushinglimitsmathematical"
title="DeepSeekMath: Pushing the limits of mathematical reasoning in open language models">DeepSeekMath: Pushing the limits of mathematical reasoning in open language models</fr:link></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>480</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:title
text="Math">Math</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tex
display="block"><![CDATA[     \begin {align*}     {\mathcal {J}}_{\mathrm {GRPO}}(\theta )&= \mathbb {E}[q\sim  P(Q),\{o_{i}\}_{i=1}^{G}\sim \pi _{\theta _{o l d}}(O|q)] \\     &= \frac {1}{G}\sum _{i=1}^{G}\left (\operatorname *{min}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d}}(o_{i}|q)}A_{i},\operatorname *{clip}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d d}}(o_{i}|q)},1-\varepsilon ,1+\varepsilon \right )A_{i}\right )-\beta \mathbb {D}_{K L}\left (\pi _{\theta }||\pi _{r e f}\right )\right )     \end {align*}   ]]></fr:tex>
  where
  <fr:tex
display="block"><![CDATA[         \mathbb {D}_{\mathrm {K L}}\left (\pi _{\theta }||\pi _{\mathrm {ref}}\right )=\frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-\log \frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-1     ]]></fr:tex>
    The astute RL reader will notice this is essentially <fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">PPO</fr:link>.
    The key distinction here is that the advantage <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> is not computed using a critic model. Instead, 
<fr:tex
display="block"><![CDATA[A_{i}=\frac {r_{i}-\mathrm {mean}(\{r_{1},r_{2},\cdots ,r_{G}\})}{\mathrm {std}(\{r_{1},r_{2},\cdots ,r_{G}\})}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:addr
type="machine">#306</fr:addr><fr:route>unstable-306.xml</fr:route><fr:title
text="Post-training">Post-training</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:em>Reinforcement Learning for all Scenarios:</fr:em> Seems like they do RLHF after the pure RL stage.</fr:li>
        <fr:ul><fr:li>Do traditional helpfulness harmfulness RLHF with trained reward model.</fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:addr
type="machine">#307</fr:addr><fr:route>unstable-307.xml</fr:route><fr:title
text="Distilling Models with R1">Distilling Models with R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>To distill, they do only SFT with R1 generated COT.</fr:li>
      <fr:li>They show that distillation outperforms doing pure RL approach on smaller model</fr:li>
      <fr:ul><fr:li>Seems contradictory to <fr:link
type="local"
href="zeng2025simplerl.xml"
addr="zeng2025simplerl"
title="7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient">7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient</fr:link></fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<html:script
xmlns:html="http://www.w3.org/1999/xhtml"
src="https://utteranc.es/client.js"
repo="kkanarios32/website-comments"
issue-term="pathname"
theme="boxy-light"
crossorigin="anonymous"
async="" /></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3603</fr:anchor><fr:addr
type="user">kak-0005</fr:addr><fr:route>kak-0005.xml</fr:route><fr:title
text="Contrastive Reinforcement Learning">Contrastive Reinforcement Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog post, we aim to demistify <fr:link
type="external"
href="gcrl"><fr:em>Contrastive Reinforcement Learning</fr:em></fr:link>. This term often gets thrown around in the dark inner circles of the reinforcement learning community. However, for those that are not familiar with contrastive learning, what does contrastive even mean? For those that are, how can reinforcement learning be contrastive? Throughout this blog post, we will answer these questions and many more.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>438</fr:anchor><fr:addr
type="user">kak-0009</fr:addr><fr:route>kak-0009.xml</fr:route><fr:title
text="Contrastive Learning">Contrastive Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Prior to understanding contrastive reinforcement learning, it is important to have an at least rudimentary understanding of contrastive learning. Historically, contrastive learning has been used to learn representations. The fundamental idea behind contrastive learning is to encourage the representations of similar outputs to be similar in representation space.</fr:p><fr:p><fr:strong>Supervised setting:</fr:strong> For now, assume we are in the supervised setting (we have access to lables). Suppose that we are learning a representation in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Our model is a classifier on dogs and cats. If we have two dogs <fr:tex
display="inline"><![CDATA[y_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y_2]]></fr:tex> then we want the learned representation map <fr:tex
display="block"><![CDATA[\phi : \{\text {dogs}, \text {cats}\} \to  \mathbb {R}^d]]></fr:tex> to be such that <fr:tex
display="inline"><![CDATA[\phi (y_1)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\phi (y_2)]]></fr:tex> are "close" in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Now the notion of "close" is to be determined by the user. An example could be to minimize the inner product between their representation maps i.e. we could learn a feature map parametrized by <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex> with the following objective <fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle .]]></fr:tex> Similarly, we want dissimilar outputs to be far apart in representation space. If <fr:tex
display="inline"><![CDATA[y_3]]></fr:tex> is a cat, then we can introduce a regularization to encourage this i.e.
<fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle  - \sum _{i \in  \{1, 2\}} \langle  \phi _{\theta }(y_i), \phi _{\theta }(y_3) \rangle .]]></fr:tex></fr:p><fr:p><fr:strong>Unsupervised setting:</fr:strong> Now suppose that we get rid of labels and are just given <fr:tex
display="inline"><![CDATA[n]]></fr:tex> dog samples <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> from some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {D}}]]></fr:tex>. We now want to be able to learn <fr:tex
display="inline"><![CDATA[p_{\theta }]]></fr:tex> to somehow estimate this distribution. An approach is to learn to distinguish the sample dogs given from random noise. To do so, we generate <fr:tex
display="inline"><![CDATA[n]]></fr:tex> random images <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> according to some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {R}}]]></fr:tex>. We can now return to the supervised learning setting, where we treat <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> as two classes. If we recall standard supervised learning practice, given a sample <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we then want to find <fr:tex
display="block"><![CDATA[p(\mathcal {D} \mid  x) = 1 - p(\mathcal {R} \mid  X).]]></fr:tex> 
As an explicit example, we will use logistic regression. Namely, we will model <fr:tex
display="inline"><![CDATA[p(x) = p(\mathcal {D} \mid  x)]]></fr:tex> as <fr:tex
display="block"><![CDATA[p_{\theta }(x) = \frac {1}{1 + e^{-G_{\theta }(x)}}.]]></fr:tex> However, <fr:tex
display="inline"><![CDATA[p_{\theta }(x)]]></fr:tex> is estimating <fr:tex
display="inline"><![CDATA[p(\mathcal {D} \mid  x)]]></fr:tex>, where we care about <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex>. To estimate the correct quantity, we need to leverage our knowledge of the noise distribution. Recall that if <fr:tex
display="inline"><![CDATA[p_{\theta }(x) = p(\mathcal {D} \mid  x)]]></fr:tex> then <fr:tex
display="inline"><![CDATA[G_{\theta }(x) = \log  \frac {p(x \mid  \mathcal {D})}{p(x \mid  \mathcal {R})}]]></fr:tex>. Since we generated the samples from <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex>, we have the explicit distribution i.e. <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {R}) = p_{\mathcal {R}}(x)]]></fr:tex>. Therefore, we can restrict <fr:tex
display="inline"><![CDATA[G_{\theta }]]></fr:tex> to explicitly learn <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex> by considering <fr:tex
display="block"><![CDATA[G_{\theta }(x) = \log  p_{\theta }(x \mid  \mathcal {D}) - \log  p_{\mathcal {R}}(x),]]></fr:tex> considering the cross entropy loss we get the <fr:link
type="external"
href="nce">NCE loss</fr:link></fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">kak-000E</fr:addr><fr:route>kak-000E.xml</fr:route><fr:title
text="NCE loss">NCE loss</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="external"
href="nce">NCE</fr:link></fr:em> loss aims to minimize the following objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \sum _{t} \log  \left [h(x_t; \theta )\right ] + \log \left [1 - h(y_t; \theta )\right ],]]></fr:tex> where <fr:tex
display="inline"><![CDATA[x_t]]></fr:tex> are samples from the data distribution and <fr:tex
display="inline"><![CDATA[y_t]]></fr:tex> are randomly generated samples and <fr:tex
display="block"><![CDATA[\begin {array}{r c l}{{h({\bf  u};\theta )}}&{{=}}&{{\frac {1}{1+\exp \left [-G({\bf  u};\theta )\right ]},}}\\ {{G({\bf  u};\theta )}}&{{=}}&{{\ln  p_{m}({\bf  u};\theta )-\ln  p_{n}({\bf  u}).}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In <fr:link
type="local"
href="gutmann2012.xml"
addr="gutmann2012"
title="Noise-contrastive Estimation">Noise-contrastive Estimation</fr:link>, they show under mild conditions that the estimator <fr:tex
display="inline"><![CDATA[p_{\theta }(x \mid  D) \to  p_{\mathcal {D}}(x)]]></fr:tex> in probability as the number of samples in the loss goes to infinity. Equivalently, the estimator is <fr:link
type="local"
href="kak-000F.xml"
addr="kak-000F"
title="Consistent estimator">consistent</fr:link>.</fr:p><fr:p><fr:strong>Time series:</fr:strong> Before we get to contrastive RL, it is a natural question to wonder how does this apply to temporal sequences? Concretely, we want to make predictions about the future given the current "context". However, we want to do so in an unsupervised way, meaning we are only given trajectories not a notion of what it means for a trajectory to be good. Naively, one can try to do this in a supervised manner. For a <fr:tex
display="inline"><![CDATA[k]]></fr:tex> step prediction, this would just be your model predicting what will happen in <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps then seeing if it matches what occured <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps in the future in the sample trajectory. However, if your sample space <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is very high-dimensional, modeling this relationship can require an exorbinant amount of trajectories.</fr:p><fr:p>Fast forwarding to contrastive RL, current work is primarily considered with a particular contrastive objective.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>440</fr:anchor><fr:addr
type="user">kak-000B</fr:addr><fr:route>kak-000B.xml</fr:route><fr:title
text="InfoNCE">InfoNCE</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">InfoNCE</fr:link></fr:em> loss aims to minimize the following information-theoretic objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \mathbb {E}_{\mathcal {X}} \left [\log  \frac {f_k(x_{t + k}, c_t)}{\sum _{x_j \in  \mathcal {X}} f_k(x_j, c_t)}\right ]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Now we need to unpack this very ominous loss. To start, what are <fr:tex
display="inline"><![CDATA[x_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>?</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">kak-000C</fr:addr><fr:route>kak-000C.xml</fr:route><fr:title
text="Maximize Mutual info">Maximize Mutual info</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\mathcal {L}_N]]></fr:tex> from <fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">Contrastive Predictive Decoding</fr:link> maximizes a lower bound on the <fr:link
type="local"
href="kak-000V.xml"
addr="kak-000V"
title="Mutual Information">Mutual Information</fr:link> between <fr:tex
display="inline"><![CDATA[x_{t + k}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>442</fr:anchor><fr:addr
type="machine">#377</fr:addr><fr:route>unstable-377.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>All we must do is plug <fr:tex
display="inline"><![CDATA[\frac {p(x \mid  c)}{p(x)}]]></fr:tex> back into the objective.
  <fr:tex
display="block"><![CDATA[\begin {align*}     \mathcal {L}_{\mathbb {N}}^{\text {opt}}&=-\,\mathbb {E}\log \left [\frac {\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}}{\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}+\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &\approx \mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}(N-1)\,\mathbb {E}\,\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k} \mid  c_t)}N\right ] \\     &\geq  \mathbb {E} \log  \left [\frac {p(x_{t + k})}{p(x_{t + k} \mid  c_t)}N \right ] \\     &= - I(x_{t + k}, c_t) + \log  N  \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree><fr:tex
display="block"><![CDATA[ \operatorname *{max}_{f(u,v)}\mathbb {E}_{(u,v^{+})\sim  p(u,v)}\left [\log \sigma (\underbrace {f(u,{\green  v^{+}})}_{\phi (u)^{T}\psi ({\green  v^{+}})})+\log (1-\sigma (\underbrace {f(u,{\red  v^{-}})}_{\phi (u)^{T}\psi ({\red  v^{-}})}))\right ] ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} &\operatorname *{max}_{f}\mathbb {E}_{(s,a)\sim  p(s,a),s_{f}^{-}\sim  p(s_{f})}\left [\mathcal {L}(s,a,s_{f}^{+},s_{f}^{-})\right ] \\ \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}_1(\theta ) = \log \sigma (f_{\theta }(s_1,a_1,{\color {green} s_{8}})) + \log (1-\sigma (f_{\theta }(s_1,a_1, {\color {red} s_3}))) ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} \widehat {\mathcal {L}}(\theta ) &= \frac {1}{n} \sum _{i = 1}^{n} \mathcal {L}_i \\ &= \frac {1}{n} \sum _{i = 1}^{n} \Big [\log \sigma (f_{\theta }(s_i,a_i,{\color {green} s_{f}^{+}})) + \log (1-\sigma (f_{\theta }(s_i,a_i, {\color {red} s_{f}^{-}})))\Big ] \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}(\theta ) = \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] ]]></fr:tex><fr:tex
display="block"><![CDATA[f^*(s, a, s_g) = \log \left (\frac {p^{\pi (\cdot  \mid  \cdot )}(s_g \mid  s, a)}{p(s_g)}\right )]]></fr:tex>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="machine">#378</fr:addr><fr:route>unstable-378.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We want to maximize
<fr:tex
display="block"><![CDATA[     \begin {align*} \mathcal {L}(\theta ) &= \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] \\ &= \int  \log \sigma (f_{\theta }(x)) P_X(x) + \int  \log (1-\sigma (f_{\theta }(y))) P_Y(y) \\ &= \int  \log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)     \end {align*}     ]]></fr:tex>
    Since we are maximizing <fr:tex
display="inline"><![CDATA[f(s)]]></fr:tex>, we can just maximize the integrand i.e.
<fr:tex
display="block"><![CDATA[       \begin {align*}         \frac {\mathrm {d}}{\mathrm {d}f(z)} \Big [\log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)\Big ] = 0       \end {align*}     ]]></fr:tex>
    Solving,
    <fr:tex
display="block"><![CDATA[         \begin {align*}           P_X(z)\big (1 - \sigma (f(z))\big ) - P_Y(z)\sigma (f(z)) = 0 &\iff  \sigma (f(z)) = \frac {P_X(z)}{P_X(z) + P_Y(z)} \\           &\iff  f(z) = \log \left (\frac {P_X(z)}{P_Y(z)}\right )         \end {align*}       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>444</fr:anchor><fr:addr
type="machine">#379</fr:addr><fr:route>unstable-379.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
The first step is to prove that the average Q-values are close to the task-conditioned Q-values. Below, we will use <fr:tex
display="inline"><![CDATA[R_{c}(\tau )\triangleq \sum _{\ell =0}^{\infty }\gamma ^{\ell }r_{\ell }(s_{\ell },a_{\ell })]]></fr:tex>:

<fr:tex
display="block"><![CDATA[ \begin {align*} \left |Q^{\beta (\cdot |\cdot ,a)}(s,a,e)-Q^{\beta (\cdot |\cdot ,\epsilon ^{\prime })}(s,a,e)\right |&=\left |\int \beta (\tau \mid  s,a,e)R_{e}(\tau )d\tau -\int \beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right |\\  &=\left |\int \beta (\tau \mid  s,a,e)-\beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right | \\ &=\left |\int \beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )R_{e}(\tau )d\tau \right | \\ &\leq \int \left |\beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )\right |d\tau \cdot \operatorname *{max}_{\tau }|R_{e}(\tau )d\tau | \\ &\leq \int \beta (\tau \mid  s,a,e)\left |1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right |d\tau \cdot  1 \\ &=\mathbb {E}_{\beta (\tau |s,a,e)}\left [\left |1-{\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}}\right |\right ] \\ &\leq  \epsilon . \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3605</fr:anchor><fr:addr
type="user">kak-0003</fr:addr><fr:route>kak-0003.xml</fr:route><fr:title
text="Notes">Notes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This will be home to my notes that have graduated from <fr:link
type="local"
href="kak-0015.xml"
addr="kak-0015"
title="Learning">Learning</fr:link> either because they are no longer in development or because I am happy with where they are currently at.</fr:p>
  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>951</fr:anchor><fr:addr
type="machine">#413</fr:addr><fr:route>unstable-413.xml</fr:route><fr:title
text="Old  Notes from Undergrad">Old <fr:tex
display="inline"><![CDATA[\LaTeX ]]></fr:tex> Notes from Undergrad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>953</fr:anchor><fr:addr
type="user">algebra</fr:addr><fr:route>algebra.xml</fr:route><fr:title
text="Math 494 Notes">Math 494 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/494-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>955</fr:anchor><fr:addr
type="user">analysis</fr:addr><fr:route>analysis.xml</fr:route><fr:title
text="Math 395 Notes">Math 395 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/395-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>957</fr:anchor><fr:addr
type="user">functional</fr:addr><fr:route>functional.xml</fr:route><fr:title
text="Math 602 Notes">Math 602 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/602-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>959</fr:anchor><fr:addr
type="user">measure</fr:addr><fr:route>measure.xml</fr:route><fr:title
text="Math 597 Notes">Math 597 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/597-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3607</fr:anchor><fr:addr
type="user">kak-0006</fr:addr><fr:route>kak-0006.xml</fr:route><fr:title
text="What's up with all these fancy optimizers?">What's up with all these fancy optimizers?</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Throughout my trials and tribulations with experimental RL, I ran into the seemingly prevelant problem of severe instability dependent on optimizers and even hyperparameters of optimizers. In this blog, I aim to understand where and why things have seemingly evolved out of control from trusty SGD.</fr:p><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
  width: 25%; 
  height: 200px; 
  background-image: url('test.png'); 
  background-size: contain; 
  background-repeat: no-repeat;
  display: inline-block;
" /><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
  width: 25%; 
  height: 200px; 
  background-image: url('test.png'); 
  background-size: contain; 
  background-repeat: no-repeat;
  display: inline-block;
" /><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
  width: 25%; 
  height: 200px; 
  background-image: url('test.png'); 
  background-size: contain; 
  background-repeat: no-repeat;
  display: inline-block;
" /><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
  width: 25%; 
  height: 200px; 
  background-image: url('test.png'); 
  background-size: contain; 
  background-repeat: no-repeat;
  display: inline-block;
" /><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
  width: 25%; 
  height: 200px; 
  background-image: url('test.png'); 
  background-size: contain; 
  background-repeat: no-repeat;
  display: inline-block;
" /></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3609</fr:anchor><fr:addr
type="user">meta2024</fr:addr><fr:route>meta2024.xml</fr:route><fr:title
text="Meta Learning for Continual Reinforcement Learning: An Investigation">Meta Learning for Continual Reinforcement Learning: An Investigation</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/continual_rl_slides.pdf</fr:meta><fr:meta
name="external">papers/honors_thesis.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3611</fr:anchor><fr:addr
type="user">kanarios2024</fr:addr><fr:route>kanarios2024.xml</fr:route><fr:title
text="Cost Aware Best Arm Identification">Cost Aware Best Arm Identification</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author><fr:author><fr:link
type="local"
href="qiningzhang.xml"
addr="qiningzhang"
title="Qining Zhang">Qining Zhang</fr:link></fr:author><fr:author><fr:link
type="local"
href="leiying.xml"
addr="leiying"
title="Lei Ying">Lei Ying</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/cabai_slides.pdf</fr:meta><fr:meta
name="external">posters/cabai_rlc_poster.pdf</fr:meta><fr:meta
name="doi">10.48550/arXiv.2402.16710</fr:meta><fr:meta
name="venue"><fr:link
type="local"
href="rlc.xml"
addr="rlc"
title="Reinforcement Learning Conference">Reinforcement Learning Conference</fr:link></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3615</fr:anchor><fr:addr
type="user">kanariosdas2023</fr:addr><fr:route>kanariosdas2023.xml</fr:route><fr:title
text="Parallel Algebraic Multigrid for Higher Order PDEs">Parallel Algebraic Multigrid for Higher Order PDEs</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/amg_slides.pdf</fr:meta><fr:meta
name="external">posters/amg_poster.pptx</fr:meta><fr:meta
name="doi">https://www.osti.gov/servlets/purl/2205732/</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3617</fr:anchor><fr:addr
type="user">log-0002</fr:addr><fr:route>log-0002.xml</fr:route><fr:title
text="11/13/2024">11/13/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>It has been awhile since my last entry. Unfortunately, I had some travel among other things, but I am ready to finish the semester strong.</fr:p><fr:p><fr:strong>Daily Summary:</fr:strong> Today we finally narrowed down the scope of our compilers project. To summarize, we have implemented a CFG pass as part of Jaclang to serve as part of our LamIR to pass to a language model at runtime. However, a few questions remain:</fr:p><fr:ul><fr:li>What runtime information is important to provide in addition to the CFG, AST, etc?</fr:li>
  <fr:ul><fr:li>Currently we are focused on annotating edges of the CFG with visitation counts as they happen at runtime.</fr:li>
    <fr:li>As an implementation detail, is there a better way then <fr:code>sys.settrace</fr:code> to get runtime information without having to modify CPython source code?</fr:li></fr:ul>
    <fr:li>How do we represent this representation in natural language in order for the LLM to provide meaningful results?</fr:li>
    <fr:li>What is a meaningful result?</fr:li>
    <fr:ul><fr:li>Currently, we are interested in smart asserts, but ideally some code optimization can be performed.</fr:li></fr:ul></fr:ul><fr:p><fr:strong>Tomorrow Todo's:</fr:strong></fr:p><fr:ul><fr:li>In preparation for MATH 626 next semester, I need to brush up on probability. To do so, I will be following along with <fr:link
type="external"
href="https://www.colorado.edu/amath/sites/default/files/attached-files/billingsley.pdf">Probability and Measure</fr:link> by Billingsley.</fr:li>
  <fr:li>For research,</fr:li>
  <fr:ul><fr:li>Must get contrastive RL experiments up and running,</fr:li>
    <fr:li>If that happens I plan to set up dumping runtime info in Jaclang.</fr:li>
    <fr:li>Also I have a scheduled meeting with AMD advisors for GPU project. We will see what comes of this.</fr:li></fr:ul>
  <fr:li>Paper of the week will still be <fr:link
type="external"
href="gcrl">gcrl</fr:link>. Any other extra/break time will be towards blog post.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3619</fr:anchor><fr:addr
type="user">log-0003</fr:addr><fr:route>log-0003.xml</fr:route><fr:title
text="11/14/2024">11/14/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>This day did not quite go to plan. The contrastive RL repo is not exactly how imagined it...</fr:p>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2573</fr:anchor><fr:addr
type="machine">#252</fr:addr><fr:route>unstable-252.xml</fr:route><fr:title
text="Daily Summary">Daily Summary</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:strong>GPU Project:</fr:strong>
    <fr:ul><fr:li>Have GPU kernel for part of chaining algorithm. Makes a CPU call for another part</fr:li>
      <fr:ul><fr:li>Need to write a kernel for a naturally sequential DP.</fr:li>
        <fr:li>My initial impression is just how to reuse any memory accesses that have been done for the current GPU kernel.</fr:li></fr:ul>
      <fr:li>Key question is does even a naive kernel implementation speed up the overall program due to the eliminated memory transfer between GPU and CPU?</fr:li></fr:ul>
    <fr:strong>Contrastive RL:</fr:strong>
    <fr:ul><fr:li>Question is how to do contrastive RL in a lifelong setting? i.e. non-episodic and potentially changing reward functions.</fr:li>
      <fr:li>Have a pretty good idea how to implement the ant gather environment. However, current setup returns object positions.</fr:li>
      <fr:ul><fr:li>If there are a lot (potentially infinite) apples / bombs this will not work.</fr:li>
          <fr:li>Need to modify so observations are images, but this makes problem significantly harder.</fr:li></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2575</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:title
text="Tomorrow Todo's">Tomorrow Todo's</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:ul><fr:li>Might not have time for self-study tomorrow. It is a packed day.</fr:li>
  <fr:li>For research,</fr:li>
  <fr:ul><fr:li><fr:strong>CRL stuff:</fr:strong> Render ant gather environment. Hopefully, before compilers meeting.</fr:li>
    <fr:li><fr:strong>Compilers stuff:</fr:strong> Have meeting. Need actionable goals for runtime information logging.</fr:li>
    <fr:li><fr:strong>LLMs stuff:</fr:strong> After group meeting, must make slides on weak-to-strong. Look at new version of paper.</fr:li></fr:ul>
  <fr:li>If I somehow have extra time, then continue with probability self study. Ideally, I get through the background chapter by Monday. We want to get to probability measures to do probability!</fr:li>
  <fr:ul><fr:li>It seems it may also be a good idea to get some background with discrete stochastic processes, so I may concurrently follow along an MIT courseware course. TBD.</fr:li></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3621</fr:anchor><fr:addr
type="user">log-0004</fr:addr><fr:route>log-0004.xml</fr:route><fr:title
text="11/16/2024">11/16/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>I am currently on a run of bad productivity days. Hopefully, this will be resolved with a lighter exercise load next week.</fr:p>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2579</fr:anchor><fr:addr
type="machine">#250</fr:addr><fr:route>unstable-250.xml</fr:route><fr:title
text="Daily Summary">Daily Summary</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:strong>Contrastive RL:</fr:strong> Today, I did spend a bit of time on this project. Mainly, I have been accumulating useful tips from productive researchers, and they recommend not rushing to publish but rather deeply understanding your field first. Due to this, I have decided to take a brief step back and survey the field a bit.
    <fr:ul><fr:li>I quickly went over a parallel line of work based on Laplacian representations of transition dynamics. It seems there is an explicit correspondence between these approaches and the successor representation I have grown accustomed to. A question I plan to explore is what advantages one approach offers over the other? Maybe there is a slick way to compute one efficiently?</fr:li>
      <fr:li>I also have come to the realization that I do not need to implement the ant gather environment in its entirety right away. Just re-using the ant ball environment and respawning the ball when it is reached should be enough?</fr:li></fr:ul>
<fr:strong>Weak-to-strong Generalization:</fr:strong> Unfortunately, this is what I spent most of my time on today. We have an upcoming presentation on the topic and so I obviously obsessively have tried to understand everything that may come up as a question.
<fr:ul><fr:li>The prevailing result of today is that our previous formulation was not very good. (Exciting I know)</fr:li>
    <fr:li>My main takeaway is that if we assume a latent concept space i.e. 
<fr:tex
display="block"><![CDATA[\mathrm {LLM}(Y \mid  X) = \int _{\Theta } f(Y \mid  X, \theta ) p(\theta  \mid  X) d\theta ]]></fr:tex>
    In the previous formulation, the ICL task can only correspond to <fr:strong>one</fr:strong> <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex>. This is because then if we assume ICL is doing bayesian update it can identify <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex>.</fr:li>
    <fr:ul><fr:li>Not sold on if this is true.</fr:li>
        <fr:li>Main question is what do they mean by overlap?</fr:li>
        <fr:ul><fr:li>Does each <fr:tex
display="inline"><![CDATA[q_i(Y \mid  X) = q(Y \mid  X, \theta _i)]]></fr:tex> have non-overlapping output space?</fr:li>
            <fr:li>Or are they referring to the assumption that the target task is a single <fr:tex
display="inline"><![CDATA[\theta _i]]></fr:tex>?</fr:li></fr:ul></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2581</fr:anchor><fr:addr
type="machine">#251</fr:addr><fr:route>unstable-251.xml</fr:route><fr:title
text="Tomorrow Todo's">Tomorrow Todo's</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:ul><fr:li>I intend to be a probabilist next semester, so I must refresh probabliity background ASAP. Aim for 1-2hrs of probability book.</fr:li>
  <fr:li>For research,</fr:li>
  <fr:ul><fr:li><fr:strong>CRL stuff:</fr:strong> Implement non-stationary ant ball. Hopefully, get some sort of experiment running.</fr:li>
    <fr:li><fr:strong>Compilers stuff:</fr:strong> Might be meeting with group tomorrow?</fr:li>
    <fr:li><fr:strong>LLMs stuff:</fr:strong> If left over time, then dive into alternative interesting formulations (unlikely).</fr:li></fr:ul>
  <fr:li>As my next reading endeavour, I intend to deeply understand the successor features survey by Machado and Doina. This will probably be a paper of the month as I cannot possibly digest the 70 page behemoth in the next week.</fr:li>
  <fr:li>As another thing todo, is get better at writing these todo's. Ideally, they will be much more actionable as I continue making these logs. I guess we'll see.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3623</fr:anchor><fr:addr
type="user">log-0005</fr:addr><fr:route>log-0005.xml</fr:route><fr:title
text="11/18/2024">11/18/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Today we kind of got back on track.</fr:p>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2585</fr:anchor><fr:addr
type="machine">#248</fr:addr><fr:route>unstable-248.xml</fr:route><fr:title
text="Daily Summary">Daily Summary</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:strong>Contrastive RL:</fr:strong> As a way to avoid struggling with mujoco, I re-immersed myself in the relevant literature. I had a few takeaways:
    <fr:ul><fr:li>I took a look back at the <fr:link
type="local"
href="mcleod2022.xml"
addr="mcleod2022"
title="Continual Auxiliary Task Learning">Continual Auxiliary Task Learning</fr:link> paper. I still really want to implement a system that puts everything together. Namely,</fr:li>
      <fr:ul><fr:li>In this paper, they do not learn the cumulants that they use to compute the successor features.</fr:li>
          <fr:li>Also, is a continual optimizer enough for non-stationary MDPs when learning cumulants?</fr:li></fr:ul>
        <fr:li>Regarding implementation details for the Contrastive RL stuff. It seems the first priority should actually be implementing the hierarchical policy.</fr:li>
        <fr:ul><fr:li>Currently, the repo is set up to randomly select goals and see how well the goal-conditioned policy can reach them. This is basically the extent of experimentation needed without the hierarchical policy.</fr:li></fr:ul>
      <fr:li>I did come across an alternative successor-feature like apprach that I want to take a closer look at: the Forward-Backward representation <fr:link
type="external"
href="https://openreview.net/pdf?id=MYEap_OcQI">Toutati et al. 2023</fr:link>, <fr:link
type="external"
href="http://www.yann-ollivier.org/rech/publs/allpolicies.pdf">Toutati et al. 2021</fr:link>, <fr:link
type="external"
href="https://arxiv.org/pdf/2101.07123">Blier et al. 2021</fr:link>. Initial impressions:</fr:li>
      <fr:ul><fr:li>Seems to be learned in a very similar manner to the successor feature stuff.</fr:li>
          <fr:li>Re-parametrization avoids converging to trivial 0 solution.</fr:li>
          <fr:li>Experimentally, seems way better than contrastive (at least for zero shot RL).</fr:li></fr:ul></fr:ul>
<fr:strong>Weak-to-strong Generalization:</fr:strong> I finished up my slides for our presentation tomorrow.
<fr:ul><fr:li>I have sufficiently confused myself on what weak-to-strong generalization even means. Is it</fr:li>
    <fr:ol><fr:li>Correctly answering things that the weak model got incorrect? or</fr:li>
        <fr:li>Generalizing correct answers on easier tasks to harder tasks?</fr:li></fr:ol>
      <fr:li>The former case seems to be the hot topic right now, but I think the second one might be what we actually care about?</fr:li>
      <fr:li>Maybe think about how to formulate this mathematically.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2587</fr:anchor><fr:addr
type="machine">#249</fr:addr><fr:route>unstable-249.xml</fr:route><fr:title
text="Tomorrow Todo's">Tomorrow Todo's</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>I have a plethora of meetings tomorrow, so I may not get too much done.</fr:li>
    <fr:li>For research,</fr:li>
    <fr:ul><fr:li><fr:strong>CRL stuff:</fr:strong> Meeting with my advisor tomorrow (scary-ish). Will hopefully have next steps after that.</fr:li>
      <fr:li><fr:strong>Compilers stuff:</fr:strong> High-priority after my meeting. Need to figure out how to get branch counts. Even if super naive (no more CPython rabbit holes).</fr:li>
      <fr:li><fr:strong>LLMs stuff:</fr:strong> Talk to group mates. Who knows where this might go.</fr:li></fr:ul>
    <fr:li>I have added another thing to the reading list: <fr:link
type="external"
href="http://www.yann-ollivier.org/rech/publs/allpolicies.pdf">Toutati et al. 2021</fr:link>. This seems to be what I was looking for. A unification of all of the successor-representation-like algorithms that have been floating around my space.</fr:li>
    <fr:li>Game-time decision whether I panic prepare stuff for my meeting / presentation, or start the probability measures section of my self-study. We shall see...</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3625</fr:anchor><fr:addr
type="user">log-0006</fr:addr><fr:route>log-0006.xml</fr:route><fr:title
text="11/20/2024">11/20/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>I am still hitting an afternoon wall. I have yet to put a full day together in awhile, but the waking up early and working has helped a little bit.</fr:p>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2591</fr:anchor><fr:addr
type="machine">#246</fr:addr><fr:route>unstable-246.xml</fr:route><fr:title
text="Daily Summary">Daily Summary</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><fr:strong>Probability Theory:</fr:strong> Upon waking up, I seem to struggle to immediately go into coding mode. To still be productive, I have instituted a self-study or paper reading upon waking up. For some reason this is more manageable to me? Anyways, I have made it through the second section of <fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">Probability and Measure</fr:link>, where we defined probabilty measures. I do think carefully going through this without worrying about problem sets, etc. has allowed me to gain a bit more intuition into what is going on.</fr:p>

  <fr:p><fr:strong>Weak-to-strong Generalization:</fr:strong> Upon reading the linear probing paper <fr:link
type="external"
href="https://arxiv.org/pdf/2202.10054">Kumar et al. 2022</fr:link> and Mihir's wonderful presentation, I understand better what their claims are and have kind of shifted focus.

    <fr:ul><fr:li>In the linear probing case, they assume the in distribution and out of distribution still come from the same "sample space" in some sense.</fr:li>
        <fr:li>They also are all correctly labeled unlike in weak-to-strong.</fr:li>
        <fr:li>To me, this applies better to easy-to-hard generalization, so we are now exploring this direction instead.</fr:li>
        <fr:li>The main question now is how to theoretically represent an "easy" and hard question? Along with how to represent the "latent knowledge" that allows the model to generalize from easy-to-hard?</fr:li>
        <fr:li>Need to setup experiments to test linear probing vs. fine-tuning in easy-to-hard.</fr:li>
        <fr:li>Existing papers only do linear probing vs. LoRA.</fr:li></fr:ul></fr:p>
<fr:p><fr:strong>Ghost in the shell:</fr:strong> This project has also started to take off a little bit. I have been tasked with implementing the python tracer to provide profile information to our LaMIR.
<fr:ul><fr:li>I am still feeling a bit ambitious and want to do this in C with CPython. However, my group is more intent on just getting something working, which I can understand.</fr:li>
    <fr:li>Need to better gauge how difficult a C tracer would be before I decide.</fr:li></fr:ul></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2593</fr:anchor><fr:addr
type="machine">#247</fr:addr><fr:route>unstable-247.xml</fr:route><fr:title
text="Tomorrow Todo's">Tomorrow Todo's</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>Section 3 of <fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">Probability and Measure</fr:link> seems a bit dense. Finish construction of extension and see how we feel.</fr:li>
    <fr:li>Time to deeply understand contrastive RL. In particular, how Q-function comes from contrastive loss</fr:li>
    <fr:ul><fr:li>If in the mood, try to understand <fr:link
type="local"
href="nachum2019.xml"
addr="nachum2019"
title="Near Optimal Representation Learning for Hierarchical Reinforcement Learning">Near Optimal Representation Learning for Hierarchical Reinforcement Learning</fr:link> connection to contrastive RL</fr:li></fr:ul>
    <fr:li>Otherwise, pick one of tracer work / linear probing work to make some progress on.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3627</fr:anchor><fr:addr
type="user">log-0007</fr:addr><fr:route>log-0007.xml</fr:route><fr:title
text="11/21/2024">11/21/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Not a maximally productive day but good progress was made on (almost?) every project.</fr:p>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2597</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:title
text="Daily Summary">Daily Summary</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><fr:strong>Probability Theory:</fr:strong> I am having a surprisingly good time learning this compared to my experience in undergrad. Today, I finished and thorougly understood the extension of a measure to the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra induced by the outer measure. I left the uniqueness for the next session. I guess the only outstanding question I had was 
    <fr:ul><fr:li>Why do we need to impose the extra condition that we need the set to satisfy <fr:tex
display="inline"><![CDATA[P^*(A \cap  E) + P^*(A^c \cap  E) = P^*(E)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex> vs. just taking <fr:tex
display="inline"><![CDATA[E = \Omega ]]></fr:tex>?</fr:li></fr:ul></fr:p>

  <fr:p><fr:strong>Contrastive RL:</fr:strong> Today was big for my understanding along with an interesting new direction.
    <fr:ul><fr:li>I went over both the original <fr:link
type="local"
href="gutmann2012.xml"
addr="gutmann2012"
title="Noise-contrastive Estimation">NCE</fr:link> and <fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">InfoNCE</fr:link> papers to better understand the non-RL versions.</fr:li>
      <fr:li>Finally have kind of understood, where the <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-function comes from in <fr:link
type="local"
href="eysenbach2023.xml"
addr="eysenbach2023"
title="Constrastive Learning as Goal Conditioned Reinforcement Learning">Constrastive Learning as Goal Conditioned Reinforcement Learning</fr:link> even though they do not provide proof of the Lemma that claims it.</fr:li>
      <fr:ul><fr:li>In the <fr:link
type="local"
href="gutmann2012.xml"
addr="gutmann2012"
title="Noise-contrastive Estimation">Noise-contrastive Estimation</fr:link> paper, they show that their objective will converge to the distribution that generated the data <fr:tex
display="inline"><![CDATA[p(x)]]></fr:tex>. In <fr:link
type="local"
href="eysenbach2023.xml"
addr="eysenbach2023"
title="Constrastive Learning as Goal Conditioned Reinforcement Learning">Constrastive Learning as Goal Conditioned Reinforcement Learning</fr:link>, they want to learn the discounted state occupancy measure. To make this their <fr:tex
display="inline"><![CDATA[p(x)]]></fr:tex>, 
          <fr:ol><fr:li>they take their "positive" examples as drawn from the state occupancy (turns out to do this is not that hard).</fr:li>
            <fr:li>they just sample their negative examples uniformly.</fr:li></fr:ol>
          <fr:li>Need to look a little more at <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-function is state discounted probability proof. Why is it not just linearity of expectation / Fubini? Inner series is clearly convergent? Probably related to policy stuff I need to get better at.</fr:li></fr:li></fr:ul>
        <fr:li>An interesting idea that came up is to apply goal-conditioned RL to safe RL. Namely, we can discourage the visitation of unsafe states by considering <fr:tex
display="inline"><![CDATA[Q(s, a, \text {unsafe})]]></fr:tex></fr:li>
        <fr:ul><fr:li>Take <fr:tex
display="inline"><![CDATA[\pi  \in  \arg \max _{\pi } Q(s, \pi (s), g) - \lambda (\delta ) Q(s, \pi (s), \text {obstacle})]]></fr:tex>, or</fr:li>
            <fr:li>take <fr:tex
display="inline"><![CDATA[\pi  \in  \arg \max _{\pi } Q(s, \pi (s), g)]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[Q(s, \pi (s), \text {obstacle}) < \epsilon ]]></fr:tex>.</fr:li></fr:ul></fr:ul></fr:p>
<fr:p><fr:strong>Ghost in the shell:</fr:strong> New ideas have arisen to turn this course project into a research project.
<fr:ul><fr:li>Professors introduce the concept of "phase detection" from microarchitecture.</fr:li>
    <fr:li>It seems that this area is concerned with detecting how inputs may influence things like hot paths and detecting when this is going to occur.</fr:li>
    <fr:li>These methods all seems to choose metrics and algorithms for these metrics arbitrarily.</fr:li>
    <fr:li>Can we pass a superset of all these metrics to an LLM and have it detect phase changes automatically?</fr:li></fr:ul></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2599</fr:anchor><fr:addr
type="machine">#245</fr:addr><fr:route>unstable-245.xml</fr:route><fr:title
text="Tomorrow Todo's">Tomorrow Todo's</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>I want to start <fr:link
type="local"
href="jiang2024.xml"
addr="jiang2024"
title="Reinforcement Learning: Theory and Algorithms">Reinforcement Learning: Theory and Algorithms</fr:link> tomorrow, taking a short break from very abstract / rigorous mathematics.</fr:li>
    <fr:li>Focus tomorrow is getting profiling up and running.</fr:li>
    <fr:ul><fr:li>By EOD, need to have edges of CFG filled with visitation frequencies.</fr:li></fr:ul>
    <fr:li>If extra time, finish / work on <fr:link
type="local"
href="kak-0005.xml"
addr="kak-0005"
title="Contrastive Reinforcement Learning">Contrastive Reinforcement Learning</fr:link> blog post with newfound knowledge.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3629</fr:anchor><fr:addr
type="user">log-0001</fr:addr><fr:route>log-0001.xml</fr:route><fr:title
text="11/4/2024">11/4/2024</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Hello world! This is my first instantiation of this daily logging thing. Here I will attempt to jot down any questions that come up in my research along with planning my daily activities of the next day. To hold my self accountable, I will log my daily accomplishments and questions.</fr:p><fr:p><fr:strong>Daily Summary:</fr:strong> Today, I focused most of my efforts on the <fr:link
type="local"
href="kak-0005.xml"
addr="kak-0005"
title="Contrastive Reinforcement Learning">Contrastive Reinforcement Learning</fr:link> blog. I was not able to finish it, but significant progress was made. I think while writing this blog I am finally starting to see how everything comes together. Ultimately, this was more of a logistical day. Since I just instatiated my more structure daily plan, hopefully we can adhere to it tomorrow.</fr:p><fr:p><fr:strong>Tomorrow Todo's:</fr:strong> With the instantiation of the new plan I will allocate my next day's activities a day in advance.</fr:p><fr:ul><fr:li>We will be starting a self-study following <fr:link
type="local"
href="richardsutton.xml"
addr="richardsutton"
title="Richard Sutton">Richard Sutton</fr:link>'s <fr:link
type="external"
href="https://drive.google.com/drive/folders/0B3w765rOKuKANmxNbXdwaE1YU1k?resourcekey=0-JZz-noRuJgogNsg1ljgV8w">CMPUT 609</fr:link> course. For tomorrow, I will go over the review questions and then start with the function approximation section of his textbook.</fr:li>
  <fr:li>For research, it is long overdue that I contribute to my weak-to-strong generalization project. There are two outstanding objectives:</fr:li>
  <fr:ul><fr:li>Finite sample analysis,</fr:li>
    <fr:li>Experiment implementation.</fr:li></fr:ul>
  I will choose / switch between these.
  <fr:li>Paper of the week will still be <fr:link
type="external"
href="gcrl">gcrl</fr:link>. I will also use this and my extra time to work on the blog post.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="true"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3631</fr:anchor><fr:addr
type="user">kak-0001</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Kellen Kanarios">Kellen Kanarios</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="author">false</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>This is my <fr:link
type="external"
href="https://www.jonmsterling.com/foreign-forester-tfmt-000V.xml">forest</fr:link>. I am a PhD student at the <fr:link
type="local"
href="umich.xml"
addr="umich"
title="University of Michigan">University of Michigan</fr:link> as part of the <fr:link
type="external"
href="https://ece.engin.umich.edu/">Electrical and Computer Engineering program</fr:link>, where I work on reinforcement learning. My PhD advisor is <fr:link
type="local"
href="leiying.xml"
addr="leiying"
title="Lei Ying">Lei Ying</fr:link>. Previously, I obtained a BS from the <fr:link
type="local"
href="umich.xml"
addr="umich"
title="University of Michigan">University of Michigan</fr:link> in Mathematics and Computer Science, where I graduated with honors and high honors respectively. During my undergrad, I worked with <fr:link
type="local"
href="leiying.xml"
addr="leiying"
title="Lei Ying">Lei Ying</fr:link> as part of the <fr:link
type="external"
href="https://sure.engin.umich.edu/">SURE Program</fr:link> and as a teaching assitant for <fr:link
type="external"
href="https://sites.google.com/view/intro-to-rl/home">EECS 602</fr:link>.
<fr:p><fr:strong>DISCLAIMER:</fr:strong> This website still heavily under construction.</fr:p>


  <fr:ul><fr:li>This is a (outdated) picture of me
    <html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
      width: 25%; 
      height: 200px; 
      background-image: url('img/profile-pic.png'); 
      background-size: contain; 
      background-repeat: no-repeat;
    " /></fr:li>
    <fr:li>Email: <fr:link
type="external"
href="mailto:kellenkk@umich.edu">kellenkk@umich.edu</fr:link></fr:li>
    <fr:li>CV: <fr:link
type="external"
href="files/kellen-kanarios-cv.pdf">kellen-cv</fr:link></fr:li></fr:ul></fr:p>
  
  
  <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2302</fr:anchor><fr:addr
type="user">rn</fr:addr><fr:route>rn.xml</fr:route><fr:title
text="News">News</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:ul><fr:li>[<fr:strong>September. 2024</fr:strong>] I will officially be starting my PhD at <fr:link
type="local"
href="umich.xml"
addr="umich"
title="University of Michigan">University of Michigan</fr:link></fr:li>
      <fr:li>[<fr:strong>August. 2024</fr:strong>] I finished my undergraduate <fr:link
type="local"
href="meta2024.xml"
addr="meta2024"
title="Meta Learning for Continual Reinforcement Learning: An Investigation">thesis</fr:link> and officially graduated!</fr:li>
      <fr:li>[<fr:strong>August. 2024</fr:strong>] I will be attending the first ever <fr:link
type="local"
href="rlc.xml"
addr="rlc"
title="Reinforcement Learning Conference">Reinforcement Learning Conference</fr:link></fr:li>
      <fr:li>[<fr:strong>May. 2024</fr:strong>] Our <fr:link
type="local"
href="kanarios2024.xml"
addr="kanarios2024"
title="Cost Aware Best Arm Identification">paper</fr:link> got accepted by <fr:link
type="local"
href="rlc.xml"
addr="rlc"
title="Reinforcement Learning Conference">Reinforcement Learning Conference</fr:link></fr:li>
      <fr:li>[<fr:strong>January. 2024</fr:strong>] I will be TAing <fr:link
type="external"
href="https://sites.google.com/view/intro-to-rl/home">EECS 602</fr:link></fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree>

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2304</fr:anchor><fr:addr
type="user">pub</fr:addr><fr:route>pub.xml</fr:route><fr:title
text="Research">Research</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2306</fr:anchor><fr:addr
type="user">meta2024</fr:addr><fr:route>meta2024.xml</fr:route><fr:title
text="Meta Learning for Continual Reinforcement Learning: An Investigation">Meta Learning for Continual Reinforcement Learning: An Investigation</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/continual_rl_slides.pdf</fr:meta><fr:meta
name="external">papers/honors_thesis.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2308</fr:anchor><fr:addr
type="user">kanarios2024</fr:addr><fr:route>kanarios2024.xml</fr:route><fr:title
text="Cost Aware Best Arm Identification">Cost Aware Best Arm Identification</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author><fr:author><fr:link
type="local"
href="qiningzhang.xml"
addr="qiningzhang"
title="Qining Zhang">Qining Zhang</fr:link></fr:author><fr:author><fr:link
type="local"
href="leiying.xml"
addr="leiying"
title="Lei Ying">Lei Ying</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/cabai_slides.pdf</fr:meta><fr:meta
name="external">posters/cabai_rlc_poster.pdf</fr:meta><fr:meta
name="doi">10.48550/arXiv.2402.16710</fr:meta><fr:meta
name="venue"><fr:link
type="local"
href="rlc.xml"
addr="rlc"
title="Reinforcement Learning Conference">Reinforcement Learning Conference</fr:link></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2312</fr:anchor><fr:addr
type="user">kanariosdas2023</fr:addr><fr:route>kanariosdas2023.xml</fr:route><fr:title
text="Parallel Algebraic Multigrid for Higher Order PDEs">Parallel Algebraic Multigrid for Higher Order PDEs</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>20</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/amg_slides.pdf</fr:meta><fr:meta
name="external">posters/amg_poster.pptx</fr:meta><fr:meta
name="doi">https://www.osti.gov/servlets/purl/2205732/</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2314</fr:anchor><fr:addr
type="user">kak-0002</fr:addr><fr:route>kak-0002.xml</fr:route><fr:title
text="Blog">Blog</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This is my blog, in which I write about a variety of topics including computer science, mathematics, and more.</fr:p>


<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>436</fr:anchor><fr:addr
type="user">kak-0005</fr:addr><fr:route>kak-0005.xml</fr:route><fr:title
text="Contrastive Reinforcement Learning">Contrastive Reinforcement Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog post, we aim to demistify <fr:link
type="external"
href="gcrl"><fr:em>Contrastive Reinforcement Learning</fr:em></fr:link>. This term often gets thrown around in the dark inner circles of the reinforcement learning community. However, for those that are not familiar with contrastive learning, what does contrastive even mean? For those that are, how can reinforcement learning be contrastive? Throughout this blog post, we will answer these questions and many more.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>438</fr:anchor><fr:addr
type="user">kak-0009</fr:addr><fr:route>kak-0009.xml</fr:route><fr:title
text="Contrastive Learning">Contrastive Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Prior to understanding contrastive reinforcement learning, it is important to have an at least rudimentary understanding of contrastive learning. Historically, contrastive learning has been used to learn representations. The fundamental idea behind contrastive learning is to encourage the representations of similar outputs to be similar in representation space.</fr:p><fr:p><fr:strong>Supervised setting:</fr:strong> For now, assume we are in the supervised setting (we have access to lables). Suppose that we are learning a representation in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Our model is a classifier on dogs and cats. If we have two dogs <fr:tex
display="inline"><![CDATA[y_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y_2]]></fr:tex> then we want the learned representation map <fr:tex
display="block"><![CDATA[\phi : \{\text {dogs}, \text {cats}\} \to  \mathbb {R}^d]]></fr:tex> to be such that <fr:tex
display="inline"><![CDATA[\phi (y_1)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\phi (y_2)]]></fr:tex> are "close" in <fr:tex
display="inline"><![CDATA[\mathbb {R}^d]]></fr:tex>. Now the notion of "close" is to be determined by the user. An example could be to minimize the inner product between their representation maps i.e. we could learn a feature map parametrized by <fr:tex
display="inline"><![CDATA[\theta ]]></fr:tex> with the following objective <fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle .]]></fr:tex> Similarly, we want dissimilar outputs to be far apart in representation space. If <fr:tex
display="inline"><![CDATA[y_3]]></fr:tex> is a cat, then we can introduce a regularization to encourage this i.e.
<fr:tex
display="block"><![CDATA[\max _{\theta }\ \langle  \phi _{\theta }(y_1), \phi _{\theta }(y_2) \rangle  - \sum _{i \in  \{1, 2\}} \langle  \phi _{\theta }(y_i), \phi _{\theta }(y_3) \rangle .]]></fr:tex></fr:p><fr:p><fr:strong>Unsupervised setting:</fr:strong> Now suppose that we get rid of labels and are just given <fr:tex
display="inline"><![CDATA[n]]></fr:tex> dog samples <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> from some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {D}}]]></fr:tex>. We now want to be able to learn <fr:tex
display="inline"><![CDATA[p_{\theta }]]></fr:tex> to somehow estimate this distribution. An approach is to learn to distinguish the sample dogs given from random noise. To do so, we generate <fr:tex
display="inline"><![CDATA[n]]></fr:tex> random images <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> according to some distribution <fr:tex
display="inline"><![CDATA[p_{\mathcal {R}}]]></fr:tex>. We can now return to the supervised learning setting, where we treat <fr:tex
display="inline"><![CDATA[\mathcal {D}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex> as two classes. If we recall standard supervised learning practice, given a sample <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we then want to find <fr:tex
display="block"><![CDATA[p(\mathcal {D} \mid  x) = 1 - p(\mathcal {R} \mid  X).]]></fr:tex> 
As an explicit example, we will use logistic regression. Namely, we will model <fr:tex
display="inline"><![CDATA[p(x) = p(\mathcal {D} \mid  x)]]></fr:tex> as <fr:tex
display="block"><![CDATA[p_{\theta }(x) = \frac {1}{1 + e^{-G_{\theta }(x)}}.]]></fr:tex> However, <fr:tex
display="inline"><![CDATA[p_{\theta }(x)]]></fr:tex> is estimating <fr:tex
display="inline"><![CDATA[p(\mathcal {D} \mid  x)]]></fr:tex>, where we care about <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex>. To estimate the correct quantity, we need to leverage our knowledge of the noise distribution. Recall that if <fr:tex
display="inline"><![CDATA[p_{\theta }(x) = p(\mathcal {D} \mid  x)]]></fr:tex> then <fr:tex
display="inline"><![CDATA[G_{\theta }(x) = \log  \frac {p(x \mid  \mathcal {D})}{p(x \mid  \mathcal {R})}]]></fr:tex>. Since we generated the samples from <fr:tex
display="inline"><![CDATA[\mathcal {R}]]></fr:tex>, we have the explicit distribution i.e. <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {R}) = p_{\mathcal {R}}(x)]]></fr:tex>. Therefore, we can restrict <fr:tex
display="inline"><![CDATA[G_{\theta }]]></fr:tex> to explicitly learn <fr:tex
display="inline"><![CDATA[p(x \mid  \mathcal {D})]]></fr:tex> by considering <fr:tex
display="block"><![CDATA[G_{\theta }(x) = \log  p_{\theta }(x \mid  \mathcal {D}) - \log  p_{\mathcal {R}}(x),]]></fr:tex> considering the cross entropy loss we get the <fr:link
type="external"
href="nce">NCE loss</fr:link></fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>439</fr:anchor><fr:addr
type="user">kak-000E</fr:addr><fr:route>kak-000E.xml</fr:route><fr:title
text="NCE loss">NCE loss</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="external"
href="nce">NCE</fr:link></fr:em> loss aims to minimize the following objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \sum _{t} \log  \left [h(x_t; \theta )\right ] + \log \left [1 - h(y_t; \theta )\right ],]]></fr:tex> where <fr:tex
display="inline"><![CDATA[x_t]]></fr:tex> are samples from the data distribution and <fr:tex
display="inline"><![CDATA[y_t]]></fr:tex> are randomly generated samples and <fr:tex
display="block"><![CDATA[\begin {array}{r c l}{{h({\bf  u};\theta )}}&{{=}}&{{\frac {1}{1+\exp \left [-G({\bf  u};\theta )\right ]},}}\\ {{G({\bf  u};\theta )}}&{{=}}&{{\ln  p_{m}({\bf  u};\theta )-\ln  p_{n}({\bf  u}).}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>In <fr:link
type="local"
href="gutmann2012.xml"
addr="gutmann2012"
title="Noise-contrastive Estimation">Noise-contrastive Estimation</fr:link>, they show under mild conditions that the estimator <fr:tex
display="inline"><![CDATA[p_{\theta }(x \mid  D) \to  p_{\mathcal {D}}(x)]]></fr:tex> in probability as the number of samples in the loss goes to infinity. Equivalently, the estimator is <fr:link
type="local"
href="kak-000F.xml"
addr="kak-000F"
title="Consistent estimator">consistent</fr:link>.</fr:p><fr:p><fr:strong>Time series:</fr:strong> Before we get to contrastive RL, it is a natural question to wonder how does this apply to temporal sequences? Concretely, we want to make predictions about the future given the current "context". However, we want to do so in an unsupervised way, meaning we are only given trajectories not a notion of what it means for a trajectory to be good. Naively, one can try to do this in a supervised manner. For a <fr:tex
display="inline"><![CDATA[k]]></fr:tex> step prediction, this would just be your model predicting what will happen in <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps then seeing if it matches what occured <fr:tex
display="inline"><![CDATA[k]]></fr:tex> steps in the future in the sample trajectory. However, if your sample space <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is very high-dimensional, modeling this relationship can require an exorbinant amount of trajectories.</fr:p><fr:p>Fast forwarding to contrastive RL, current work is primarily considered with a particular contrastive objective.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>440</fr:anchor><fr:addr
type="user">kak-000B</fr:addr><fr:route>kak-000B.xml</fr:route><fr:title
text="InfoNCE">InfoNCE</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em><fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">InfoNCE</fr:link></fr:em> loss aims to minimize the following information-theoretic objective <fr:tex
display="block"><![CDATA[\mathcal {L}_{N} = - \mathbb {E}_{\mathcal {X}} \left [\log  \frac {f_k(x_{t + k}, c_t)}{\sum _{x_j \in  \mathcal {X}} f_k(x_j, c_t)}\right ]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:p>Now we need to unpack this very ominous loss. To start, what are <fr:tex
display="inline"><![CDATA[x_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>?</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>441</fr:anchor><fr:addr
type="user">kak-000C</fr:addr><fr:route>kak-000C.xml</fr:route><fr:title
text="Maximize Mutual info">Maximize Mutual info</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\mathcal {L}_N]]></fr:tex> from <fr:link
type="local"
href="vandenOord2018.xml"
addr="vandenOord2018"
title="Contrastive Predictive Decoding">Contrastive Predictive Decoding</fr:link> maximizes a lower bound on the <fr:link
type="local"
href="kak-000V.xml"
addr="kak-000V"
title="Mutual Information">Mutual Information</fr:link> between <fr:tex
display="inline"><![CDATA[x_{t + k}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_t]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>442</fr:anchor><fr:addr
type="machine">#377</fr:addr><fr:route>unstable-377.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>All we must do is plug <fr:tex
display="inline"><![CDATA[\frac {p(x \mid  c)}{p(x)}]]></fr:tex> back into the objective.
  <fr:tex
display="block"><![CDATA[\begin {align*}     \mathcal {L}_{\mathbb {N}}^{\text {opt}}&=-\,\mathbb {E}\log \left [\frac {\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}}{\frac {p(x_{t+k}|c_{t})}{p(x_{t+k})}+\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}\sum _{x_{j}\in  X_{\text {neg}}}\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &\approx \mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k}|c_{t})}(N-1)\,\mathbb {E}\,\frac {p(x_{j}|c_{t})}{p(x_{j})}\right ] \\     &=\mathbb {E}\log \left [1+\frac {p(x_{t+k})}{p(x_{t+k} \mid  c_t)}N\right ] \\     &\geq  \mathbb {E} \log  \left [\frac {p(x_{t + k})}{p(x_{t + k} \mid  c_t)}N \right ] \\     &= - I(x_{t + k}, c_t) + \log  N  \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree><fr:tex
display="block"><![CDATA[ \operatorname *{max}_{f(u,v)}\mathbb {E}_{(u,v^{+})\sim  p(u,v)}\left [\log \sigma (\underbrace {f(u,{\green  v^{+}})}_{\phi (u)^{T}\psi ({\green  v^{+}})})+\log (1-\sigma (\underbrace {f(u,{\red  v^{-}})}_{\phi (u)^{T}\psi ({\red  v^{-}})}))\right ] ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} &\operatorname *{max}_{f}\mathbb {E}_{(s,a)\sim  p(s,a),s_{f}^{-}\sim  p(s_{f})}\left [\mathcal {L}(s,a,s_{f}^{+},s_{f}^{-})\right ] \\ \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}_1(\theta ) = \log \sigma (f_{\theta }(s_1,a_1,{\color {green} s_{8}})) + \log (1-\sigma (f_{\theta }(s_1,a_1, {\color {red} s_3}))) ]]></fr:tex><fr:tex
display="block"><![CDATA[ \begin {align*} \widehat {\mathcal {L}}(\theta ) &= \frac {1}{n} \sum _{i = 1}^{n} \mathcal {L}_i \\ &= \frac {1}{n} \sum _{i = 1}^{n} \Big [\log \sigma (f_{\theta }(s_i,a_i,{\color {green} s_{f}^{+}})) + \log (1-\sigma (f_{\theta }(s_i,a_i, {\color {red} s_{f}^{-}})))\Big ] \end {align*} ]]></fr:tex><fr:tex
display="block"><![CDATA[ \mathcal {L}(\theta ) = \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] ]]></fr:tex><fr:tex
display="block"><![CDATA[f^*(s, a, s_g) = \log \left (\frac {p^{\pi (\cdot  \mid  \cdot )}(s_g \mid  s, a)}{p(s_g)}\right )]]></fr:tex>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>443</fr:anchor><fr:addr
type="machine">#378</fr:addr><fr:route>unstable-378.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We want to maximize
<fr:tex
display="block"><![CDATA[     \begin {align*} \mathcal {L}(\theta ) &= \mathbb {E}_{x \sim  p_X, y \sim  p_Y}\Big [\log \sigma (f_{\theta }(x)) + \log (1-\sigma (f_{\theta }(y)))\Big ] \\ &= \int  \log \sigma (f_{\theta }(x)) P_X(x) + \int  \log (1-\sigma (f_{\theta }(y))) P_Y(y) \\ &= \int  \log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)     \end {align*}     ]]></fr:tex>
    Since we are maximizing <fr:tex
display="inline"><![CDATA[f(s)]]></fr:tex>, we can just maximize the integrand i.e.
<fr:tex
display="block"><![CDATA[       \begin {align*}         \frac {\mathrm {d}}{\mathrm {d}f(z)} \Big [\log \sigma (f_{\theta }(z)) P_X(z) + \log (1-\sigma (f_{\theta }(z))) P_Y(z)\Big ] = 0       \end {align*}     ]]></fr:tex>
    Solving,
    <fr:tex
display="block"><![CDATA[         \begin {align*}           P_X(z)\big (1 - \sigma (f(z))\big ) - P_Y(z)\sigma (f(z)) = 0 &\iff  \sigma (f(z)) = \frac {P_X(z)}{P_X(z) + P_Y(z)} \\           &\iff  f(z) = \log \left (\frac {P_X(z)}{P_Y(z)}\right )         \end {align*}       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>444</fr:anchor><fr:addr
type="machine">#379</fr:addr><fr:route>unstable-379.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>31</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
The first step is to prove that the average Q-values are close to the task-conditioned Q-values. Below, we will use <fr:tex
display="inline"><![CDATA[R_{c}(\tau )\triangleq \sum _{\ell =0}^{\infty }\gamma ^{\ell }r_{\ell }(s_{\ell },a_{\ell })]]></fr:tex>:

<fr:tex
display="block"><![CDATA[ \begin {align*} \left |Q^{\beta (\cdot |\cdot ,a)}(s,a,e)-Q^{\beta (\cdot |\cdot ,\epsilon ^{\prime })}(s,a,e)\right |&=\left |\int \beta (\tau \mid  s,a,e)R_{e}(\tau )d\tau -\int \beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right |\\  &=\left |\int \beta (\tau \mid  s,a,e)-\beta (\tau \mid  s,a,e^{\prime })R_{e}(\tau )d\tau \right | \\ &=\left |\int \beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )R_{e}(\tau )d\tau \right | \\ &\leq \int \left |\beta (\tau \mid  s,a,e)\left (1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right )\right |d\tau \cdot \operatorname *{max}_{\tau }|R_{e}(\tau )d\tau | \\ &\leq \int \beta (\tau \mid  s,a,e)\left |1-\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}\right |d\tau \cdot  1 \\ &=\mathbb {E}_{\beta (\tau |s,a,e)}\left [\left |1-{\frac {\beta (\tau \mid  s,a,e^{\prime })}{\beta (\tau \mid  s,a,e)}}\right |\right ] \\ &\leq  \epsilon . \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>445</fr:anchor><fr:addr
type="user">kak-005F</fr:addr><fr:route>kak-005F.xml</fr:route><fr:title
text="Rebuilding My (Neo)Vim Config From Scratch">Rebuilding My (Neo)Vim Config From Scratch</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>I have been using LazyVim for some time now, but I have now run into issues multiple times where understanding how LazyVim is doing something is far more difficult than if I had written my own setup. I allocated one day for this adventure and really just wanted to make sure I had support for <fr:tex
display="inline"><![CDATA[\TeX ]]></fr:tex>, python, forester, and C/C++. Due to my (self-imposed) time constraint, I do not have the associated resources linked for each of the things discussed below. At some point, I hope to come back and more thoroughly cover each of the components.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>419</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:title
text="Sane Defaults">Sane Defaults</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
To my surprise, a lot of the features that I had come to take for granted were actually options set up internally by Lazyvim. For example, I was shocked with 8 space indents!! and I could not even copy from one terminal instance to another... Due to this, I went and found all of the options I liked from Lazyvim and added them to my new configuration in <fr:code>configs/options.lua</fr:code>.
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>420</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:title
text="Installing a Plugin Manager">Installing a Plugin Manager</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
For this, we will be using the defacto standard <fr:code>lazy.nvim</fr:code>. This is actually straightforward and kind of "just works". Just follow the installation guide in their documentation.
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>421</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:title
text="Setting up Auto Complete">Setting up Auto Complete</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
This is one of the main motivations for me making the switch. It seems <fr:code>nvim-cmp</fr:code> has finally been replaced with a new <fr:code>blink.cmp</fr:code>, so that is what we will be using.


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>422</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:title
text="Language Server Protocol">Language Server Protocol</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
It turns out there is a lot that goes into getting LSP setup correctly.
<fr:ol><fr:li>First we must actually install the language servers. To do this the easiest way, we use the <fr:code>mason.nvim</fr:code> and <fr:code>mason.nvim-lspconfig</fr:code> plugins. At some point, I might actually figure out how to set up lsp myself without lspconfig but that point is not now.</fr:li>
<fr:li>Through <fr:code>nvim-lspconfig</fr:code>, we can set up each of the servers we want to have LSP support. I just set up clangd, pyright, and texlab.</fr:li></fr:ol>
This was a bit ridiculous. The first of many challenges was around import resolution in python. To remedy this, I needed to write a function to find the virtual environment directory and then set the <fr:code>pythonPath</fr:code> to the venv python binary. Previously, I think I was just using pylsp and installing it as a pip package to each python venv. I much prefer the new way, and I think pyright is overall a much better lsp.
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>423</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:title
text="Forester Completion">Forester Completion</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Another necessary completion source for me is the one provided by <fr:code>forester.nvim</fr:code>. Similar to vimtex, the reference completion support is VERY useful. Obviously, I need completion when I am writing this blog!!! This was a little more involved. The first difficulty was that the completion source provided by the <fr:code>forester.nvim</fr:code> plugin was for <fr:code>nvim-cmp</fr:code>. It turns out this is a prevalent enough problem that the author of <fr:code>blink.cmp</fr:code> wrote an additional plugin <fr:code>blink.compat</fr:code> to allow for <fr:code>nvim-cmp</fr:code> completion sources. While this sounds all fine and good, <fr:code>nvim-compat</fr:code> expects plugins that return the completion source themselves, whereas in <fr:code>forester.nvim</fr:code> the completion source is just one submodule of a more feature-rich plugin. To get around this, I needed to look into the <fr:code>blink.compat</fr:code> code and find how they are registering the sources and just do it myself.
</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>424</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:title
text="Snippets">Snippets</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>Going all the way back to the <fr:link
type="external"
href="https://castel.dev/post/lecture-notes-1/">Gilles Castel blog post</fr:link>, I have always been partial to snippets that auto-expand. I had them set up prior to Lazyvim but with Lazyvim I had resigned to using friendly-snippets with native nvim snippets. Since I was already redoing everything, this time around I decided not to compromise. Once upon a time (right when it came out I think?) I tried out Luasnips, but it seems that they now have far more extensive features. They are also natively supported by <fr:code>blink.cmp</fr:code>!! It feels necessary that I plug the <fr:link
type="external"
href="https://github.com/iurimateus/luasnip-latex-snippets.nvim">awesome repo</fr:link> that ports the original Ultisnips snippets to Luasnip. With this, I was able to easily add my own forester snippets!!!</fr:p>
  <fr:p>A fun little thing that I had been hoping to do for awhile and is finally now possible - I can load latex snippets when inside math environments in forester!!!!</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>425</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:title
text="Treesitter">Treesitter</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>426</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:title
text="Formatters and Linters">Formatters and Linters</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>4</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:code>compat.nvim</fr:code>, <fr:code>mason.nvim</fr:code>, black, isort.
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>446</fr:anchor><fr:addr
type="user">loading</fr:addr><fr:route>loading.xml</fr:route><fr:title
text="Coming Soon!!!">Coming Soon!!!</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>448</fr:anchor><fr:addr
type="user">kak-005D</fr:addr><fr:route>kak-005D.xml</fr:route><fr:title
text="Optimization from a Deep Learning Perspective">Optimization from a Deep Learning Perspective</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>450</fr:anchor><fr:addr
type="user">kak-004X</fr:addr><fr:route>kak-004X.xml</fr:route><fr:title
text="A Note on Advantage Estimation">A Note on Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>452</fr:anchor><fr:addr
type="machine">#267</fr:addr><fr:route>unstable-267.xml</fr:route><fr:title
text="What is it?">What is it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>454</fr:anchor><fr:addr
type="machine">#268</fr:addr><fr:route>unstable-268.xml</fr:route><fr:title
text="Why do we do it?">Why do we do it?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>456</fr:anchor><fr:addr
type="machine">#269</fr:addr><fr:route>unstable-269.xml</fr:route><fr:title
text="Generalized Advantage Estimation">Generalized Advantage Estimation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>4</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>458</fr:anchor><fr:addr
type="user">kak-003Y</fr:addr><fr:route>kak-003Y.xml</fr:route><fr:title
text="The History and Evolution of Policy Gradient Algorithms">The History and Evolution of Policy Gradient Algorithms</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Rough itinerary,
  <fr:ul><fr:li>Vanilla policy gradient
      <fr:ul><fr:li>Policy gradient theorem + proof</fr:li>
          <fr:li>Deterministic policy gradient theorem + (maybe)proof</fr:li></fr:ul></fr:li>
      <fr:li>Actor critic method
      <fr:ul><fr:li>A2C: Variance reduction method</fr:li>
        <fr:li>(Maybe) A3C: Asynchronous update</fr:li></fr:ul></fr:li>
      <fr:li>Trust region policy optimization</fr:li>
      <fr:li>Soft Actor Critic</fr:li>
      <fr:li><fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">Proximal Policy Optimization</fr:link></fr:li>
      <fr:li><fr:link
type="local"
href="kak-003X.xml"
addr="kak-003X"
title="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:link></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>460</fr:anchor><fr:addr
type="user">kak-003D</fr:addr><fr:route>kak-003D.xml</fr:route><fr:title
text="Deepseek v1 through R1: RL is back!">Deepseek v1 through R1: RL is back!</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In this blog, we will aim to understand the key contributions of <fr:link
type="local"
href="deepseekai2025deepseekr1incentivizingreasoningcapability.xml"
addr="deepseekai2025deepseekr1incentivizingreasoningcapability"
title="DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning">DeepSeek-R1: Incentivizing reasoning capability in LLMs via reinforcement learning</fr:link>. It will serve as the complement to my group meeting presentation possibly consisting of more in-depth explanations. Time permitting, we might go over the engineering innovations introduced in <fr:link
type="local"
href="deepseekai2024deepseekv3technicalreport.xml"
addr="deepseekai2024deepseekv3technicalreport"
title="DeepSeek-V3 technical report">DeepSeek-V3 technical report</fr:link>.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>462</fr:anchor><fr:addr
type="machine">#302</fr:addr><fr:route>unstable-302.xml</fr:route><fr:title
text="Background">Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    By request of my advisor, I will cover the basics of LLMs prior to the innovations in the Deepseek lineage. For those familiar with LLMs, please skip this section.
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>464</fr:anchor><fr:addr
type="user">kak-004J</fr:addr><fr:route>kak-004J.xml</fr:route><fr:title
text="Word Embeddings">Word Embeddings</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tex
display="block"><![CDATA[\mathrm {Tok}(\mathbf {x})=\begin {bmatrix} 132\\ 17 \\ 87\\ 83\\ 184\end {bmatrix}]]></fr:tex></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>465</fr:anchor><fr:addr
type="user">kak-004G</fr:addr><fr:route>kak-004G.xml</fr:route><fr:title
text="Self-Attention">Self-Attention</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>TLDR: Learned weighting of token embeddings. Essentially, learning which words to "attend" to in the input sequence. Have matrices
<fr:tex
display="inline"><![CDATA[\mathbf {Q} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {q}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {q}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_q}]]></fr:tex>, 
<fr:tex
display="inline"><![CDATA[ \mathbf {K} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {k}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {k}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_k} ]]></fr:tex>
<fr:tex
display="inline"><![CDATA[ \mathbf {V} = \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \vdots  \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(n)} & \text {---}   \end {bmatrix} \end {bmatrix} \in  \mathbb {R}^{n \times  d_v} ]]></fr:tex></fr:p><fr:p><fr:strong>Intuition 1:</fr:strong> Convex re-weighting of input tokens.
  Note that
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_1 & p_2 & p_3   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} = p_1 \mathbf {v}^{(1)} + p_2 \mathbf {v}^{(2)} + p_3 \mathbf {v}^{(3)} \end {align*}   ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*}   \begin {bmatrix}     p_{11} & 0 & 0 \\     p_{21} & p_{22} & 0 \\     p_{31} & p_{32} & p_{33}   \end {bmatrix} \begin {bmatrix}   \begin {bmatrix}     \text {---} & \mathbf {v}^{(1)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(2)} & \text {---}   \end {bmatrix} \\   \begin {bmatrix}     \text {---} & \mathbf {v}^{(3)} & \text {---}   \end {bmatrix}   \end {bmatrix} =    \begin {bmatrix}   p_{11} \mathbf {v}^{(1)}  \\   p_{21} \mathbf {v}^{(1)} + p_{22} \mathbf {v}^{(2)} \\   p_{31} \mathbf {v}^{(1)} + p_{32} \mathbf {v}^{(2)} + p_{33} \mathbf {v}^{(3)}   \end {bmatrix} \end {align*}   ]]></fr:tex>
  <fr:strong>Intuition 2:</fr:strong> Context dependent re-weighting.
      If <fr:tex
display="inline"><![CDATA[\mathbf {p} = \mathbb {S}(\mathbf {Q} \mathbf {K}^T)]]></fr:tex> then
      <fr:tex
display="block"><![CDATA[         \begin {align*}           p_{ij} = \frac {\mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}{\sum _{j} \mathbf {q}^{(i)} \cdot  \mathbf {k}^{(j)}}         \end {align*}       ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>467</fr:anchor><fr:addr
type="machine">#274</fr:addr><fr:route>unstable-274.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Suppose that <fr:tex
display="inline"><![CDATA[\mathbf {x} = \text {I play with the ball}]]></fr:tex>. Then 
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``ball"})     \end {align*}   ]]></fr:tex>
  A feasible query for "ball" would be a verb describing the action of the ball, so maybe
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_q \mathbf {x}^{(5)} = \mathrm {Embed}(\text {``play"})   \end {align*}   ]]></fr:tex>
  and a key for "play" would be what you are playing with like a ball, so 
  <fr:tex
display="block"><![CDATA[   \begin {align*}       W_k \mathbf {x}^{(2)} = \mathrm {Embed}(\text {``ball"})   \end {align*}   ]]></fr:tex>
  i.e.
<fr:tex
display="block"><![CDATA[   \begin {align*}     \mathrm {Query}(\text {``quantum"}) \cdot  \mathrm {Key}(\text {``mechanics"}) \approx      ||\mathrm {Query}(\text {``quantum"})|| \cdot  ||\mathrm {Key}(\text {``mechanics"})||   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
 
<fr:p><fr:tex
display="block"><![CDATA[   \begin {align*} \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} &= \mathbb {S}\left (\begin {bmatrix} \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(1)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(2)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(3)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(4)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(5)} & \mathbf {q}^{(4)} \cdot  \mathbf {k}^{(6)} \end {bmatrix} \right ) \\ &= \begin {bmatrix} 0 & 0.2 & 0.3 & 0.5 & 0 & 0 \end {bmatrix}   \end {align*} ]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \left [\mathbb {S}(\mathbf {Q}\mathbf {K}^T)\right ]_{4} \mathbf {V} = 0.2 \mathbf {v}^{(2)} + 0.3 \mathbf {v}^{(3)} + 0.5 \mathbf {v}^{(5)} ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>469</fr:anchor><fr:addr
type="machine">#301</fr:addr><fr:route>unstable-301.xml</fr:route><fr:title
text="RLHF">RLHF</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tex
display="block"><![CDATA[\mathrm {loss}\left (\phi \right )=E_{\left (x,y\right )\sim  D_{\pi _{\phi }^{\mathrm {RL}}}}\left [r_\theta (x,y)-\beta \log \left (\pi _{\phi }^{\mathrm {RL}}(y\mid  x)/\pi ^{\mathrm {SFT}}(y\mid  x)\right )\right ] + \gamma  E_{x\sim  D_{\mathrm {pretrain}}}\left [\log (\pi _{\phi }^{\mathrm {RL}}(x))\right ]]]></fr:tex>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>471</fr:anchor><fr:addr
type="machine">#303</fr:addr><fr:route>unstable-303.xml</fr:route><fr:title
text="Deepseek v2">Deepseek v2</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Paper 
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>473</fr:anchor><fr:addr
type="machine">#304</fr:addr><fr:route>unstable-304.xml</fr:route><fr:title
text="Deepseek v3">Deepseek v3</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
TODO. Kinda wanna look into the architectural / training innovations from this paper.
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>475</fr:anchor><fr:addr
type="machine">#308</fr:addr><fr:route>unstable-308.xml</fr:route><fr:title
text="Deepseek R1">Deepseek R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>477</fr:anchor><fr:addr
type="machine">#305</fr:addr><fr:route>unstable-305.xml</fr:route><fr:title
text="How is R1 different then previous iterations of models?">How is R1 different then previous iterations of models?</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>In R1-Zero, they do <fr:strong>ZERO</fr:strong> SFT on the base model - directly apply reinforcement learning.</fr:li>
    <fr:li>Use PPO like policy optimization but do <fr:strong>NOT</fr:strong> learn a reward model.</fr:li>
    <fr:ul><fr:li>Use very simple reward: 
        <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[+1]]></fr:tex> for correct answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-0.5]]></fr:tex> for incorrect answer</fr:li> 
          <fr:li><fr:tex
display="inline"><![CDATA[-1]]></fr:tex> for inability to answer.</fr:li></fr:ul></fr:li></fr:ul></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>479</fr:anchor><fr:addr
type="user">kak-003X</fr:addr><fr:route>kak-003X.xml</fr:route><fr:title
text="Group Relative Policy Optimization">Group Relative Policy Optimization</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Traditional actor critic RL algorithms, require training both an actor and a critic (as the name implies). Typically, these components are both of equal size. In the field of RL, this is non-problematic because models are typically rather small (at least in comparison to LLMs).
In <fr:link
type="local"
href="shao2024deepseekmathpushinglimitsmathematical.xml"
addr="shao2024deepseekmathpushinglimitsmathematical"
title="DeepSeekMath: Pushing the limits of mathematical reasoning in open language models">DeepSeekMath: Pushing the limits of mathematical reasoning in open language models</fr:link></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>480</fr:anchor><fr:addr
type="machine">#298</fr:addr><fr:route>unstable-298.xml</fr:route><fr:title
text="Math">Math</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tex
display="block"><![CDATA[     \begin {align*}     {\mathcal {J}}_{\mathrm {GRPO}}(\theta )&= \mathbb {E}[q\sim  P(Q),\{o_{i}\}_{i=1}^{G}\sim \pi _{\theta _{o l d}}(O|q)] \\     &= \frac {1}{G}\sum _{i=1}^{G}\left (\operatorname *{min}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d}}(o_{i}|q)}A_{i},\operatorname *{clip}\left (\frac {\pi _{\theta }(o_{i}|q)}{\pi _{\theta _{o d d}}(o_{i}|q)},1-\varepsilon ,1+\varepsilon \right )A_{i}\right )-\beta \mathbb {D}_{K L}\left (\pi _{\theta }||\pi _{r e f}\right )\right )     \end {align*}   ]]></fr:tex>
  where
  <fr:tex
display="block"><![CDATA[         \mathbb {D}_{\mathrm {K L}}\left (\pi _{\theta }||\pi _{\mathrm {ref}}\right )=\frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-\log \frac {\pi _{\mathrm {ref}}(o_{i}|q)}{\pi _{\theta }(o_{i}|q)}-1     ]]></fr:tex>
    The astute RL reader will notice this is essentially <fr:link
type="local"
href="schulman2017proximalpolicyoptimizationalgorithms.xml"
addr="schulman2017proximalpolicyoptimizationalgorithms"
title="Proximal policy optimization algorithms">PPO</fr:link>.
    The key distinction here is that the advantage <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> is not computed using a critic model. Instead, 
<fr:tex
display="block"><![CDATA[A_{i}=\frac {r_{i}-\mathrm {mean}(\{r_{1},r_{2},\cdots ,r_{G}\})}{\mathrm {std}(\{r_{1},r_{2},\cdots ,r_{G}\})}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree>


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>481</fr:anchor><fr:addr
type="machine">#306</fr:addr><fr:route>unstable-306.xml</fr:route><fr:title
text="Post-training">Post-training</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:em>Reinforcement Learning for all Scenarios:</fr:em> Seems like they do RLHF after the pure RL stage.</fr:li>
        <fr:ul><fr:li>Do traditional helpfulness harmfulness RLHF with trained reward model.</fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>483</fr:anchor><fr:addr
type="machine">#307</fr:addr><fr:route>unstable-307.xml</fr:route><fr:title
text="Distilling Models with R1">Distilling Models with R1</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>To distill, they do only SFT with R1 generated COT.</fr:li>
      <fr:li>They show that distillation outperforms doing pure RL approach on smaller model</fr:li>
      <fr:ul><fr:li>Seems contradictory to <fr:link
type="local"
href="zeng2025simplerl.xml"
addr="zeng2025simplerl"
title="7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient">7B model and 8K examples: Emerging reasoning with reinforcement learning is both effective and efficient</fr:link></fr:li></fr:ul></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<html:script
xmlns:html="http://www.w3.org/1999/xhtml"
src="https://utteranc.es/client.js"
repo="kkanarios32/website-comments"
issue-term="pathname"
theme="boxy-light"
crossorigin="anonymous"
async="" /></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2316</fr:anchor><fr:addr
type="user">kak-0015</fr:addr><fr:route>kak-0015.xml</fr:route><fr:title
text="Learning">Learning</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>25</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Here are things I am actively learning / working on before they become a more complete set of <fr:link
type="local"
href="kak-0003.xml"
addr="kak-0003"
title="Notes">Notes</fr:link>.</fr:p><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2288</fr:anchor><fr:addr
type="user">kak-0012</fr:addr><fr:route>kak-0012.xml</fr:route><fr:title
text="Notes on Reinforcement Learning: An Introduction">Notes on <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This won't really be notes, my lab has begun taking a few undergrads who are not familiar with RL. I will be onboarding them by going through <fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">Reinforcement Learning: An Introduction</fr:link>. Specifically, I will be following the <fr:link
type="local"
href="richardsutton.xml"
addr="richardsutton"
title="Richard Sutton">Richard Sutton</fr:link> flavor of RL through his <fr:link
type="external"
href="https://drive.google.com/drive/folders/0B3w765rOKuKANmxNbXdwaE1YU1k?resourcekey=0-JZz-noRuJgogNsg1ljgV8w">CMPUT 609</fr:link> course. You know what the say: the best way to learn is to teach! Here, I will try to solve all the problems as we go and prepare some questions for the undergrads for when we meet. Additionally, I will document my foray into more advanced exploration of topics introduced in the textbook.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1778</fr:anchor><fr:addr
type="machine">#344</fr:addr><fr:route>unstable-344.xml</fr:route><fr:title
text="Multi-armed Bandits">Multi-armed Bandits</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1780</fr:anchor><fr:addr
type="machine">#336</fr:addr><fr:route>unstable-336.xml</fr:route><fr:title
text=" [sutton2022, 2.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the case of two actions, (assuming that <fr:tex
display="inline"><![CDATA[Q_*(a_1) > Q_*(a_2)]]></fr:tex>) the probability of the greedy action being selected is <fr:tex
display="inline"><![CDATA[1 - \epsilon ]]></fr:tex> or 0.5.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1782</fr:anchor><fr:addr
type="machine">#337</fr:addr><fr:route>unstable-337.xml</fr:route><fr:title
text=" [sutton2022, 2.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the long run <fr:tex
display="inline"><![CDATA[\epsilon  = 0.01]]></fr:tex>, would achieve the highest reward. The expected reward can be written as
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* = \max _{a} q^*(a) + \frac {\epsilon }{n}\sum _{i \neq  a}^{n} q^*(i)     \end {align*}   ]]></fr:tex>
  The exception is that if <fr:tex
display="inline"><![CDATA[\epsilon  = 0]]></fr:tex>, then there are no guarantees. For example, if your initialization is zeros. Then you could have an empirical average of a suboptimal arm that is always positive and you would never deviate. Thus, to ensure you converge to the true optimal arm you need <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1784</fr:anchor><fr:addr
type="machine">#338</fr:addr><fr:route>unstable-338.xml</fr:route><fr:title
text=" [sutton2022, 2.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  TODO

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1786</fr:anchor><fr:addr
type="machine">#339</fr:addr><fr:route>unstable-339.xml</fr:route><fr:title
text=" [sutton2022, 2.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Following the steps in 2.6,
  <fr:tex
display="block"><![CDATA[       \begin {align*}         Q_{n + 1} &= Q_n + \alpha _n [R_n - Q_n] \\         &= Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}] + \alpha _n \Big [R_n - (Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}])\Big ] \\         &\vdots  \\         & = \left (\prod _{i = 1}^{n} (1 - \alpha _{i})\right ) Q_1 + \sum _{i = 1}^{n} \alpha _n \left (\prod _{i = 1}^{n} (1 - \alpha _{n - i})\right )R_i       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1788</fr:anchor><fr:addr
type="machine">#340</fr:addr><fr:route>unstable-340.xml</fr:route><fr:title
text=" [sutton2022, 2.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since all of the arms in the testbed have distributions with support less than 5, in the beginning the unpulled arm's optimistic estimates will be higher than the empirical estimates of the previously pulled arms. Therefore, in the early stages all of the arms will be pulled in a round robin fashion, and assuming deterministic rewards the optimal arm will keep being pulled until it falls below the other optimistic values.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1790</fr:anchor><fr:addr
type="machine">#341</fr:addr><fr:route>unstable-341.xml</fr:route><fr:title
text=" [sutton2022, 2.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Since there are 10 arms (presumably with the same initialization), the UCB bonus will enforce that the first 10 pulls are round robin (uniform) pulling of each of the 10 arms. Then on the 11th step each will have the same UCB bonus term but the one with the highest empirical reward will be pulled, leading to a spike. It then drops in subsequent steps because the UCB bonus of that arm will decrease and other (possibly less optimal) arms are pulled in subsequent steps.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1792</fr:anchor><fr:addr
type="machine">#342</fr:addr><fr:route>unstable-342.xml</fr:route><fr:title
text=" [sutton2022, 2.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We can just expand the denominator as
<fr:tex
display="block"><![CDATA[     \begin {align*}       \Pr \{A_t = a\} &= \frac {e^{H_t(a)}}{e^{H_t(a)} + e^{H_t(b)}} \\       &= \frac {1}{1 + e^{\frac {H_t(b)}{H_t(a)}}} \\       &= \frac {1}{1 + e^{-\frac {H_t(a)}{H_t(b)}}} \\     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1794</fr:anchor><fr:addr
type="machine">#343</fr:addr><fr:route>unstable-343.xml</fr:route><fr:title
text=" [sutton2022, 2.10]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="2.10"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 2.10]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In case 1, the best you can hope to achieve is <fr:tex
display="inline"><![CDATA[\max _{a} \mathbb {E} [R(a)]]]></fr:tex>. In this case, we have
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R(1)] &= 0.5 \cdot  10 + 0.5 \cdot  90 = 50, \\       \mathbb {E}[R(2)] &= 0.5 \cdot  20 + 0.5 \cdot  80 = 50     \end {align*}   ]]></fr:tex>
  Therefore, the best we can hope to achieve is <fr:tex
display="inline"><![CDATA[50]]></fr:tex>. If we are given what case we are in, then we can achieve
<fr:tex
display="block"><![CDATA[     \begin {align*}       R^* &= 0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 1] +       0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 2] \\       &= 0.5 \cdot  20 + 0.5 \cdot  90 \\       &= 55     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1796</fr:anchor><fr:addr
type="machine">#357</fr:addr><fr:route>unstable-357.xml</fr:route><fr:title
text="Markov Decision Processes">Markov Decision Processes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1798</fr:anchor><fr:addr
type="machine">#345</fr:addr><fr:route>unstable-345.xml</fr:route><fr:title
text=" [sutton2022, 3.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  I think you draw the line at where you can already execute the necessary behavior to get from one state to another. This is eerily familiar to the line of work known as hierarchical reinforcement learning, where you gradually learn higher level of abstraction by executing subpolicies.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1800</fr:anchor><fr:addr
type="machine">#346</fr:addr><fr:route>unstable-346.xml</fr:route><fr:title
text=" [sutton2022, 3.5]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.5"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.5]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  We need to add the notion of a terminal state. This can be done by just adding some <fr:tex
display="inline"><![CDATA[t]]></fr:tex> to the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex>. Then
  <fr:tex
display="block"><![CDATA[       \begin {cases}         p(t, 0 \mid  s, a) = 1, &\text { if } s = t\\         \sum _{s^{\prime }\in \mathcal {S}}\sum _{r\in \mathcal {R}}p(s^{\prime },r|s,a)=1,\mathrm {~for~all~}s\in \mathcal {S},a\in \mathcal {A}(s), &\text { if } s \neq  t       \end {cases} ]]></fr:tex>
I think the idea is just that when you hit a terminal state you no longer can reach other states.
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1802</fr:anchor><fr:addr
type="machine">#347</fr:addr><fr:route>unstable-347.xml</fr:route><fr:title
text=" [sutton2022, 3.6]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.6"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> denote the length of the episode. Then the return <fr:tex
display="inline"><![CDATA[G_t]]></fr:tex> would be 
<fr:tex
display="block"><![CDATA[   \begin {align*} G_t &= R_{t+1} + \gamma  R_{t + 2} + \cdots  + \gamma ^{T - {t + 1}} R_T = - \gamma ^{T - {t + 1}}   \end {align*} ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1804</fr:anchor><fr:addr
type="machine">#348</fr:addr><fr:route>unstable-348.xml</fr:route><fr:title
text=" [sutton2022, 3.7]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.7"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.7]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  You have not effectively communicated the task. The agent has no incentive to solve the maze as fast as possible. This means that no matter the duration it took to solve the task the agent would receive the same reward. To fix this, you can give -1 reward at each time step, or use a discount factor to capture the time.

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1806</fr:anchor><fr:addr
type="machine">#349</fr:addr><fr:route>unstable-349.xml</fr:route><fr:title
text=" [sutton2022, 3.8]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.8"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Due to the recursive relationship, we will start from the back
<fr:tex
display="block"><![CDATA[     \begin {align*}       G_5 &= 0 \\       G_4 &= R_{5} + \gamma  G_5 = 2 \\       G_3 &= R_{4} + \gamma  G_4 = 4 \\       G_2 &= R_{3} + \gamma  G_3 = 8 \\       G_1 &= R_{2} + \gamma  G_2 = 6 \\       G_0 &= R_{1} + \gamma  G_1 = 2     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1808</fr:anchor><fr:addr
type="machine">#350</fr:addr><fr:route>unstable-350.xml</fr:route><fr:title
text=" [sutton2022, 3.9]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.9"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
From the definition,
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_0 &= R_{1} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 2 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 2 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 2} \\ &= 2 + \frac {7 \gamma }{1 - \gamma } \\ &= 65 \end {align*} ]]></fr:tex>
and 
<fr:tex
display="block"><![CDATA[ \begin {align*}   G_1 &= R_{2} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\ &= 7 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\ &= 7 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 3} \\ &= 7 + \frac {7 \gamma }{1 - \gamma } \\ &= 70 \end {align*} ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1810</fr:anchor><fr:addr
type="machine">#351</fr:addr><fr:route>unstable-351.xml</fr:route><fr:title
text=" [sutton2022, 3.11]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.11"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.11]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  By just expanding,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {E}[R_{t + 1} \mid  S_{t} = s] = \sum _{a} \pi (a \mid  s) \sum _{s'} \sum _{r} p(s', r \mid  s, a) \cdot  r     \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1812</fr:anchor><fr:addr
type="machine">#352</fr:addr><fr:route>unstable-352.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  <fr:tex
display="block"><![CDATA[       \begin {align*}         v_{\pi }(s) &= \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)       \end {align*}     ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1814</fr:anchor><fr:addr
type="machine">#353</fr:addr><fr:route>unstable-353.xml</fr:route><fr:title
text=" [sutton2022, 3.12]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.12"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
<fr:tex
display="block"><![CDATA[ \begin {align*}   q_{\pi }(s, a) = \sum _{s', r} p(s', r \mid  s, a) \big (r + \gamma  v_{\pi }(s')\big ) \end {align*}   ]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  



  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1816</fr:anchor><fr:addr
type="machine">#354</fr:addr><fr:route>unstable-354.xml</fr:route><fr:title
text=" [sutton2022, 3.15]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.15"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.15]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Recall that 
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }(s) = \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1} \mid  S_t = s]     \end {align*}   ]]></fr:tex>
  Adding a constant <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{\pi }'(s) &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } \gamma ^{k} R_{t + k + 1} + c \mid  S_t = s] \\       &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1}\mid  S_t = s] + \sum _{k = 0}^{\infty } \gamma ^{k} c \\       &= v_{\pi }(s) + \frac {c}{1 - \gamma }     \end {align*}   ]]></fr:tex>
  Therefore, <fr:tex
display="inline"><![CDATA[v_c = \frac {c}{1 - \gamma }]]></fr:tex>.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1818</fr:anchor><fr:addr
type="machine">#355</fr:addr><fr:route>unstable-355.xml</fr:route><fr:title
text=" [sutton2022, 3.16]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.16"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.16]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  In the episodic case, this would not be the same. In the maze running example, <fr:tex
display="inline"><![CDATA[v_c]]></fr:tex> would be larger for longer episodes. This would then incentivize the agent to actually take LONGER, where as we want the agent to solve the maze as fast as possible.

</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1820</fr:anchor><fr:addr
type="machine">#356</fr:addr><fr:route>unstable-356.xml</fr:route><fr:title
text=" [sutton2022, 3.18]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.18"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 3.18]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  This is similar to exercise 3.12. Namely, 
<fr:tex
display="block"><![CDATA[v_{\pi }(s) = \mathbb {E}_{\pi }[q_{\pi }(s, a)] = \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)]]></fr:tex>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1822</fr:anchor><fr:addr
type="machine">#362</fr:addr><fr:route>unstable-362.xml</fr:route><fr:title
text="Dynamic Programming">Dynamic Programming</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1824</fr:anchor><fr:addr
type="machine">#358</fr:addr><fr:route>unstable-358.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:strong>Value Iteration as Linear Algebra:</fr:strong> During my brief stint at <fr:link
type="external"
href="https://www.ipam.ucla.edu/">IPAM</fr:link>, I spent a lot of time focused on <fr:link
type="local"
href="kanariosdas2023.xml"
addr="kanariosdas2023"
title="Parallel Algebraic Multigrid for Higher Order PDEs">solving large systems for discretized PDEs</fr:link>. From this, I learned about iterative methods, such as Gauss-Jacobi and Gauss-Seidel. Interestingly, these methods can be used to interpret some of RL's most fundamental algorithms. If we define the following matrices,
<fr:tex
display="block"><![CDATA[   \begin {align*}         R &= \begin {bmatrix}         \mathbb {E}[r(s = 1)]\\         \vdots  \\         \mathbb {E}[r(s = n)]         \end {bmatrix}, \quad  P = \begin {bmatrix}         P_{\pi }(s'=1 | s=1) & \cdots  & P_{\pi }(s'=n | s=1) \\         \vdots  & \ddots  & \vdots  \\         P_{\pi }(s'=1 | s=n) & \cdots  & P_{\pi }(s'=n | s=n)         \end {bmatrix}, \\           V_k &= \begin {bmatrix}         V_k(s = 1)\\         \vdots  \\         V_k(s = n)         \end {bmatrix}   \end {align*}       ]]></fr:tex>
      Then we can write the value function <fr:tex
display="inline"><![CDATA[V_{\pi }]]></fr:tex> as the solution to the linear system
      <fr:tex
display="block"><![CDATA[           V_{\pi } = R + PV_{\pi } \iff  V_{\pi } = (1 - P)^{-1} R         ]]></fr:tex>
    This is just inverting a matrix! Updating one state with the canonical update
<fr:tex
display="block"><![CDATA[     \begin {align*}       v_{k + 1}(s) = \sum _{a}\pi (a|s)\sum _{s^{\prime },r}p(s^{\prime },r\,|\,s,a)\Big [r+\gamma  v_{k}(s^{\prime })\Big ]     \end {align*} ]]></fr:tex>
Is actually just one iteration of Gauss-Seidel!
    </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1826</fr:anchor><fr:addr
type="machine">#359</fr:addr><fr:route>unstable-359.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>(Number of updates as pseudo discount factor). </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1828</fr:anchor><fr:addr
type="machine">#360</fr:addr><fr:route>unstable-360.xml</fr:route><fr:title
text=" [sutton2022, 4.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    We have that
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(11, \mathrm {down}) &= -1,       \end {align*}     ]]></fr:tex>
    where there is no recursion because the episode ends.
    Next,
<fr:tex
display="block"><![CDATA[       \begin {align*}         q_{\pi }(7, \mathrm {down}) &= -1 + v(11) \\         &= -1 - 14 \\          &= -15       \end {align*}     ]]></fr:tex>
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1830</fr:anchor><fr:addr
type="machine">#361</fr:addr><fr:route>unstable-361.xml</fr:route><fr:title
text=" [sutton2022, 4.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="4.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 4.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
</fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  

  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1832</fr:anchor><fr:addr
type="machine">#365</fr:addr><fr:route>unstable-365.xml</fr:route><fr:title
text="Review Question">Review Question</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1834</fr:anchor><fr:addr
type="machine">#363</fr:addr><fr:route>unstable-363.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Review the methods discussed in the first part of the book. What are their strengths and weaknesses? When should they be used?</fr:mainmatter><fr:backmatter /></fr:tree>

  <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
style="white-space: nowrap">
    
 
   
   <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1836</fr:anchor><fr:addr
type="machine">#364</fr:addr><fr:route>unstable-364.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      
  <html:table
xmlns:html="http://www.w3.org/1999/xhtml">
        
  <html:tr>
          
  <html:td />

          
  <html:td><fr:strong>Strength</fr:strong></html:td>

          
  <html:td><fr:strong>Weakness</fr:strong></html:td>

          
  <html:td><fr:strong>Use case</fr:strong></html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Bandits</fr:strong></html:td>

          
  <html:td>Simplest case. Can isolate exploration problem.</html:td>

          
  <html:td>No credit assignment. Action only effect next timestep.</html:td>

          
  <html:td>Clinical trials. Things without temporally extended outcomes.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dynamic Programming</fr:strong></html:td>

          
  <html:td>Exact solution.</html:td>

          
  <html:td>Complexity blows up with state and action space. Model-based.</html:td>

          
  <html:td>Tabular MDPs.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Monte Carlo</fr:strong></html:td>

          
  <html:td>Unbiased estimator. Model-free.</html:td>

          
  <html:td>Extremely high variance. Must wait till end of episode.</html:td>

          
  <html:td>When interacting with environment is inexpensive, episode length is short.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>TD methods</fr:strong></html:td>

          
  <html:td>Model-free. Online.</html:td>

          
  <html:td>Biased estimator.</html:td>

          
  <html:td>Environment interaction is cheap but also episode length is long or continuing.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>N step</fr:strong></html:td>

          
  <html:td>Balance bias-variance tradeoff.</html:td>

          
  <html:td>Must choose <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</html:td>

          
  <html:td>Lower variance continuing environments?</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><fr:strong>Dyna</fr:strong></html:td>

          
  <html:td>Sample efficiency.</html:td>

          
  <html:td>Model-based.</html:td>

          
  <html:td>When interacting with environment is costly i.e. driving.</html:td>

        </html:tr>

      </html:table>

    </fr:mainmatter><fr:backmatter /></fr:tree>
 

  </html:span>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1838</fr:anchor><fr:addr
type="user">kak-000G</fr:addr><fr:route>kak-000G.xml</fr:route><fr:title
text="On-policy Prediction with Approximation">On-policy Prediction with Approximation</fr:title><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>In my opinion, the most important part of this chapter is now that when we update say a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function for a specific state action pair <fr:tex
display="inline"><![CDATA[(s,a)]]></fr:tex>, then this update can affect the value of the <fr:tex
display="inline"><![CDATA[Q(s', a')]]></fr:tex> due to the reuse of the internal parameters.</fr:p>
  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1839</fr:anchor><fr:addr
type="machine">#367</fr:addr><fr:route>unstable-367.xml</fr:route><fr:title
text=" [sutton2022, 9.1]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.1"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Show that tabular methods are a special case of linear function approximation. What would the feature vectors be?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1840</fr:anchor><fr:addr
type="machine">#368</fr:addr><fr:route>unstable-368.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
<fr:p>As a linear function approximation method, we have two quantities <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\boldsymbol {x}(s)]]></fr:tex>. We make the update
<fr:tex
display="block"><![CDATA[w_{t + 1} = w_{t} + \alpha (r_t + \gamma  w_{t}^{\top } x_{t+1} - w_t^{\top } x_t) x_t]]></fr:tex>
In the tabular setting, we just assume that we have the capacity to represent every possible state. This means that <fr:tex
display="inline"><![CDATA[x(s) \in  \mathbb {R}^{|S|}]]></fr:tex>. Therefore, if we define the features as <fr:tex
display="inline"><![CDATA[x : s_i \mapsto  \boldsymbol {e}_i]]></fr:tex> then we can recover policy evaluation by taking,
<fr:tex
display="block"><![CDATA[r_i = \mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)], \quad  w_i = v_{\pi }(s_i)]]></fr:tex></fr:p>
Substituting, we get 
<fr:tex
display="block"><![CDATA[ w_{t + 1} = w_{t} + \alpha (\mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)] + v(s_{t + 1}) - v(s_{t})) \cdot  \boldsymbol {e}_i ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> is our vector of values, updating the <fr:tex
display="inline"><![CDATA[i]]></fr:tex>th entry is exactly performing exactly one update to <fr:tex
display="inline"><![CDATA[v_{\pi }(s_i)]]></fr:tex> in the tabular setting.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1841</fr:anchor><fr:addr
type="machine">#369</fr:addr><fr:route>unstable-369.xml</fr:route><fr:title
text=" [sutton2022, 9.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.2"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>Why does (9.17) define <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> distinct features for dimension k?</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1842</fr:anchor><fr:addr
type="machine">#370</fr:addr><fr:route>unstable-370.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>For each <fr:tex
display="inline"><![CDATA[s_j]]></fr:tex>, there are <fr:tex
display="inline"><![CDATA[n + 1]]></fr:tex> options for <fr:tex
display="inline"><![CDATA[c_{i, j}]]></fr:tex>. Since there are <fr:tex
display="inline"><![CDATA[k]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_{j}]]></fr:tex>'s, there are <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> total possible features for <fr:tex
display="inline"><![CDATA[x_i]]></fr:tex>.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1843</fr:anchor><fr:addr
type="machine">#371</fr:addr><fr:route>unstable-371.xml</fr:route><fr:title
text=" [sutton2022, 9.3]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.3"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
<fr:p>What <fr:tex
display="inline"><![CDATA[n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{i,j}]]></fr:tex> produce the feature vectors <fr:tex
display="block"><![CDATA[\mathbf {x}(s)=(1,s_{1},s_{2},s_{1}s_{2},s_{1}^{2},s_{2}^{2},s_{1}^{2}s_{2}^{2},s_{1}s_{2}^{2},s_{1}^{2}s_{2}^{2})^{\top }?]]></fr:tex></fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1844</fr:anchor><fr:addr
type="machine">#372</fr:addr><fr:route>unstable-372.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p><fr:tex
display="inline"><![CDATA[n = 2]]></fr:tex> and <fr:tex
display="inline"><![CDATA[c_{ij}]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\boldsymbol {c_0} = [0, 0], \quad    \boldsymbol {c_1} = [1, 0] \\   \boldsymbol {c_2} = [0, 1], \quad    \boldsymbol {c_3} = [1, 1] \\   \boldsymbol {c_4} = [2, 0], \quad    \boldsymbol {c_5} = [0, 2] \\   \boldsymbol {c_6} = [2, 2], \quad    \boldsymbol {c_7} = [1, 2], \quad    \boldsymbol {c_8} = [2, 2]   ]]></fr:tex></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1845</fr:anchor><fr:addr
type="machine">#373</fr:addr><fr:route>unstable-373.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In section 9.5.2, what do they mean when they say you can select <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so all the fourier features can be used?
    <fr:ol><fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k < mk^2]]></fr:tex>.</fr:li>
        <fr:li>Pick <fr:tex
display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex
display="inline"><![CDATA[(n + 1)^k]]></fr:tex> is reasonable.</fr:li></fr:ol></fr:li>
    <fr:p>In the tabular case, I think (a) is correct. My initial understanding of state representation is as a representation learning i.e. compression type objective. If we assume that <fr:tex
display="inline"><![CDATA[s_i \in  [m]]]></fr:tex>, then we do not gain anything in the tabular setting if our value function vector is the same size as the underlying transition kernel. When in the continuous state space regime i.e. <fr:tex
display="inline"><![CDATA[s_i \in  [0,1]]]></fr:tex>, there is no amount of features that would overfit the transition kernel. Therefore, it is just about trying to learn as much as possible about the underlying relations of the state dimensions.</fr:p>
    <fr:p>In the <fr:tex
display="inline"><![CDATA[2]]></fr:tex>-dimensional case, the feature vector <fr:tex
display="inline"><![CDATA[c_i = [1,1]]]></fr:tex> would provide information on how <fr:tex
display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[s_2]]></fr:tex> relate not just their specific values. You want the learning algorithm to understand the relationships, so that it can make better use of the internal parameters when learning something like a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. This is basically just SVD but instead of classification you are learning a <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> function. The compression</fr:p></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1846</fr:anchor><fr:addr
type="machine">#374</fr:addr><fr:route>unstable-374.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:ol><fr:li>In Figure 9.5, why do fourier features outperform polynomial features?
    <fr:ol><fr:li>The fourier features got lucky on the seeds (lol).</fr:li>
        <fr:li>The choice of <fr:tex
display="inline"><![CDATA[\boldsymbol {c}]]></fr:tex> is not specified. A good choice can provide improvement specific to the problem?</fr:li>
        <fr:li>Polynomial features range is very large. Can suffer from blowup or vanishing of features.</fr:li></fr:ol></fr:li>
    One of the advantages of fourier features mentioned previously is the ability to select which features to serve as your basis. However, for this setup I assume they just use all of the fourier features. This likely means it is more of an issue with the polynomial features and (c). If you have a large polynomial then even relative similar states <fr:tex
display="inline"><![CDATA[s_1 = 1.1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[s_2 = 0.9]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\ldots ]]></fr:tex> can blow up or vanish making them likely more unstable when using gradient-based methods.</fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1847</fr:anchor><fr:addr
type="machine">#375</fr:addr><fr:route>unstable-375.xml</fr:route><fr:title
text=" [sutton2022, 9.4]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="9.4"
refid="sutton2022"><fr:link
type="local"
href="sutton2022.xml"
addr="sutton2022"
title="Reinforcement Learning: An Introduction">[sutton2022, 9.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
  <fr:p>You could do anisotropic (big word for asymmetric) tile partitioning. If we consider the two state dimensions as (x,y) coordinates and suppose that we want to only generalize across the <fr:tex
display="inline"><![CDATA[y]]></fr:tex>-direction i.e. we want states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate to have similar values then we would tile with long thin tiles. Therefore, states with the same <fr:tex
display="inline"><![CDATA[x]]></fr:tex> coordinate would lie in the same vertical tile and if the tiles are very thin any change in <fr:tex
display="inline"><![CDATA[x]]></fr:tex>-coordinate would lie in disjoint tiles.</fr:p>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1848</fr:anchor><fr:addr
type="machine">#376</fr:addr><fr:route>unstable-376.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>5</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>I think that RBF as a continuous generalization coarse-coding is a nice intuition I want to remember here. Essentially, you just weight a state by how close it is to the center of the receptive field. This weighting is done via a Gaussian kernel, which I believe is arbitrary and can be any distance measure of choice.</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2290</fr:anchor><fr:addr
type="user">kak-003Z</fr:addr><fr:route>kak-003Z.xml</fr:route><fr:title
text="Stochastic Processes">Stochastic Processes</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>576</fr:anchor><fr:addr
type="machine">#297</fr:addr><fr:route>unstable-297.xml</fr:route><fr:title
text="Markov Chains">Markov Chains</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>578</fr:anchor><fr:addr
type="machine">#295</fr:addr><fr:route>unstable-295.xml</fr:route><fr:title
text="Definitions">Definitions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>580</fr:anchor><fr:addr
type="user">kak-0040</fr:addr><fr:route>kak-0040.xml</fr:route><fr:title
text="Markov Chain">Markov Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say a stochastic process <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> is a Markov chain (MC) with transition matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> if for any <fr:tex
display="inline"><![CDATA[n \in  \mathcal {N}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{0}, \ldots  x_{n - 1}]]></fr:tex>
  <fr:tex
display="block"><![CDATA[ 		\mathbb {P}(X_{n + 1} = y \mid  X_{n} = x, X_{n - 1} = x_{n - 1}, \ldots , X_0 = x_0) = \mathbb {P}(X_{n + 1} = y \mid  X_n = x) = p(x, y)   ]]></fr:tex>
	whenever conditional probability is well-defined. 
	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>581</fr:anchor><fr:addr
type="machine">#293</fr:addr><fr:route>unstable-293.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Moreover, any matrix <fr:tex
display="inline"><![CDATA[p : \mathcal {S} \times  \mathcal {S} \to  [0, 1]]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[\sum _{y \in  \mathcal {S}} p(x, y) = 1]]></fr:tex> is called a stochastic matrix. Given any stochastic matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, one can create a MC.
</fr:mainmatter><fr:backmatter /></fr:tree>

	
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>582</fr:anchor><fr:addr
type="machine">#294</fr:addr><fr:route>unstable-294.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
		This is called a temporally homogeneous discrete Markov chain because <fr:tex
display="inline"><![CDATA[p]]></fr:tex> does not depend on time.
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>583</fr:anchor><fr:addr
type="user">kak-0041</fr:addr><fr:route>kak-0041.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th step transition probability <fr:tex
display="inline"><![CDATA[\mathbb {P}(X_{n + m} = y \mid  X_{n} = x)]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[m]]></fr:tex>th power of transition matrix <fr:tex
display="inline"><![CDATA[p]]></fr:tex>, computed at <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>584</fr:anchor><fr:addr
type="user">kak-0042</fr:addr><fr:route>kak-0042.xml</fr:route><fr:title
text="Chapman-Kolmogorov Equation">Chapman-Kolmogorov Equation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[p^{m + n}(x,y) = \sum _{z \in  S} p^{m}(x,z) p^{n}(z,y)]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>585</fr:anchor><fr:addr
type="machine">#292</fr:addr><fr:route>unstable-292.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Note that
<fr:tex
display="block"><![CDATA[       \begin {align*}         p^{m + n}(x, y) &= \mathbb {P}(X_{m+n} = y \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y, X_{m} = z \mid  X_{0} = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z, X_{0} = x) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} \mathbb {P}(X_{m+n} = y \mid  X_m = z) \mathbb {P}(X_m = z \mid  X_0 = x) \\         &= \sum _{z} p^{n}(z, y) p^{m}(x, z)       \end {align*}     ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>586</fr:anchor><fr:addr
type="user">kak-0043</fr:addr><fr:route>kak-0043.xml</fr:route><fr:title
text="Stopping time">Stopping time</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[T : \Omega  \to  \mathbb {N} \cup  \{\infty \}]]></fr:tex> is a stopping time with respect to <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\{T = k\}]]></fr:tex> can be determined by <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{k}\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>587</fr:anchor><fr:addr
type="machine">#296</fr:addr><fr:route>unstable-296.xml</fr:route><fr:title
text="Classification of States">Classification of States</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>589</fr:anchor><fr:addr
type="user">kak-0044</fr:addr><fr:route>kak-0044.xml</fr:route><fr:title
text="Strong Markov Property">Strong Markov Property</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Let <fr:tex
display="inline"><![CDATA[T]]></fr:tex> be a stopping time with respect to <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[k \in  \mathbb {N}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>, given <fr:tex
display="inline"><![CDATA[\{T < \infty , X_{T} = x\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X_{T + k}]]></fr:tex> is independent of <fr:tex
display="inline"><![CDATA[\{X_0, \ldots , X_{T}\}]]></fr:tex>. Moreover, 
<fr:tex
display="block"><![CDATA[\mathbb {P}(X_{T + k} \mid  T < \infty , X_T = x) = p^k(x,y)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>590</fr:anchor><fr:addr
type="machine">#291</fr:addr><fr:route>unstable-291.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  TODO
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>591</fr:anchor><fr:addr
type="user">kak-0045</fr:addr><fr:route>kak-0045.xml</fr:route><fr:title
text="Transient and recurrent states">Transient and recurrent states</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex> is recurrent if <fr:tex
display="inline"><![CDATA[\rho _{xx} = 1]]></fr:tex> and transient if <fr:tex
display="inline"><![CDATA[\rho _{xx} < 1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>592</fr:anchor><fr:addr
type="user">kak-0048</fr:addr><fr:route>kak-0048.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say <fr:tex
display="inline"><![CDATA[T_y]]></fr:tex> is a return time if <fr:tex
display="inline"><![CDATA[T_y = \inf  \{n \geq  1 \mid  X_n = y\}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\rho _{xy} = \mathbb {P}(T_y < \infty )]]></fr:tex>. We write the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th return time as 
	<fr:tex
display="block"><![CDATA[T_{y}^{k} = \min  \{n > T_y^{k - 1} \mid  X_{n} = y\}]]></fr:tex>
  with <fr:tex
display="inline"><![CDATA[T_y^{1} \coloneqq  T_{y}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>593</fr:anchor><fr:addr
type="user">kak-0046</fr:addr><fr:route>kak-0046.xml</fr:route><fr:title
text="Communicates">Communicates</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	We say <fr:tex
display="inline"><![CDATA[x]]></fr:tex> communicates with <fr:tex
display="inline"><![CDATA[y]]></fr:tex> and denote it by <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\rho _{xy} > 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>594</fr:anchor><fr:addr
type="user">kak-0047</fr:addr><fr:route>kak-0047.xml</fr:route><fr:title
text="Transitivity of communcation">Transitivity of communcation</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	If <fr:tex
display="inline"><![CDATA[x \to  y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y \to  z]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[x \to  z]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>595</fr:anchor><fr:addr
type="machine">#290</fr:addr><fr:route>unstable-290.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	By assumption, there exists <fr:tex
display="inline"><![CDATA[m, n \leq  t]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[p^{m}(x,y) > 0]]></fr:tex> and <fr:tex
display="inline"><![CDATA[p^n(y,z) > 0]]></fr:tex>. Then 
  <fr:tex
display="block"><![CDATA[ 	\begin {align*} 		p^{m + n}(x, z) &= \sum _{k \in  S} p^{m}(x, k)p^{n}(k,z) \\ 										&\geq  p^{m}(x,y)p^{n}(y,z) \quad  \quad  (\text {Strong Markov})\\  										&> 0 	\end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>596</fr:anchor><fr:addr
type="user">kak-0049</fr:addr><fr:route>kak-0049.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>	Suppose <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_{y} \leq  k) \geq  a > 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x \in  S]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\mathbb {P}_x(T_y \geq  mk) \leq  (1-a)^m]]></fr:tex>, <fr:tex
display="inline"><![CDATA[m \in  \mathbb {N}]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>597</fr:anchor><fr:addr
type="machine">#289</fr:addr><fr:route>unstable-289.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
	Define <fr:tex
display="inline"><![CDATA[X_{n}^{(1)} = X_{k + n}, \ldots , X_{n}^{(m-1)} = X_{(m-1)k + n}]]></fr:tex>. Then define <fr:tex
display="inline"><![CDATA[T_{y}^{(1)}, \ldots , T_{y}^{(m-1)}]]></fr:tex> as the corresponding hitting times of state <fr:tex
display="inline"><![CDATA[y]]></fr:tex>. We have
  <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}_x(T_y > km) &= \mathbb {P}_{x}(T_y > k, T_y^{(1)} > k, \ldots , T_y^{(m-1)} > k) \\                             &\leq  \mathbb {P}_x(T_y > k, \ldots , T_y^{(m-1)} > k \mid  X_{k} \neq  y, \ldots , X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}_{x}(T_y > k)\mathbb {P}_x(T_y^{(1)} > k \mid  X_{k} \neq  y) \cdots  \mathbb {P}_x(T_y^{(m-1)} > k \mid  X_{(m-1)k} \neq  y) \\                             &= \mathbb {P}(T_y > k)\left (\sum _{z \neq  y}\underbrace {\mathbb {P}_z(T_y > k)}_{\leq  (1-a)} \mathbb {P}_x(X_{k} = z \mid  X_{k} \neq  y)\right ) \\                             &\leq  (1-a)^{m}\underbrace {\sum _{z \neq  y}\mathbb {P}_x \left (X_k = z \mid  X_k \neq   y \right )}_{=1}     \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>598</fr:anchor><fr:addr
type="user">kak-0058</fr:addr><fr:route>kak-0058.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a finite closed and irreducible set, then all states in <fr:tex
display="inline"><![CDATA[C]]></fr:tex> are recurrent.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>599</fr:anchor><fr:addr
type="user">kak-0057</fr:addr><fr:route>kak-0057.xml</fr:route><fr:title
text="Decomposition Theorem">Decomposition Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If the state space <fr:tex
display="inline"><![CDATA[S]]></fr:tex> is finite, then <fr:tex
display="inline"><![CDATA[S]]></fr:tex> can be written as a disjoint union <fr:tex
display="inline"><![CDATA[T\cup  R_{1}\cup \cdots \cup  R_{k}]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[T]]></fr:tex> is a set of transient states and the <fr:tex
display="inline"><![CDATA[R_{i},\ 1\leq  i\leq  k]]></fr:tex>, are closed irreducible sets of recurrent states.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2292</fr:anchor><fr:addr
type="user">kak-0007</fr:addr><fr:route>kak-0007.xml</fr:route><fr:title
text="Notes on Probability and Measure">Notes on <fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">Probability and Measure</fr:link></fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For these notes, I will attempt to refresh my knowledge of measure-theoretic probability along with learning stochastic processes for the first time. I will be following <fr:link
type="external"
href="https://link.springer.com/book/10.1007/978-0-387-87859-1">Probability and Stochastics</fr:link> by Cinlar. Unfortunately, there are no solutions to exercises, but it is by far the best written book I have found.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1657</fr:anchor><fr:addr
type="machine">#381</fr:addr><fr:route>unstable-381.xml</fr:route><fr:title
text="Borel's Normal Number Theorem">Borel's Normal Number Theorem</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1659</fr:anchor><fr:addr
type="user">kak-000S</fr:addr><fr:route>kak-000S.xml</fr:route><fr:title
text="Additivity of Intervals">Additivity of Intervals</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We have the following properties
  <fr:ol><fr:li>If <fr:tex
display="inline"><![CDATA[\bigcup _{k}I_{k}\subset  I]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[\sum _{k}|I_{k}|\leq |I|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I\subset \bigcup _{k}I_{k}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> need not be disjoint), then <fr:tex
display="inline"><![CDATA[|I|\leq \sum _{k}|I_{k}|]]></fr:tex>.</fr:li>
<fr:li>If <fr:tex
display="inline"><![CDATA[I=\bigcup _{k}I_{k}]]></fr:tex>, and the <fr:tex
display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex
display="inline"><![CDATA[|I|=\sum _{k}|I_{k}|]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1660</fr:anchor><fr:addr
type="machine">#380</fr:addr><fr:route>unstable-380.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  The important takeaway from <fr:link
type="local"
href="kak-000S.xml"
addr="kak-000S"
title="Additivity of Intervals">Additivity of Intervals</fr:link> is that extending (2) from finite to countable unions requires Heine-Borel theorem, illustrating that this extension is non-trivial. This will be important to remember as we continue to extend the Lebesgue measure to <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras. 
  </fr:mainmatter><fr:backmatter /></fr:tree>

  This section aims to motivate why we need to approach probability from a measure theoretic point of view.
  As an example, we will do the first exercise for this section.
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1662</fr:anchor><fr:addr
type="user">kak-000L</fr:addr><fr:route>kak-000L.xml</fr:route><fr:title
text="Dyadic Intervals">Dyadic Intervals</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>14</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Represent coin toss as dyadic expansion consider the set</fr:p><fr:tex
display="block"><![CDATA[\left [\omega :\ d_{i}(\omega )=u_{i},\,i=1,\ldots ,n \right ]=\Big (\sum _{i=1}^{n} \frac {u_{i}}{2^{i}},\ \sum _{i=1}^{n}\frac {u_{i}}{2^{i}} + \frac {1}{2^{n}}\Big ).]]></fr:tex><fr:p>More stuff</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
  <fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1663</fr:anchor><fr:addr
type="user">kak-000N</fr:addr><fr:route>kak-000N.xml</fr:route><fr:title
text="Problem 1.1 Billingsley">Problem 1.1 Billingsley</fr:title><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>17</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:ol><fr:li>A discrete probability space cannot contain an infinite sequence of independent events <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> each with probability <fr:tex
display="inline"><![CDATA[1/2]]></fr:tex>. To see this, denote the event space as <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>. Note that 
    <fr:tex
display="block"><![CDATA[P(A_1 \cap  A_2) + P(A_1 \cap  A_2^c) + P(A_1^c \cap  A_2) + P(A_1^c \cap  A_2^c) = 1]]></fr:tex>
    Therefore, every <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex> must be in one of those four events and have probability at most <fr:tex
display="inline"><![CDATA[1/4]]></fr:tex>. Similarly, we can construct <fr:tex
display="inline"><![CDATA[n]]></fr:tex> disjoint sets in the same manner and bound <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\})]]></fr:tex> by <fr:tex
display="inline"><![CDATA[1/n]]></fr:tex>. Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex>, we have that <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is a discrete probability space, we must have that 
    <fr:tex
display="block"><![CDATA[\sum _{x \in  \mathcal {X}} \mathbb {P}(\{x\}) = 1]]></fr:tex>
    However, we have just shown that for each <fr:tex
display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Thus, we have reached a contradiction.</fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree>
  
  I think my main takeaway from this is that infinite sequences break discrete probability because each discrete event will have probability zero. This is not actually a problem because in an infinite sequence the occurence of any such sequence "feasibly" has zero probability. However, we still want to reason about probabilistic things like the convergence of the average of the sequence. Since discrete probability is broken, we cannot even use it for these things. This is why we need to use measure theory to allow for zero probability sequences, but still provide information about these more "general" events. Who knows if this intuition is right though?
</fr:mainmatter><fr:backmatter /></fr:tree>
  
<fr:p><fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1664</fr:anchor><fr:addr
type="machine">#382</fr:addr><fr:route>unstable-382.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:ul><fr:li>After a bit more digging, the main culprit here is the countable subadditivity condition of measure.</fr:li>
      <fr:li>In a discrete probability space, the entire space is at most countable. Therefore, if each individual event has zero probability then the countable union i.e. the whole space will have zero probability.</fr:li>
      <fr:li>In measure theoretic probability, we are able to accumulate non-zero probability mass from an <fr:strong>uncountable</fr:strong> union of zero measure events.</fr:li>
      <fr:li>I guess the canonical example of this is that each point on a line has length 0, but the line itself (an uncountable union of points) has non-zero length.</fr:li>
      <fr:li>In the dyadic intervals example, each event of an arbitrary discrete probability space can be identified with a point on the line of probability zero.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree></fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1666</fr:anchor><fr:addr
type="machine">#385</fr:addr><fr:route>unstable-385.xml</fr:route><fr:title
text="Probability Measures">Probability Measures</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1668</fr:anchor><fr:addr
type="user">kak-000O</fr:addr><fr:route>kak-000O.xml</fr:route><fr:title
text="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class of subsets <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field if the following holds
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {F}]]></fr:tex></fr:li>
    <fr:li>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots  \in  \mathscr {F}]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\bigcup _{i = 1}^{\infty } A_i \in  \mathscr {F}]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>It seems, in this section, we aim to answer why certain decisions were made regarding what can be analyzed. For example,</fr:p>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1669</fr:anchor><fr:addr
type="machine">#383</fr:addr><fr:route>unstable-383.xml</fr:route><fr:taxon>Question</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Why do we only allow consider countable unions in the definition of a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>?</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1671</fr:anchor><fr:addr
type="machine">#384</fr:addr><fr:route>unstable-384.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Because this is what god intended.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1673</fr:anchor><fr:addr
type="user">kak-000P</fr:addr><fr:route>kak-000P.xml</fr:route><fr:title
text="Probability Measure">Probability Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A set function is a real-valued function defined on some class of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. A set function <fr:tex
display="inline"><![CDATA[P]]></fr:tex> on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a probability measure if it satisfies these conditions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[0\leq  P(A)\leq 1]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A\in \mathscr {F}]]></fr:tex>;</fr:li>
  <fr:li><fr:tex
display="inline"><![CDATA[P(\varnothing )=0]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(\Omega )=1]]></fr:tex>;</fr:li>
  <fr:li>if <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> is a disjoint sequence of <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> sets and if <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}\in \mathscr {F}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[P\Big (\bigcup _{k=1}^{\infty }A_{k}\Big )=\sum _{k=1}^{\infty }P(A_{k}).]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1674</fr:anchor><fr:addr
type="user">kak-000Q</fr:addr><fr:route>kak-000Q.xml</fr:route><fr:title
text="Probability Space">Probability Space</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field in <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is a probability measure on <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, the triple <fr:tex
display="inline"><![CDATA[(\Omega ,\mathscr {F},P)]]></fr:tex> is called a probability measure space, or simply a probability space. A support of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> for which <fr:tex
display="inline"><![CDATA[P(A)=1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1675</fr:anchor><fr:addr
type="user">kak-000R</fr:addr><fr:route>kak-000R.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>.

<fr:ol><fr:li><fr:em>Continuity from below</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathscr {A}_{n}\uparrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\uparrow  P(A)]]></fr:tex>.</fr:li>

<fr:li><fr:em>Continuity from above</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[P(A_{n})\downarrow  P(A)]]></fr:tex>.</fr:li>
<fr:li><fr:em>Countable subadditivity</fr:em>: If <fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}]]></fr:tex> lie in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> (the <fr:tex
display="inline"><![CDATA[A_{k}]]></fr:tex> need not be disjoint), then

<fr:tex
display="block"><![CDATA[P\left (\bigcup _{k=1}^{\infty }A_{k}\right )\leq \sum _{k=1}^{\infty }P(A_{k})]]></fr:tex></fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1676</fr:anchor><fr:addr
type="machine">#388</fr:addr><fr:route>unstable-388.xml</fr:route><fr:title
text="Existence and Extension">Existence and Extension</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Here we will see how we can define a probability measure on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex> and get a unique extension to the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {F} = \sigma (\mathscr {F}_0)]]></fr:tex>. I guess the key here is uniqueness?</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1678</fr:anchor><fr:addr
type="user">kak-000T</fr:addr><fr:route>kak-000T.xml</fr:route><fr:title
text="Outer Measure">Outer Measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="block"><![CDATA[P^{*}(A)=\mathrm {inf}\,\sum _{n}P(A_{n}),]]></fr:tex> where <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1679</fr:anchor><fr:addr
type="machine">#386</fr:addr><fr:route>unstable-386.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Taking <fr:tex
display="inline"><![CDATA[P_*(A) = 1 - P^*(A^c)]]></fr:tex> gives the inner measure. This is just analogously approximating from the inside.</fr:mainmatter><fr:backmatter /></fr:tree>

    Intuition is that the sets that are "measurable" should be sets that can be arbitrarily approximated from the inside and outside, or equivalently
<fr:tex
display="block"><![CDATA[P^*(A) + P^*(A^c) = 1]]></fr:tex>
    <fr:ol><fr:li>My intution for this is that if a set is not arbitrarily well approximated by countable other sets from our algebra then we cannot hope to get an accurate measure from our measure defined on only the algebra.</fr:li>
      <fr:li>The countableness is just from the definition of the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
    <fr:p>Then we can use <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> as our measure. To do this, we will need to show that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is countable additive as one might expect. The rest of the properties of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> are trivial.</fr:p>

    
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1681</fr:anchor><fr:addr
type="machine">#387</fr:addr><fr:route>unstable-387.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:p>Suppose that <fr:tex
display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n]]></fr:tex>. By the definition of <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">Outer Measure</fr:link>, we can find some <fr:tex
display="inline"><![CDATA[B_{nk}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[A_n \subset  \bigcup _{k = 1}^{\infty } B_{nk}]]></fr:tex> where 
<fr:tex
display="block"><![CDATA[\sum _{k} P(B_{nk}) < P^*(A_n) + \epsilon  2^{-k}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[C_n = \bigcup _{k} B_{nk}]]></fr:tex>, so that <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n \subset  \bigcup _{n} C_n]]></fr:tex> and
<fr:tex
display="block"><![CDATA[P^*\left (\bigcup _n A_n\right ) < \sum _{n} P(C_n) = \sum _{n} \sum _{k} P(B_{nk}) < \sum _{n} P^*(A_n) + \epsilon ]]></fr:tex></fr:p>
      Since <fr:tex
display="inline"><![CDATA[\bigcup _{n} A_n = A]]></fr:tex>, we have achieved the desired result.
    </fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:p>It turns out that for some reason only enforcing <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and its complement to sum to <fr:tex
display="inline"><![CDATA[1]]></fr:tex> is not restrictive enough? From this, we end up with the final condition</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1683</fr:anchor><fr:addr
type="user">kak-000U</fr:addr><fr:route>kak-000U.xml</fr:route><fr:title
text="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable if for every <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>, we have that 
<fr:tex
display="block"><![CDATA[P^*(A \cap  E) + P^*(A^c \cap  E) = P^*(E)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:p>You then only need to show two things:
        <fr:ol><fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets contains <fr:tex
display="inline"><![CDATA[\mathscr {F_0}]]></fr:tex>,</fr:li>
            <fr:li>The class of <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets is a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</fr:li></fr:ol>
        From these, we can conclude that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is at least defined on a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> containing <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>. Restricting <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>, then yields the desired extension.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1684</fr:anchor><fr:addr
type="machine">#393</fr:addr><fr:route>unstable-393.xml</fr:route><fr:title
text="Uniqueness">Uniqueness</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>We now want to show that the extension we developed in the previous section is actually unique. The first question we have is what do we mean by unique? To answer this, we need to remember what we have done so far.
    <fr:ol><fr:li>We have a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, defined on an algebra <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>.</fr:li>
        <fr:li>We then extended <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex> via <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>, so that for every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[P(A) = P^*(A)]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex></fr:li></fr:ol>
      From this, our only restriction is that <fr:tex
display="inline"><![CDATA[P^*(A) = P(A)]]></fr:tex> for <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Therefore, uniqueness here means that if <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> and every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[A \in  \sigma (\mathscr {F}_0)]]></fr:tex>.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1686</fr:anchor><fr:addr
type="user">kak-0018</fr:addr><fr:route>kak-0018.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathcal {P}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system if it is closed under the formation of finite intersections:
<fr:tex
display="block"><![CDATA[A,B\in \mathcal {P} \implies  A\cap  B\in \mathcal {P}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1687</fr:anchor><fr:addr
type="user">kak-0019</fr:addr><fr:route>kak-0019.xml</fr:route><fr:title
text="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system if it contains <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> and is closed under the formation of complements and of finite and countable disjoint unions:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\Omega \in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A\in \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[A^{c}\in \mathscr {L}]]></fr:tex>;</fr:li>

<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots ,\in \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\cap  A_{m}=\varnothing ]]></fr:tex> for <fr:tex
display="inline"><![CDATA[m\neq  n]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[\bigcup _{n}A_{n}\in \mathscr {L}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>I was a bit unsure that a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> is not a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, but the author provided an example that I will walk through to understand the distinction</fr:p>


   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1688</fr:anchor><fr:addr
type="machine">#389</fr:addr><fr:route>unstable-389.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
Consider a four point space <fr:tex
display="inline"><![CDATA[\Omega  = \{x_1, x_2, x_3, x_4\}]]></fr:tex>. We can define a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> by taking <fr:tex
display="inline"><![CDATA[\mathscr {L} = \emptyset , \Omega ,]]></fr:tex> and the six two point sets. The union of any two disjoint two point sets will be <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. However, a non-disjoint union of two disjoint sets can result in a three point set, which is not in <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex>. These non-disjoint unions would be covered in a <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


<fr:p>To remedy this disconnect, we have the following lemma:</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1690</fr:anchor><fr:addr
type="user">kak-001A</fr:addr><fr:route>kak-001A.xml</fr:route><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class that is both a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system is a <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>In our example, we could take the intersection of say <fr:tex
display="inline"><![CDATA[\{x_1, x_2\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2, x_3\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex>. We could then take a disjoint union of <fr:tex
display="inline"><![CDATA[\{x_1, x_3\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\{x_2\}]]></fr:tex> to get <fr:tex
display="inline"><![CDATA[\{x_1, x_2, x_3\}]]></fr:tex>.</fr:p> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1691</fr:anchor><fr:addr
type="user">kak-001B</fr:addr><fr:route>kak-001B.xml</fr:route><fr:title
text="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system and <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system, then <fr:tex
display="inline"><![CDATA[\mathscr {P}\subset \mathscr {L}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})\subset \mathscr {L}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Now we will see how this allows us to prove our desired result i.e. the uniqueness of our extension of a probability on an algebra to the <fr:link
type="external"
href="kak-0000">kak-0000</fr:link> via the outer measure.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1692</fr:anchor><fr:addr
type="user">kak-001C</fr:addr><fr:route>kak-001C.xml</fr:route><fr:title
text="Uniqueness of Extension">Uniqueness of Extension</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> are probability measures on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>, where <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system. If <fr:tex
display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_{2}]]></fr:tex> agree on <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex>, then they agree on <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1693</fr:anchor><fr:addr
type="machine">#335</fr:addr><fr:route>unstable-335.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Take <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> to be the class of sets such that <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L} \implies  P_1(A) = P_2(A)]]></fr:tex>. Since <fr:tex
display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system, from <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, it is sufficient to show that <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. Since <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {P}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\Omega  \in  \mathscr {L}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[A \in  \mathscr {L}]]></fr:tex>, then
<fr:tex
display="block"><![CDATA[P_1(A^c) = 1 - P_1(A) = 1 - P_2(A) = P_2(A^c).]]></fr:tex>
Therefore, <fr:tex
display="inline"><![CDATA[A^c \in  \mathscr {L}]]></fr:tex>. Finally, if <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> disjoint then
<fr:tex
display="block"><![CDATA[   P_1\left (\bigcup _{n = 1} A_n\right ) = \sum _{n = 1} P_1(A_n) = \sum _{n = 1}P_2 (A_n) = P_2\left (\bigcup _{n = 1}A_n\right ) ]]></fr:tex>
Thus, <fr:tex
display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system. From <fr:link
type="local"
href="kak-001C.xml"
addr="kak-001C"
title="Uniqueness of Extension">Theorem 9</fr:link>, <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P}) \subset  \mathscr {L}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P_2]]></fr:tex> agree on all of <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>An (important?) note is that this works due to our definition of a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link>. Namely, countable additivity is really a condition on countable disjoint unions, meaning that the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> induced by a <fr:link
type="local"
href="kak-000P.xml"
addr="kak-000P"
title="Probability Measure">Probability Measure</fr:link> does not make full use of the generality allowed under arbitrary countable unions because it must satisfy countable additivity.</fr:p>

<fr:p>For completeness and future use, we introduce here the notion of monotone classes and Halmo's useful <fr:link
type="local"
href="kak-001E.xml"
addr="kak-001E"
title="Halmo's Monotone Class Theorem">theorem</fr:link>.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1694</fr:anchor><fr:addr
type="user">kak-001D</fr:addr><fr:route>kak-001D.xml</fr:route><fr:title
text="Monotone Class">Monotone Class</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A class <fr:tex
display="inline"><![CDATA[\mathscr {M}]]></fr:tex> of subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is monotone if it is closed under the formation of monotone unions and intersections:

<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\uparrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>;</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A_{1},A_{2},\ \ldots \in \mathscr {M}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex> imply <fr:tex
display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1695</fr:anchor><fr:addr
type="user">kak-001E</fr:addr><fr:route>kak-001E.xml</fr:route><fr:title
text="Halmo's Monotone Class Theorem">Halmo's Monotone Class Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> is a field and <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> is a monotone class, then <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}\subset \mathscr {A}]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {F}_{0})\subset \mathscr {A}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>Also for completeness, we introduce completeness lol.</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1696</fr:anchor><fr:addr
type="user">kak-001F</fr:addr><fr:route>kak-001F.xml</fr:route><fr:title
text="Completeness of a measure">Completeness of a measure</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A probability measure <fr:tex
display="inline"><![CDATA[(\Omega , \mathcal {F}, P)]]></fr:tex> is <fr:em>complete</fr:em> if for <fr:tex
display="inline"><![CDATA[A \subset  B]]></fr:tex> if <fr:tex
display="inline"><![CDATA[P(B) = 0]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P(A) = 0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p>You might be wondering when this is not the case because we have subadditivity. However, it is not the case that <fr:tex
display="inline"><![CDATA[P(A) > 0]]></fr:tex> but instead that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is not measurable. As an example,</fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1697</fr:anchor><fr:addr
type="user">kak-001G</fr:addr><fr:route>kak-001G.xml</fr:route><fr:title
text="Vitali Sets">Vitali Sets</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If we consider <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>, then we can partition <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> into equivalent classes as <fr:tex
display="inline"><![CDATA[x \sim  y]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x - y = r]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[r \in  \mathbb {Q} \cap  [0, 1]]]></fr:tex>. Denote each of these as <fr:tex
display="inline"><![CDATA[V_{r}]]></fr:tex>. By the <fr:link
type="local"
href="kak-001H.xml"
addr="kak-001H"
title="Axiom of Choice">Axiom of Choice</fr:link>, we can choose one representative from each <fr:tex
display="inline"><![CDATA[V_r]]></fr:tex>. We call the set of these representatives <fr:tex
display="inline"><![CDATA[V]]></fr:tex>. Therefore, we can write <fr:tex
display="inline"><![CDATA[[0, 1]]]></fr:tex> as a countable union via <fr:tex
display="inline"><![CDATA[[0,1] = \bigcup _{r \in  \mathbb {Q}} V + r]]></fr:tex>. For the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>, each <fr:tex
display="inline"><![CDATA[\lambda (V + r) = \lambda (V)]]></fr:tex>. Since each <fr:tex
display="inline"><![CDATA[V + r]]></fr:tex> is disjoint, we have 
<fr:tex
display="block"><![CDATA[\lambda \left (\bigcup _{r \in  \mathbb {Q}} V + r\right ) = \sum _{r \in  \mathbb {Q}} \lambda (V)]]></fr:tex>
If <fr:tex
display="inline"><![CDATA[\lambda (V) = 0]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\lambda ([0,1]) \leq  \lambda (V) = 0]]></fr:tex> which is a contradiction. Otherwise <fr:tex
display="inline"><![CDATA[\lambda  ([0,1]) = \sum _{r \in  \mathbb {Q}} k = \infty ]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[k \in  \mathbb {R}]]></fr:tex>. Thus, <fr:tex
display="inline"><![CDATA[V]]></fr:tex> is not Lebesgue measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>


  
    
    
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1698</fr:anchor><fr:addr
type="machine">#390</fr:addr><fr:route>unstable-390.xml</fr:route><fr:title
text=" [billingsley1986, 3.2]"> <html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="link-reference"
tid="3.2"
refid="billingsley1986"><fr:link
type="local"
href="billingsley1986.xml"
addr="billingsley1986"
title="Probability and Measure">[billingsley1986, 3.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex
display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> and for every subset <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> define <fr:tex
display="inline"><![CDATA[P^{\star }(A)]]></fr:tex> by <fr:link
type="local"
href="kak-000T.xml"
addr="kak-000T"
title="Outer Measure">(3.1)</fr:link>. Denote also by <fr:tex
display="inline"><![CDATA[P]]></fr:tex> the extension of <fr:tex
display="inline"><![CDATA[P]]></fr:tex> to <fr:tex
display="inline"><![CDATA[\mathscr {F}=\sigma (\mathscr {F}_{0})]]></fr:tex>.
  <fr:ol><fr:li>Show that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> if and only if <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>.</fr:li></fr:ol>

</fr:mainmatter><fr:backmatter /></fr:tree>
  


 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1700</fr:anchor><fr:addr
type="machine">#391</fr:addr><fr:route>unstable-391.xml</fr:route><fr:taxon>Solution</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>First suppose that <fr:tex
display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>. We must show that 
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) = P^*(E)]]></fr:tex>
  From part (1) and our hypothesis, <fr:tex
display="inline"><![CDATA[\exists  \overline {A}, \underline {A} \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\underline {A} \subset  A \subset  \overline {A}]]></fr:tex> and <fr:tex
display="block"><![CDATA[P(\overline {A}) = P^*(A) = P_*(A) = P(\underline {A})]]></fr:tex>. Additionally, <fr:tex
display="inline"><![CDATA[\exists  B \in  \mathscr {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[E \subset  B]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P^*(E) = P(B)]]></fr:tex>. Then we have that
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) \leq  P^*(B \cap  \overline {A}) = P(B \cap  \overline {A})]]></fr:tex>
  and
<fr:tex
display="block"><![CDATA[P^*(B \cap  A) \leq  P^*(B \cap  \underline {A}^c) = P(B \cap  \underline {A}^c)]]></fr:tex>
  Thus,
<fr:tex
display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) \leq  P(B \cap  \underline {A}^c) + P(B \cap  \overline {A}) = P^*(E)]]></fr:tex>
  as desired.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 



    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1702</fr:anchor><fr:addr
type="machine">#392</fr:addr><fr:route>unstable-392.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>I really struggled for a minute on even understanding this problem. The import thing to understand for this problem is what space everything is defined on.
<fr:ol><fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> is defined on the initial field <fr:tex
display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>, which is the closure over finite unions and complements of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is defined on the powerset <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex>. <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily a measure on all of these subsets though.
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[E]]></fr:tex> is <fr:strong>NOT</fr:strong> necessarily in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> hence the need for <fr:tex
display="inline"><![CDATA[B]]></fr:tex>.</fr:li></fr:ul></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[P]]></fr:tex> (abuse of notation) is <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> restricted to the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> subsets of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>.</fr:li></fr:ol>
  Common question is why we cannot just apply finite additivity and have everything <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link>? The answer is that <fr:tex
display="inline"><![CDATA[P^*]]></fr:tex> is not countably subadditive on <fr:tex
display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex> but only the <fr:link
type="local"
href="kak-000U.xml"
addr="kak-000U"
title="P^*-measurable"><fr:tex
display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> sets.
</fr:mainmatter><fr:backmatter /></fr:tree>

</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1704</fr:anchor><fr:addr
type="machine">#399</fr:addr><fr:route>unstable-399.xml</fr:route><fr:title
text="Denumerable Probabilities">Denumerable Probabilities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
The results of this section concern infinite sequences of events in a probability space. They will be illustrated by examples in the unit interval. By this will always be meant the triple (<fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P]]></fr:tex>) for which <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> is (0,1), <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field <fr:tex
display="inline"><![CDATA[\mathscr {B}]]></fr:tex> of Borel sets there, and <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is for <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex> the Lebesgue measure <fr:tex
display="inline"><![CDATA[\lambda (A)]]></fr:tex> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. 
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1706</fr:anchor><fr:addr
type="user">kak-001J</fr:addr><fr:route>kak-001J.xml</fr:route><fr:title
text="Conditional Probability">Conditional Probability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A | B) = \frac {P(A \cap  B)}{P(B)}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1707</fr:anchor><fr:addr
type="user">kak-001I</fr:addr><fr:route>kak-001I.xml</fr:route><fr:title
text="Chain Rule of Probability">Chain Rule of Probability</fr:title><fr:taxon>Proposition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P(A \cap  B \cap  C) = P(A)P(B | A)P(C | B \cap  A)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1708</fr:anchor><fr:addr
type="user">kak-001M</fr:addr><fr:route>kak-001M.xml</fr:route><fr:title
text="Limsup of sets">Limsup of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \sup _{n} A_n = \bigcap _{n = 1}^{\infty } \bigcup _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \sup _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex> infinitely often.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1709</fr:anchor><fr:addr
type="user">kak-001N</fr:addr><fr:route>kak-001N.xml</fr:route><fr:title
text="Liminf of sets">Liminf of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex
display="block"><![CDATA[\lim \inf _{n} A_n = \bigcup _{n = 1}^{\infty } \bigcap _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_{n}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is in all but finitely many <fr:tex
display="inline"><![CDATA[A_{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1710</fr:anchor><fr:addr
type="user">kak-001K</fr:addr><fr:route>kak-001K.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For each sequence <fr:tex
display="inline"><![CDATA[\{A_{n}\}]]></fr:tex>,

<fr:tex
display="block"><![CDATA[P\left (\lim \inf _{n}A_{n}\right )\leq \lim _{n}\inf _{n}P\left (\,A_{n}\right ) \leq \lim _{n}\sup _{n}P\left (\,A_{n}\right )\leq  P\left (\lim _{n}\sup _{n}A_{n}\right ).]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1711</fr:anchor><fr:addr
type="machine">#334</fr:addr><fr:route>unstable-334.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    We define <fr:tex
display="inline"><![CDATA[B_n \coloneqq  \bigcup _{k = n}^{\infty } A_k]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B_n]]></fr:tex> as <fr:tex
display="inline"><![CDATA[C_n = \bigcap _{k = n}^{\infty } A_k]]></fr:tex>. Note that <fr:tex
display="inline"><![CDATA[\{B_n\}]]></fr:tex> is a monotonically decreasing sequence to <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[C_n]]></fr:tex> monotonically increases to <fr:tex
display="inline"><![CDATA[\lim \inf _{n} A_n]]></fr:tex>. Therefore, we can apply continuity from below / above such that
<fr:tex
display="block"><![CDATA[     \begin {align*}     \inf _n P(A_n) \geq  P(C_n) \iff  \lim _n \inf _n P(A_n) &\geq  \lim _n P(C_n) \\      &= P(\lim _n C_n) \\      &= P(\lim \inf _n A_n)     \end {align*} ]]></fr:tex>
      Similarly,
<fr:tex
display="block"><![CDATA[       \begin {align*}       \sup _n P(A_n) \leq  P(B_n) \iff  \lim _n \sup _n P(A_n) &\leq  \lim _n P(B_n) \\        &= P(\lim _n B_n) \\        &= P(\lim \sup _n A_n)       \end {align*}   ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1712</fr:anchor><fr:addr
type="user">kak-001O</fr:addr><fr:route>kak-001O.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Independence evolves in the following manner:
  <fr:ol><fr:li>Events <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> are independent if <fr:tex
display="inline"><![CDATA[P(A \cap  B) = P(A)P(B)]]></fr:tex>.</fr:li>
    <fr:li>A finite collection of events are independent if
    <fr:tex
display="block"><![CDATA[P(A_{k_1} \cap  \cdots  \cap  A_{k_j}) = P(A_{k_1}) \cdots  P(A_{k_j})]]></fr:tex></fr:li>
    <fr:li>A infinite collection of sets is defined to be independent if every finite subcollection is independent.</fr:li>
    <fr:li>Classes <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent if for any events <fr:tex
display="inline"><![CDATA[A_1 \in  \mathscr {A}_1, \ldots , A_n \in  \mathscr {A}_n]]></fr:tex>, <fr:tex
display="inline"><![CDATA[A_1, \ldots , A_n]]></fr:tex> are independent.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1713</fr:anchor><fr:addr
type="user">kak-001P</fr:addr><fr:route>kak-001P.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent and each <fr:tex
display="inline"><![CDATA[\mathscr {A}_i]]></fr:tex> is a <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> then <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1), \ldots , \sigma (\mathscr {A}_n)]]></fr:tex> are independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1714</fr:anchor><fr:addr
type="machine">#333</fr:addr><fr:route>unstable-333.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
We have sequence of independent classes and want to show that their respective <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras are also independent. The idea is to take the class of events <fr:tex
display="inline"><![CDATA[B_1]]></fr:tex> that are independent with <fr:tex
display="inline"><![CDATA[\mathscr {A}_2, \ldots , \mathscr {A}_n]]></fr:tex>, and show that <fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A}_1)]]></fr:tex> is a subset of this class. To do this, we use <fr:link
type="local"
href="kak-001B.xml"
addr="kak-001B"
title="Dynkin's {-}">Dynkin's <fr:tex
display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:link> by noticing that this class is a <fr:link
type="local"
href="kak-0019.xml"
addr="kak-0019"
title="-System"><fr:tex
display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> that contains the <fr:link
type="local"
href="kak-0018.xml"
addr="kak-0018"
title="-System"><fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> <fr:tex
display="inline"><![CDATA[\mathscr {A}_1]]></fr:tex>.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Meaning in english:</fr:strong> In the book, they give the example of even and odd numbered coin tosses. We want to know when a new event only depends on even or odd coin tosses. Concretely, we know that even and odd coin tosses are independent, and we want to know if, for example, the outcome of every fourth coin toss is independent of odd tosses. We can do this rigorously by showing that this event is in the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra of even coin tosses. Then by <fr:link
type="local"
href="kak-001P.xml"
addr="kak-001P">Theorem 5.7</fr:link>, we know that this event is also independent of odd coin tosses.</fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1715</fr:anchor><fr:addr
type="user">kak-001R</fr:addr><fr:route>kak-001R.xml</fr:route><fr:title
text="Array Method">Array Method</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that the array
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} A_{11} & A_{12} & \cdots  \\ A_{21} & A_{22} & \cdots  \\ \vdots  & \vdots  &  \end {array} ]]></fr:tex>
of events is independent. If <fr:tex
display="inline"><![CDATA[\mathscr {F}_1]]></fr:tex> is the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra generated
by the first row then <fr:tex
display="inline"><![CDATA[\mathscr {F}_1, \mathscr {F}_2, \ldots ]]></fr:tex> are
independent.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1716</fr:anchor><fr:addr
type="machine">#331</fr:addr><fr:route>unstable-331.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>Can write events of flip <fr:tex
display="inline"><![CDATA[i]]></fr:tex> as <fr:tex
display="inline"><![CDATA[H_i]]></fr:tex> such that the following array
satisfies the above
<fr:tex
display="block"><![CDATA[ \begin {array}{ccc} H_{2} & H_{4} & \cdots  \\ H_{1} & H_3 & \cdots  \\ \end {array} ]]></fr:tex>
Then row 1 and row 2 are independent from above. Therefore, we have shown that
even and odd numbered flips' <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>'s are independent.
</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1717</fr:anchor><fr:addr
type="machine">#395</fr:addr><fr:route>unstable-395.xml</fr:route><fr:title
text="Subfields">Subfields</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1719</fr:anchor><fr:addr
type="machine">#394</fr:addr><fr:route>unstable-394.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Intuition of subfields are spaces with partial information. My best
memory of this coming up in probability was conditional expectation.
Esssentially, we need to consider the subfield of events conditioned on some
event that already occured.</fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1721</fr:anchor><fr:addr
type="user">kak-001S</fr:addr><fr:route>kak-001S.xml</fr:route><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say that points <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\omega ']]></fr:tex> are <fr:tex
display="inline"><![CDATA[\mathscr {A}]]></fr:tex> equivalent if for
every <fr:tex
display="inline"><![CDATA[A \in  \mathscr {A}]]></fr:tex>,
<fr:tex
display="block"><![CDATA[I_A(\omega ) = I_A(\omega ')]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p>From this definition, we can conclude an observer with the information of
<fr:tex
display="inline"><![CDATA[\sigma (\mathscr {A})]]></fr:tex> has only the information of the equivalence class but
cannot identify a specific point from this class.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1722</fr:anchor><fr:addr
type="machine">#396</fr:addr><fr:route>unstable-396.xml</fr:route><fr:title
text="The Borel-Cantelli Lemmas">The Borel-Cantelli Lemmas</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1724</fr:anchor><fr:addr
type="user">kak-001Q</fr:addr><fr:route>kak-001Q.xml</fr:route><fr:title
text="Borel-Cantelli One">Borel-Cantelli One</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> converges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 0]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1725</fr:anchor><fr:addr
type="machine">#332</fr:addr><fr:route>unstable-332.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n \subset  \bigcup _{k = n}^{\infty } A_k]]></fr:tex>.
    Therefore,
      <fr:tex
display="block"><![CDATA[P(\lim \sup _n A_n) \leq  P\left (\bigcup _{k = n}^{\infty } A_k\right ) \leq        \sum _{k = n}^{\infty } P(A_k)]]></fr:tex>
      Taking <fr:tex
display="inline"><![CDATA[n \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1726</fr:anchor><fr:addr
type="user">kak-001T</fr:addr><fr:route>kak-001T.xml</fr:route><fr:title
text="Borel-Cantelli Two">Borel-Cantelli Two</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex> is an independent sequence of events and <fr:tex
display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> diverges, then <fr:tex
display="inline"><![CDATA[P(\lim \sup _n A_n) = 1]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1727</fr:anchor><fr:addr
type="machine">#330</fr:addr><fr:route>unstable-330.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Consider the complement. By independence, we have
<fr:tex
display="block"><![CDATA[P(\bigcap _{k = n}^{n + m} A_k^c) = \prod _{k = n}^{n + m}(1 - P(A_k)) \leq      \exp (-\sum _{k = n}^{n + m} P(A_k)),]]></fr:tex>
    where the last inequality comes from <fr:tex
display="inline"><![CDATA[1 - x \leq  e^{-x}]]></fr:tex>. Since the series diverges, taking <fr:tex
display="inline"><![CDATA[m \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1728</fr:anchor><fr:addr
type="machine">#398</fr:addr><fr:route>unstable-398.xml</fr:route><fr:title
text="Zero-one Law">Zero-one Law</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1730</fr:anchor><fr:addr
type="user">kak-001U</fr:addr><fr:route>kak-001U.xml</fr:route><fr:title
text="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For a sequence <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of events in a probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> consider the <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-fields <fr:tex
display="inline"><![CDATA[\sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
then their intersection
<fr:tex
display="block"><![CDATA[\mathscr {T} = \bigcap _{n = 1}^{\infty } \sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
is the <fr:em>tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:em> associated with the sequence <fr:tex
display="inline"><![CDATA[\{A_n\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1731</fr:anchor><fr:addr
type="machine">#397</fr:addr><fr:route>unstable-397.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>The <fr:tex
display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim \inf _n A_n]]></fr:tex> are both tail events.</fr:mainmatter><fr:backmatter /></fr:tree>
 

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1733</fr:anchor><fr:addr
type="user">kak-001V</fr:addr><fr:route>kak-001V.xml</fr:route><fr:title
text="Kolmogorov's Zero-one Law">Kolmogorov's Zero-one Law</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> is an independent sequence of events, then for each
event <fr:tex
display="inline"><![CDATA[A]]></fr:tex> in the <fr:link
type="local"
href="kak-001U.xml"
addr="kak-001U"
title="Tail -field">Tail <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, <fr:tex
display="inline"><![CDATA[P(A)]]></fr:tex> is either <fr:tex
display="inline"><![CDATA[0]]></fr:tex> or <fr:tex
display="inline"><![CDATA[1]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1734</fr:anchor><fr:addr
type="machine">#410</fr:addr><fr:route>unstable-410.xml</fr:route><fr:title
text="Random Variables">Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1736</fr:anchor><fr:addr
type="user">kak-001W</fr:addr><fr:route>kak-001W.xml</fr:route><fr:title
text="Simple Random Variable">Simple Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> be an arbitrary probability space, and let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a real-valued function on <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex>. <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a simple random variable if it has finite range and if 
<fr:tex
display="block"><![CDATA[\left [\omega  \mid  X(\omega ) = x \right ] \in  \mathscr {F}]]></fr:tex>
for each <fr:tex
display="inline"><![CDATA[x]]></fr:tex> in its finite range.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1737</fr:anchor><fr:addr
type="machine">#400</fr:addr><fr:route>unstable-400.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider the function 
    <fr:tex
display="block"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex>
    If <fr:tex
display="inline"><![CDATA[A_i]]></fr:tex> are finite partition of <fr:tex
display="inline"><![CDATA[\Omega ]]></fr:tex> into <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-sets, then inverse image is at most countable union of the A_i's, which is an <fr:tex
display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set. Therefore, this function is measurable.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1739</fr:anchor><fr:addr
type="user">kak-0022</fr:addr><fr:route>kak-0022.xml</fr:route><fr:title
text="Finite Sequence Measurability">Finite Sequence Measurability</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_1, \ldots , X_n]]></fr:tex> be <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s
<fr:ol><fr:li>The <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> consists of the sets
<fr:tex
display="block"><![CDATA[\left [(X_1, \ldots , X_n) \in  H\right ] = \left [\omega  \mid  (X_1(\omega ), \ldots , X_n(\omega )) \in  H\right ]]]></fr:tex>
    for <fr:tex
display="inline"><![CDATA[H \subset  \mathbb {R}^n]]></fr:tex>.</fr:li>
    <fr:li>A simple random variable <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is measurable <fr:tex
display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> if and only if 
<fr:tex
display="block"><![CDATA[Y = f(X_1, \ldots , X_n)]]></fr:tex>
    for some <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex>.</fr:li></fr:ol></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1740</fr:anchor><fr:addr
type="user">kak-001X</fr:addr><fr:route>kak-001X.xml</fr:route><fr:title
text="-Field of RV"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field of RV</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field generated by a <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is the smallest <fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field such that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> is <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">measurable</fr:link>. For a sequence of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s, the <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> generated by them is the smallest <fr:link
type="local"
href="kak-000O.xml"
addr="kak-000O"
title="-Field"><fr:tex
display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, such that each of the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s is measurable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1741</fr:anchor><fr:addr
type="machine">#404</fr:addr><fr:route>unstable-404.xml</fr:route><fr:title
text="Convergence of Random Variables">Convergence of Random Variables</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
In probability, rather than standard convergence, we actually can consider convergence with high probability or almost surely (should come up later). Formally, we care about measuring the probability of the event <fr:tex
display="inline"><![CDATA[\{\omega  \mid  \lim _n X_n(\omega ) \to  X(\omega )\}]]></fr:tex>. The first question we must ask is whether this set is measurable. They do not really cover this in the textbook, but it is an important trick that comes up a lot.

   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1743</fr:anchor><fr:addr
type="machine">#401</fr:addr><fr:route>unstable-401.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
We consider the complement. Note that the sequence of random variables not converging can be written as <fr:tex
display="inline"><![CDATA[\forall  \epsilon , \exists  n]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[|X_n(\omega ) - X(\omega )| \geq  \epsilon ]]></fr:tex>. For a fixed <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>, this is the <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of the sequence <fr:tex
display="inline"><![CDATA[A_n \coloneqq  [|X_n - X| \geq  \epsilon ]]]></fr:tex>. We know that <fr:tex
display="inline"><![CDATA[\lim \sup ]]></fr:tex> of measurable sequence is measurable because it is a countable intersection of countable unions. Therefore, the last thing we need is to show for all <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>. This can be done just using rationals because <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is <fr:link
type="local"
href="kak-001Y.xml"
addr="kak-001Y"
title="Dense Subset">dense</fr:link> in <fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex>. Then we have a countable union of countable sets as desired.
  </fr:mainmatter><fr:backmatter /></fr:tree>
 


    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1745</fr:anchor><fr:addr
type="user">kak-001Z</fr:addr><fr:route>kak-001Z.xml</fr:route><fr:title
text="Almost Sure Convergence">Almost Sure Convergence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>almost surely</fr:em> if 
<fr:tex
display="block"><![CDATA[P(X_n \to  X) = 1]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1746</fr:anchor><fr:addr
type="user">kak-0020</fr:addr><fr:route>kak-0020.xml</fr:route><fr:title
text="Convergence in Probability">Convergence in Probability</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> converges <fr:em>in probability</fr:em> if for every <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>
<fr:tex
display="block"><![CDATA[\lim _{n \to  \infty } P(|X_n - X| > \epsilon ) = 0]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1747</fr:anchor><fr:addr
type="machine">#402</fr:addr><fr:route>unstable-402.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        By <fr:link
type="local"
href="kak-001K.xml"
addr="kak-001K">Theorem 5.5</fr:link>, almost sure convergence <fr:tex
display="inline"><![CDATA[\implies ]]></fr:tex> convergence in probability. Converse is NOT true.
      </fr:mainmatter><fr:backmatter /></fr:tree>

      
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1749</fr:anchor><fr:addr
type="machine">#403</fr:addr><fr:route>unstable-403.xml</fr:route><fr:taxon>Example</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Can make array of rows, where the <fr:tex
display="inline"><![CDATA[n]]></fr:tex>th row consists of <fr:tex
display="inline"><![CDATA[n]]></fr:tex> intervals that evenly divide <fr:tex
display="inline"><![CDATA[[0,1]]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[P(A_n) \to  0]]></fr:tex> but <fr:tex
display="inline"><![CDATA[[A_n \text { i.o}] = [0,1]]]></fr:tex> </fr:mainmatter><fr:backmatter /></fr:tree>
 

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1751</fr:anchor><fr:addr
type="machine">#405</fr:addr><fr:route>unstable-405.xml</fr:route><fr:title
text="Independence">Independence</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1753</fr:anchor><fr:addr
type="user">kak-0021</fr:addr><fr:route>kak-0021.xml</fr:route><fr:title
text="Independence of Random Variable">Independence of Random Variable</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A sequence of random variables <fr:tex
display="inline"><![CDATA[X_1, X_2, \ldots ]]></fr:tex> is <fr:em>independent</fr:em> if the classes <fr:tex
display="inline"><![CDATA[\sigma (X_1), \sigma (X_2), \ldots ]]></fr:tex> are <fr:link
type="local"
href="kak-001O.xml"
addr="kak-001O"
title="Independence">independent</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1754</fr:anchor><fr:addr
type="machine">#407</fr:addr><fr:route>unstable-407.xml</fr:route><fr:title
text="Existence of Independent Sequences">Existence of Independent Sequences</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1756</fr:anchor><fr:addr
type="user">kak-0023</fr:addr><fr:route>kak-0023.xml</fr:route><fr:title
text="Distribution">Distribution</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>distribution</fr:em> of a simple random variable <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the probability measure <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex> defined for all subsets <fr:tex
display="inline"><![CDATA[A]]></fr:tex> of the line by 
<fr:tex
display="block"><![CDATA[\mu (A) = P[X \in  A]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
        <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1757</fr:anchor><fr:addr
type="user">kak-0024</fr:addr><fr:route>kak-0024.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{\mu _n\}]]></fr:tex> be a sequence of probability measures on the class of all subsets of the line, each having finite support. There exists some probability space <fr:tex
display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> an independent sequence <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> of <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link>'s such that <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> has distribution <fr:tex
display="inline"><![CDATA[\mu _n]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Guess for english translation</fr:strong>: I think what this is saying is that rather than try to define a probability space for a random variable, we can instead just pick probability measures and know that the <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> come for free? i.e. (from the book) we can just define a trivial space <fr:tex
display="inline"><![CDATA[\Omega  = \{1, 0\}]]></fr:tex> and probability measure <fr:tex
display="inline"><![CDATA[P(1) = p]]></fr:tex>, <fr:tex
display="inline"><![CDATA[P(0) = 1 - p]]></fr:tex> and know that we can get a Bernoulli random variable? In this case <fr:tex
display="inline"><![CDATA[X(1) = 1]]></fr:tex>, <fr:tex
display="inline"><![CDATA[X(0) = 0]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P(X = 1) = p]]></fr:tex> and <fr:tex
display="inline"><![CDATA[P(X = 0) = 1 - p]]></fr:tex>?</fr:p>

  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1758</fr:anchor><fr:addr
type="machine">#406</fr:addr><fr:route>unstable-406.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>In the text, they say that the underlying probability space does not really matter. Basically, all calculations are determined by the distribution in range space. So I guess that is also what this theorem is getting at? </fr:mainmatter><fr:backmatter /></fr:tree>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  


  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1760</fr:anchor><fr:addr
type="machine">#408</fr:addr><fr:route>unstable-408.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1762</fr:anchor><fr:addr
type="user">kak-0029</fr:addr><fr:route>kak-0029.xml</fr:route><fr:title
text="Expected Value">Expected Value</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:link
type="local"
href="kak-001W.xml"
addr="kak-001W"
title="Simple Random Variable">Simple Random Variable</fr:link> of the form <fr:tex
display="inline"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex> is assigned expected value as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \mathbb {E}\left [\sum _i x_i I_{A_i} \right ] = \sum _i x_i P(A_i)]]></fr:tex>
More generally, if <fr:tex
display="inline"><![CDATA[f(X) = \sum _i f(x_i) I_{A_i}]]></fr:tex> then
<fr:tex
display="block"><![CDATA[\mathbb {E}\left [f(X)\right ] = \sum _i f(x_i) P(A_i) = \sum _x f(x) P[X = x]]]></fr:tex>
A useful identity is as follows:
<fr:tex
display="block"><![CDATA[\mathbb {E}[X] = \int _0^{\infty } P[X \geq  x] \mathrm {d}x]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1763</fr:anchor><fr:addr
type="user">kak-002A</fr:addr><fr:route>kak-002A.xml</fr:route><fr:title
text="Kth Moment"><fr:tex
display="inline"><![CDATA[k]]></fr:tex>th Moment</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We define the <fr:tex
display="inline"><![CDATA[k]]></fr:tex>th moment of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> as 
<fr:tex
display="block"><![CDATA[\mathbb {E}[X^k] = \sum _y y P[X^k = y]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1764</fr:anchor><fr:addr
type="user">kak-002B</fr:addr><fr:route>kak-002B.xml</fr:route><fr:title
text="Uniformly Bounded">Uniformly Bounded</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\exists  K]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X_n(\omega ) \leq  K]]></fr:tex> for every <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[n]]></fr:tex> then the <fr:tex
display="inline"><![CDATA[X_n]]></fr:tex> are <fr:em>uniformly bounded</fr:em>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1765</fr:anchor><fr:addr
type="user">kak-002C</fr:addr><fr:route>kak-002C.xml</fr:route><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\{X_n\}]]></fr:tex> is uniformly bounded, and if <fr:tex
display="inline"><![CDATA[X = \lim _n X_n]]></fr:tex> with probability <fr:tex
display="inline"><![CDATA[1]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbb {E}[X] = \lim _n \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1766</fr:anchor><fr:addr
type="machine">#409</fr:addr><fr:route>unstable-409.xml</fr:route><fr:title
text="Inequalities">Inequalities</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1768</fr:anchor><fr:addr
type="user">kak-002E</fr:addr><fr:route>kak-002E.xml</fr:route><fr:title
text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[X \geq  \alpha ] \leq  \frac {1}{\alpha } \mathbb {E}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1769</fr:anchor><fr:addr
type="user">kak-002F</fr:addr><fr:route>kak-002F.xml</fr:route><fr:title
text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[P[|X - m| \geq  \alpha ] \leq  \frac {1}{\alpha ^2} \mathrm {Var}[X]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1770</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1771</fr:anchor><fr:addr
type="user">kak-002H</fr:addr><fr:route>kak-002H.xml</fr:route><fr:title
text="Holder's Inequality">Holder's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:tex
display="block"><![CDATA[\frac {1}{p} + \frac {1}{q} = 1, \quad  p > 1,\ q > 1]]></fr:tex>
Then <fr:em>Holder's inequality</fr:em> is
<fr:tex
display="block"><![CDATA[\mathbb {E}[XY] \leq  \left (\mathbb {E}[|X|^p]\right )^{1/p} \cdot  \left (\mathbb {E}[|Y|^q]\right )^{1/q}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  
 
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1772</fr:anchor><fr:addr
type="machine">#411</fr:addr><fr:route>unstable-411.xml</fr:route><fr:title
text="The Law of Large Numbers">The Law of Large Numbers</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2294</fr:anchor><fr:addr
type="user">kak-004H</fr:addr><fr:route>kak-004H.xml</fr:route><fr:title
text="Notes on Systems Programming">Notes on Systems Programming</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>782</fr:anchor><fr:addr
type="machine">#273</fr:addr><fr:route>unstable-273.xml</fr:route><fr:title
text="Reading List / Useful Resources">Reading List / Useful Resources</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:ul><fr:li><fr:link
type="external"
href="https://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://wiki-prog.infoprepa.epita.fr/images/0/04/Malloc_tutorial.pdf">A Malloc Tutorial</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://github.com/DoctorWkt/acwj">A compiler writing journey</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://www.jmeiners.com/lc3-vm/">Writing your own Virtual Machine</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="http://www.catb.org/esr/structure-packing/">Struct alignment in C</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://maplant.com/2020-04-25-Writing-a-Simple-Garbage-Collector-in-C.html">Write a Simple Garbage Collector</fr:link></fr:li>
      <fr:li><fr:link
type="external"
href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c">Virual function explanation</fr:link></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>783</fr:anchor><fr:addr
type="user">kak-004I</fr:addr><fr:route>kak-004I.xml</fr:route><fr:title
text="Virtual Memory">Virtual Memory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>In my foray into C programming, I have become thoroughly confused with virtual memory and the like. Mainly, what is malloc really doing? In the minimap2 library, they implement essentially their own memory management on top of malloc. The reason for this is what had me confused. I think the following summarizes my findings:
  <fr:ul><fr:li>When a process is started by the OS, it allocates virtual address space for the process.</fr:li>
    <fr:li>Within this virtual address space, malloc allocates memory on the heap. Namely, just returning a pointer (technically virtual address) to a block of memory of the desired size.</fr:li>
    <fr:ul><fr:li>Malloc is an OS system call and therefore stops execution of all threads.</fr:li>
      <fr:li>To get around this, they pre-allocate their own intra-thread memory (a large contiguous chunk) then allocate memory within this chunk throughout the program.</fr:li></fr:ul></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>785</fr:anchor><fr:addr
type="user">kak-0025</fr:addr><fr:route>kak-0025.xml</fr:route><fr:title
text="Stack vs. Heap">Stack vs. Heap</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>I often hear this question come up amongst performance-driven developers, and for the longest time I could never get a straight answer as to why the stack was so much better? After a long foray into the inner workings of how memory allocation is actually done, I think I finally have an answer. I do not want to forget this, so I am doing a quick write up here.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>786</fr:anchor><fr:addr
type="machine">#329</fr:addr><fr:route>unstable-329.xml</fr:route><fr:title
text="Why stack is faster.">Why stack is faster.</fr:title><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
This all comes down to memory allocation. Prior to actually running the program, the operating system allocates some amount of memory for both the stack and the heap (I think around 2-4MB?).
<fr:ul><fr:li>Stack just increments stack pointer.</fr:li>
    <fr:li>Heap searches through <fr:link
type="external"
href="https://gee.cs.oswego.edu/dl/html/malloc.html">bins</fr:link>. 
    <fr:ul><fr:li>Apparently malloc is implemented via the <fr:link
type="external"
href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">buddy algorithm</fr:link></fr:li>
        <fr:li>TODO: Look into this more.</fr:li></fr:ul></fr:li>
    <fr:li>Real speedup is when heap runs out of pre-allocated memory.
    <fr:ul><fr:li>Has to trap to OS to get more memory. Page-fault can result in write to disk and therefore eternal misery...</fr:li>
      <fr:li>Formally, this is known as "heap growth".</fr:li></fr:ul></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2295</fr:anchor><fr:addr
type="user">kak-004B</fr:addr><fr:route>kak-004B.xml</fr:route><fr:title
text="Information Theory">Information Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>501</fr:anchor><fr:addr
type="machine">#282</fr:addr><fr:route>unstable-282.xml</fr:route><fr:title
text="Lecture 5">Lecture 5</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>503</fr:anchor><fr:addr
type="user">kak-004C</fr:addr><fr:route>kak-004C.xml</fr:route><fr:title
text="Convex set">Convex set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[C]]></fr:tex> is said to be convex if for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex> then <fr:tex
display="inline"><![CDATA[\lambda  x_1 + (1 - \lambda )x_2 \in  C]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr
type="user">kak-004D</fr:addr><fr:route>kak-004D.xml</fr:route><fr:title
text="Convex Function">Convex Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex
display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex
display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>505</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr
type="machine">#277</fr:addr><fr:route>unstable-277.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    This can be thought of as the tangent is always an underestimate of a convex function.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>509</fr:anchor><fr:addr
type="machine">#278</fr:addr><fr:route>unstable-278.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  This implies positive curvature or the common "bowl-shaped" interpretation.
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>511</fr:anchor><fr:addr
type="user">kak-002G</fr:addr><fr:route>kak-002G.xml</fr:route><fr:title
text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> then <fr:tex
display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr
type="machine">#279</fr:addr><fr:route>unstable-279.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Holds with equality if and only if 
    <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f]]></fr:tex> is linear on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a constant almost surely.</fr:li></fr:ol>
  </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr
type="user">kak-004E</fr:addr><fr:route>kak-004E.xml</fr:route><fr:title
text="Gibb's inequality">Gibb's inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[D_{\mathrm {KL}}(P || Q) \geq  0]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>515</fr:anchor><fr:addr
type="machine">#276</fr:addr><fr:route>unstable-276.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Note that 
<fr:tex
display="block"><![CDATA[ \begin {align*}  D_{\mathrm {KL}}(P || Q) &= \mathbb {E}_P \left [\log \left (\frac {P(x)}{Q(x)}\right )\right ] \\ &= \mathbb {E}_P \left [-\log \left (\frac {Q(x)}{P(x)}\right )\right ] \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-002G.xml"
addr="kak-002G"
title="Jensen's Inequality">Jensen's Inequality</fr:link>,
<fr:tex
display="block"><![CDATA[   \begin {align*}     D_{\mathrm {KL}}(P || Q) &\geq  -\log  \left (\mathbb {E}_P \left [\frac {Q(x)}{P(x)}\right ]\right ) = 0   \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr
type="machine">#280</fr:addr><fr:route>unstable-280.xml</fr:route><fr:taxon>Problem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  When is <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q) = 0]]></fr:tex>?
</fr:mainmatter><fr:backmatter /></fr:tree>


    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr
type="machine">#281</fr:addr><fr:route>unstable-281.xml</fr:route><fr:taxon>Answer</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Need <fr:tex
display="inline"><![CDATA[Q(x) / P(x)]]></fr:tex> to be constant almost surely. This occurs only when <fr:tex
display="inline"><![CDATA[Q = P]]></fr:tex>. 
    <fr:tex
display="block"><![CDATA[         Q(x) / P(x) = c \implies  Q(x) = P(x) c \iff  \sum  Q(x) = c \sum  P(x) \implies  c = 1       ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>

  <fr:strong>Applications of <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[I(X; Y) \geq  0]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X | Y) \leq  H(X)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X^n) \leq  \sum _{i = 1}^n H(X_i)]]></fr:tex></fr:li>
    <fr:li><fr:tex
display="inline"><![CDATA[H(X) \leq  \log  |\mathcal {X}|]]></fr:tex></fr:li></fr:ul>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">kak-004F</fr:addr><fr:route>kak-004F.xml</fr:route><fr:title
text="Log-Sum Inequality">Log-Sum Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[a_{i},b_{i}>0]]></fr:tex> for <fr:tex
display="inline"><![CDATA[i\in \{1,\ldots ,n\}]]></fr:tex>; <fr:tex
display="inline"><![CDATA[A=\sum _{i=1}^{n}a_{i},\quad  B=\sum _{i=1}^{n}b_{i}]]></fr:tex>
Then, we have: <fr:tex
display="inline"><![CDATA[\sum _{i=1}^{n}a_{i}\log  a_{i}/b_{i}\geq  A\log  A/B]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>521</fr:anchor><fr:addr
type="machine">#275</fr:addr><fr:route>unstable-275.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Define <fr:tex
display="inline"><![CDATA[p_i = \frac {a_i}{A}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[q_i = \frac {b_i}{B}]]></fr:tex>, then 
<fr:tex
display="block"><![CDATA[ \begin {align*}   D_{\mathrm {KL}}(p || q) &= \sum  \frac {a_i}{A} \log {\frac {B a_i}{A b_i}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \sum  \frac {a_i}{A} \log {\frac {A}{B}} \\   &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \\ \end {align*} ]]></fr:tex>
By <fr:link
type="local"
href="kak-004E.xml"
addr="kak-004E"
title="Gibb's inequality">Gibb's inequality</fr:link>,
<fr:tex
display="block"><![CDATA[ \begin {align*}   \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \geq  0   &\implies    \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} \geq  \log {\frac {A}{B}} \\   &\iff    A \sum  a_i \log {\frac {a_i}{b_i}} \geq  A \log {\frac {A}{B}} \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:strong>Consequences of <fr:link
type="local"
href="kak-004F.xml"
addr="kak-004F"
title="Log-Sum Inequality">Log-Sum Inequality</fr:link>:</fr:strong>
  <fr:ul><fr:li>Joint convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>,</fr:li>
      <fr:li>Individual convexity of <fr:tex
display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>.</fr:li>
      <fr:li>Concavity of entropy.</fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr
type="machine">#285</fr:addr><fr:route>unstable-285.xml</fr:route><fr:title
text="Lecture 7">Lecture 7</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr
type="user">kak-004Y</fr:addr><fr:route>kak-004Y.xml</fr:route><fr:title
text="Maximum Aposteriori Estimator">Maximum Aposteriori Estimator</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The optimal estimator <fr:tex
display="inline"><![CDATA[g^* : \mathcal {Y} \to  \mathcal {X}]]></fr:tex> is
<fr:tex
display="block"><![CDATA[ \begin {align*}   g*(y) = \arg \max _{x \in  \mathcal {X}} P_{X | Y}(x | y) \end {align*} ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>525</fr:anchor><fr:addr
type="machine">#266</fr:addr><fr:route>unstable-266.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    Recall that
<fr:tex
display="block"><![CDATA[     \begin {align*}       P_{e}(g) &= \sum _{x}\sum _y P_{XY}(x, y) \cdot  \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) \sum _{x} P_{X|Y}(x|y) \mathbf {1}_{x \neq  g(y)} \\       &= \sum _{y} P_Y(y) (1 - P_{X|Y}(g(y)|y)) \\     \end {align*} ]]></fr:tex>
To minimize this, we take
<fr:tex
display="block"><![CDATA[   \begin {align*}     g^*(y) = \arg \max _{x} P_{X|Y}(x | y)   \end {align*} ]]></fr:tex>
as desired.
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr
type="machine">#283</fr:addr><fr:route>unstable-283.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    High-level
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[Y]]></fr:tex> contains more information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> than <fr:tex
display="inline"><![CDATA[\hat {X}]]></fr:tex>.</fr:li>
        <fr:li>We cannot increase the amount of information about <fr:tex
display="inline"><![CDATA[X]]></fr:tex> by processing <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:li></fr:ul>
    <fr:strong>Markov Chains:</fr:strong>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[(U, V, W)]]></fr:tex> form a Markov chain if
        <fr:tex
display="block"><![CDATA[ \begin {align*}   P(W = w \mid  U = u, V = v) = P(w = w \mid  V = v) \end {align*}           ]]></fr:tex>
Denoted <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>.</fr:li>
          <fr:li>Equivalently, we say <fr:tex
display="inline"><![CDATA[(U \perp  W) | V]]></fr:tex> which means <fr:tex
display="block"><![CDATA[              P(W = w, U=u \mid  V = v) \implies  P(W = w \mid  V = v)P(U = u \mid  V = v)           ]]></fr:tex></fr:li>
          <fr:li>Reversibility: <fr:tex
display="inline"><![CDATA[U \to  V \to  W \iff  W \to  V \to  U]]></fr:tex>.</fr:li>
          <fr:li>Estimation: <fr:tex
display="inline"><![CDATA[X \to  Y \to  \hat {X}]]></fr:tex></fr:li></fr:ul> 

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr
type="user">kak-004Z</fr:addr><fr:route>kak-004Z.xml</fr:route><fr:title
text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[I(U; W) \leq  I(U; V)]]></fr:tex>.</fr:p><fr:p><fr:strong>Intuition:</fr:strong> by data processing, we can never create new information about <fr:tex
display="inline"><![CDATA[U]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>529</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Use chain rule to expand <fr:tex
display="inline"><![CDATA[I(U; (V, W))]]></fr:tex> in two ways i.e. 
<fr:tex
display="block"><![CDATA[   \begin {align*}     I(U; (V, W)) = I(U; V) + I(U; W | V) = I(U; W) + I(U; V | W)   \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[U \to  V \to  W]]></fr:tex> is a Markov chain, <fr:tex
display="inline"><![CDATA[I(U; W | V) = 0]]></fr:tex>. Therefore,
<fr:tex
display="block"><![CDATA[ \begin {align*}   I(U; V)  &= I(U; W) + I(U; V | W) \\ &\geq  I(U; W) \end {align*} ]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  


  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>530</fr:anchor><fr:addr
type="machine">#284</fr:addr><fr:route>unstable-284.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[H(X | Y)]]></fr:tex> controls the error probability <fr:tex
display="inline"><![CDATA[P_e]]></fr:tex>.</fr:li></fr:ul>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>532</fr:anchor><fr:addr
type="user">kak-0050</fr:addr><fr:route>kak-0050.xml</fr:route><fr:title
text="Fano's Inequality">Fano's Inequality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that <fr:tex
display="inline"><![CDATA[X \iff  Y \iff  \hat {X}]]></fr:tex> and let <fr:tex
display="inline"><![CDATA[p_e = \mathbb {P}(X \neq  \hat {X})]]></fr:tex>. Then, we have 
  <fr:tex
display="block"><![CDATA[       \begin {align*}         H(p_e) + p_e \log (|\mathcal {X}| - 1) \geq  H(X \mid  \hat {X}) \geq  H(X \mid  Y)       \end {align*}     ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>533</fr:anchor><fr:addr
type="machine">#286</fr:addr><fr:route>unstable-286.xml</fr:route><fr:title
text="Asymptotic Equipartion Propery">Asymptotic Equipartion Propery</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>535</fr:anchor><fr:addr
type="user">kak-0051</fr:addr><fr:route>kak-0051.xml</fr:route><fr:title
text="Weak Law of Large Numbers">Weak Law of Large Numbers</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[\frac {1}{n}\sum _{i=1}^{n}X_{i}\stackrel {{p}}{{\rightarrow }}\mu ]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>536</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    By <fr:link
type="local"
href="kak-002F.xml"
addr="kak-002F"
title="Chebyshev's Inequality">Chebyshev's Inequality</fr:link>,
    <fr:tex
display="block"><![CDATA[     \begin {align*}       \mathbb {P}(|\hat {X} - \mu | > a) \leq  -\frac {\sigma ^2}{a^2}     \end {align*}     ]]></fr:tex>
    Since <fr:tex
display="inline"><![CDATA[X_i]]></fr:tex>'s are independent, 
<fr:tex
display="block"><![CDATA[\mathrm {Var}[\hat {X}] = \frac {1}{n^2} \sum _{i = 1}^{n} \mathrm {Var}[X_i]]]></fr:tex>
    Therefore,
<fr:tex
display="block"><![CDATA[     \begin {align*}       \lim _{n \to  \infty } \mathbb {P}(|\hat {X} - \mu | > a) \leq  \lim _{n \to  \infty }-\frac {\sigma ^2}{n a^2} \to  0     \end {align*} ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>537</fr:anchor><fr:addr
type="user">kak-0052</fr:addr><fr:route>kak-0052.xml</fr:route><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex
display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Let <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> be any function, such that <fr:tex
display="inline"><![CDATA[\mathrm {Var}(f(X))=\sigma _{f}^{2}<\infty ]]></fr:tex>. Then,
<fr:tex
display="block"><![CDATA[\frac {1}{n} \sum _{i = 1}^{n} f(X_i) \stackrel {p}{\rightarrow } \mathbb {E}[f(X)]]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>538</fr:anchor><fr:addr
type="user">kak-0053</fr:addr><fr:route>kak-0053.xml</fr:route><fr:title
text="Continuous Mapping Theorem">Continuous Mapping Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X_{n}\stackrel {{p}}{{\rightarrow }}X]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> denote a continuous function. Then,
<fr:tex
display="block"><![CDATA[f(X_n) \stackrel {p}{\rightarrow } f(X)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>539</fr:anchor><fr:addr
type="user">kak-0054</fr:addr><fr:route>kak-0054.xml</fr:route><fr:title
text="AEP Theorem">AEP Theorem</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex> denote i.i.d. <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with distribution <fr:tex
display="inline"><![CDATA[P_{X}]]></fr:tex>. Then,

<fr:tex
display="block"><![CDATA[ \begin {align*}  \lim _{n\to \infty }-\frac {1}{n}\log  p_{X^{n}}(X_{1},\ldots ,X_{n}) &= \lim _{n \to  \infty } -\frac {1}{n} \log  \prod _{i = 1}^{n} P_X(X_i) \\  &= \mathbb {E}_{X \sim  p_X}[-\log  p_X(X)] \\   &= H(X) \end {align*} ]]></fr:tex>
Equivalently, for large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>
<fr:tex
display="block"><![CDATA[   \begin {align*}     \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon    \end {align*} ]]></fr:tex>
with high probability.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>540</fr:anchor><fr:addr
type="user">kak-0055</fr:addr><fr:route>kak-0055.xml</fr:route><fr:title
text="-Typical set"><fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Fix an <fr:tex
display="inline"><![CDATA[\epsilon >0]]></fr:tex>. Then, an <fr:tex
display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set with respect to the pmf <fr:tex
display="inline"><![CDATA[p_{X}]]></fr:tex>, denoted by <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}]]></fr:tex>, is defined as
<fr:tex
display="block"><![CDATA[\left \{X^n \in  \mathcal {X}^n \mid  \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon  \right \}]]></fr:tex>
Alternatively,
<fr:tex
display="block"><![CDATA[A_{\epsilon ^{(n)}} = \left \{X^n \in  \mathcal {X}^n \mid  2^{-n(H(X) + \epsilon )} \leq  p_{X^n}(X^n) \leq  2^{-n(H(X) - \epsilon )}\right \}]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>541</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  We have the following important properties
  <fr:ol><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)})\geq 1-\epsilon {\text { for large enough }}n]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{c}^{(n)}|\leq 2^{n(H(X)+\epsilon )}]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[|A_{\epsilon }^{(n)}|\geq (1-\epsilon )2^{n(H(X)-\epsilon )}\;\text {for large enough }\;n\;,]]></fr:tex></fr:li></fr:ol>
    Together, this says that, depending on the entropy, the typical set can contain most of the probability despite being much smaller than the entire space.
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>interpretation:</fr:strong> <fr:tex
display="inline"><![CDATA[A_{\epsilon }^{(n)}\,\text { is a subset of }\,{\mathcal {X}}^{n}]]></fr:tex>
<fr:ul><fr:li>Contains almost all the probability.</fr:li>
    <fr:li>Consists of <fr:tex
display="inline"><![CDATA[\approx  2^{nH(X)}]]></fr:tex></fr:li>
    <fr:li>Almost equiprobable sequences.</fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>542</fr:anchor><fr:addr
type="user">kak-0056</fr:addr><fr:route>kak-0056.xml</fr:route><fr:title
text="High probability sets">High probability sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[B_{\epsilon }^{(n)}\subset \mathcal {X}^{n}]]></fr:tex> be the smallest set with probability at least <fr:tex
display="inline"><![CDATA[1-\epsilon ]]></fr:tex>. Then, we must have

<fr:tex
display="block"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)}\cap  B_{\epsilon }^{(n)})\geq 1-2\epsilon ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>543</fr:anchor><fr:addr
type="machine">#287</fr:addr><fr:route>unstable-287.xml</fr:route><fr:title
text="Fixed-rate lossless source coding">Fixed-rate lossless source coding</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>545</fr:anchor><fr:addr
type="user">kak-0059</fr:addr><fr:route>kak-0059.xml</fr:route><fr:title
text="Coding system">Coding system</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A coding system with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> consist of an encoder and a decoder, where an encoder is a function
<fr:tex
display="block"><![CDATA[   e: \mathcal {X}^n \to  \{1, 2, \ldots , \theta \} ]]></fr:tex>
and a decoder is a function 
<fr:tex
display="block"><![CDATA[f: \{1, 2, \ldots , \theta \} \to  \mathcal {X}^n]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:p><fr:strong>Performance:</fr:strong>
    <fr:ul><fr:li>Rate = <fr:tex
display="inline"><![CDATA[\frac {\log _2 \theta }{n}]]></fr:tex></fr:li>
        <fr:li>Probability of decoding error = <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n|]]></fr:tex></fr:li></fr:ul></fr:p>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>546</fr:anchor><fr:addr
type="user">kak-005A</fr:addr><fr:route>kak-005A.xml</fr:route><fr:title
text="Achievability">Achievability</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex> (perturbation parameter) there exists a block length <fr:tex
display="inline"><![CDATA[N(\epsilon )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\forall  n > N(\epsilon )]]></fr:tex> the following holds
<fr:ul><fr:li>There exists an <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding system</fr:link> such that <fr:tex
display="inline"><![CDATA[\frac {\log  \theta }{n} < R + \epsilon ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n| < \epsilon ]]></fr:tex>.</fr:li></fr:ul></fr:p><fr:p>Alternatively, a positive real number <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is said to be <fr:em>achievable</fr:em> if there exists a sequence of <fr:link
type="local"
href="kak-0059.xml"
addr="kak-0059"
title="Coding system">coding systems</fr:link> <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log  \theta }{n} \to  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lim _{n \to  \infty } \mathbb {P}|\hat {X}^n \neq  X^n| \to  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>547</fr:anchor><fr:addr
type="user">kak-005B</fr:addr><fr:route>kak-005B.xml</fr:route><fr:title
text="Minimum rate of source coding">Minimum rate of source coding</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>minimum rate of source coding</fr:em> <fr:tex
display="inline"><![CDATA[R_s]]></fr:tex> is the infimum over all <fr:tex
display="inline"><![CDATA[R]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link> i.e.  
<fr:tex
display="block"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>548</fr:anchor><fr:addr
type="user">kak-005C</fr:addr><fr:route>kak-005C.xml</fr:route><fr:title
text="Entropy as MRSC">Entropy as <fr:link
type="local"
href="kak-005B.xml"
addr="kak-005B"
title="Minimum rate of source coding">MRSC</fr:link></fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:tex
display="block"><![CDATA[R_s = H(P_X) = H(X) = -\sum _{x \in  \mathcal {X}} P_X(x) \log  P_X(x)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>497</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:p>First we will show that <fr:tex
display="inline"><![CDATA[H(X)]]></fr:tex> is <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. Then we will have <fr:tex
display="inline"><![CDATA[R_s \leq  H(X)]]></fr:tex> by definition. Idea: take <fr:tex
display="inline"><![CDATA[\theta  = 2^{n(H(X) + \epsilon )} + 1]]></fr:tex>. Give each element in typical set a unique index, everything else the same index. By properties of typical set, <fr:tex
display="inline"><![CDATA[\mathbb {P}(\text {error}) < \epsilon ]]></fr:tex> for sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex>.</fr:p>
  <fr:p>For the other direction, suppose we have some <fr:tex
display="inline"><![CDATA[R]]></fr:tex> <fr:link
type="local"
href="kak-005A.xml"
addr="kak-005A"
title="Achievability">achievable</fr:link>. By definition, for all <fr:tex
display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, for all sufficiently large <fr:tex
display="inline"><![CDATA[n]]></fr:tex> there exists a [kak-0059] with parameters <fr:tex
display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that
<fr:tex
display="block"><![CDATA[         \begin {align*}           \frac {\log  \theta }{n} < R + \epsilon , \quad  \mathbb {P}(\text {error}) < \epsilon          \end {align*}       ]]></fr:tex>
      Use <fr:link
type="local"
href="kak-0050.xml"
addr="kak-0050"
title="Fano's Inequality">Fano's Inequality</fr:link> to show this is not possible.</fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2297</fr:anchor><fr:addr
type="user">kak-003W</fr:addr><fr:route>kak-003W.xml</fr:route><fr:title
text="LLMs stuff">LLMs stuff</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1005</fr:anchor><fr:addr
type="machine">#299</fr:addr><fr:route>unstable-299.xml</fr:route><fr:title
text="Useful Resources">Useful Resources</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
    <fr:ul><fr:li><fr:link
type="external"
href="https://hijkzzz.notion.site/rlhf-implementation-tricks?v=158d9a33ecc98132bf9e000c39227361">PPO + LLM Tricks</fr:link></fr:li></fr:ul>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2298</fr:anchor><fr:addr
type="user">kak-0033</fr:addr><fr:route>kak-0033.xml</fr:route><fr:title
text="Optimization Theory">Optimization Theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>660</fr:anchor><fr:addr
type="machine">#310</fr:addr><fr:route>unstable-310.xml</fr:route><fr:title
text="Convex Optimization Background">Convex Optimization Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>662</fr:anchor><fr:addr
type="user">kak-0034</fr:addr><fr:route>kak-0034.xml</fr:route><fr:title
text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex
display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x} \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>663</fr:anchor><fr:addr
type="user">kak-0035</fr:addr><fr:route>kak-0035.xml</fr:route><fr:title
text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>If <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex
display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:p><fr:strong>Operations that preserve convexity</fr:strong>
<fr:ul><fr:li><fr:strong>Nonnegative weighted sums:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex
display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</fr:li>
    <fr:li><fr:strong>Pointwise maximum:</fr:strong> if <fr:tex
display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex
display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex</fr:li></fr:ul></fr:p>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>664</fr:anchor><fr:addr
type="user">kak-0036</fr:addr><fr:route>kak-0036.xml</fr:route><fr:title
text="Strong convexity">Strong convexity</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A function <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex if and only if 
<fr:tex
display="block"><![CDATA[g(\boldsymbol {x}) = f(\boldsymbol {x}) - \frac {\mu }{2} ||\boldsymbol {x}||_2^2]]></fr:tex>
is convex, <fr:tex
display="inline"><![CDATA[\forall  \boldsymbol {x} \in  \mathrm {dom} f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>665</fr:anchor><fr:addr
type="user">kak-0037</fr:addr><fr:route>kak-0037.xml</fr:route><fr:title
text="Smooth Problem">Smooth Problem</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A problem is <fr:em>smooth</fr:em> if both the objective function and the constraints are differentiable.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>666</fr:anchor><fr:addr
type="user">kak-0038</fr:addr><fr:route>kak-0038.xml</fr:route><fr:title
text="Subgradient">Subgradient</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> be convex. A <fr:em>subgradient</fr:em> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex> is any <fr:tex
display="inline"><![CDATA[\boldsymbol {u}]]></fr:tex> satisfying
<fr:tex
display="block"><![CDATA[f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle ]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>667</fr:anchor><fr:addr
type="user">kak-0039</fr:addr><fr:route>kak-0039.xml</fr:route><fr:title
text="Subdifferential">Subdifferential</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>The <fr:em>subdifferential</fr:em> is the set of all <fr:link
type="local"
href="kak-0038.xml"
addr="kak-0038"
title="Subgradient">subgradient's</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> at <fr:tex
display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex>.
<fr:tex
display="block"><![CDATA[\partial  f(\boldsymbol {x}_0) \coloneqq  \{\boldsymbol {u} | f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle  \}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>668</fr:anchor><fr:addr
type="machine">#318</fr:addr><fr:route>unstable-318.xml</fr:route><fr:title
text="Useful Miscellanous Math Background">Useful Miscellanous Math Background</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p>In this section, we cover many random math facts / tools that come up / are useful in later optimization problems.</fr:p>
    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>670</fr:anchor><fr:addr
type="machine">#311</fr:addr><fr:route>unstable-311.xml</fr:route><fr:title
text="Basic Matrix Analysis">Basic Matrix Analysis</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:ul><fr:li><fr:strong>Matrix inner product:</fr:strong>
<fr:tex
display="block"><![CDATA[\langle \mathbf {x},\mathbf {z}\rangle \ =\ \sum _{i=1}^{n}x_{i}z_{i}\quad \Longrightarrow \quad \langle \mathbf {X},\mathbf {Z}\rangle \ :=\ \sum _{i=1}^{m}\sum _{j=1}^{n}X_{i j}Z_{i j}]]></fr:tex></fr:li>
    <fr:li><fr:strong>Matrix trace:</fr:strong> <fr:tex
display="inline"><![CDATA[{{M}}\in \mathbb {R}^{n\times  n};\ {{\mathrm {tr}}}({{M}}):=\sum _{i=1}^{n}M_{i i}]]></fr:tex>
    <fr:tex
display="block"><![CDATA[       \begin {align*}       &\langle {\boldsymbol  X},{\boldsymbol  Z}\rangle \ =\ \mathrm {tr}\left ({\boldsymbol  X}^{\top }{\boldsymbol  Z}\right )\ =\ \mathrm {tr}\left ({\boldsymbol  X}{\boldsymbol  Z}^{\top }\right ) \\     &\operatorname {tr}(\mathbf {A}\mathbf {B})=\operatorname {tr}(\mathbf {B}\mathbf {A})\\       &\operatorname {tr}(\mathbf {A}_{1}\mathbf {A}_{2}\cdots \mathbf {A}_{n})=\operatorname {tr}(\mathbf {A}_{\pi (1)}\mathbf {A}_{\pi (2)}\cdots \mathbf {A}_{\pi (n)})       \end {align*}     ]]></fr:tex>
    Where <fr:tex
display="inline"><![CDATA[\pi ]]></fr:tex> is a cyclic permutation on <fr:tex
display="inline"><![CDATA[\{1,2,\cdots ,n\}]]></fr:tex></fr:li></fr:ul>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>672</fr:anchor><fr:addr
type="user">kak-003A</fr:addr><fr:route>kak-003A.xml</fr:route><fr:title
text="Positive (semi)definiteness">Positive (semi)definiteness</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A <fr:em>symmetric</fr:em> matrix <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{n\times  n}]]></fr:tex> is <fr:em>positive definite</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}>0]]></fr:tex> for all nonzero <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. It is <fr:em>positive semidefinite (p.s.d.)</fr:em> if <fr:tex
display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}\geq 0]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>673</fr:anchor><fr:addr
type="user">kak-003B</fr:addr><fr:route>kak-003B.xml</fr:route><fr:title
text="Singular Value Decomposition">Singular Value Decomposition</fr:title><fr:taxon>Fact</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\operatorname {rank}(\mathbf {A})=r]]></fr:tex>. There exist <fr:tex
display="inline"><![CDATA[\sigma _{1}\geq \sigma _{2}\geq \cdots \geq \sigma _{r}>0]]></fr:tex>, and matrices <fr:tex
display="block"><![CDATA[\mathbf {U}\in \mathbb {R}^{m\times  r},\ \mathbf {V}\in \mathbb {R}^{n\times  r},]]></fr:tex> with <fr:em>orthonormal</fr:em> columns <fr:tex
display="inline"><![CDATA[(\mathbf {U}^{\top }\mathbf {U}=\mathbf {I},\ \mathbf {V}^{\top }\mathbf {V}=\mathbf {I})]]></fr:tex> such that <fr:tex
display="block"><![CDATA[\mathbf {A}\ =\ \mathbf {U}\mathbf {\Sigma }\mathbf {V}^{\top }\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }\,,\quad \mathbf {\Sigma }\ =\ \operatorname {diag}\left (\sigma _{1},\cdots ,\sigma _{r}\right ).]]></fr:tex></fr:p><fr:p>Relationship between eigen decomposition and SVD
  <fr:ul><fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {V}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}^T\boldsymbol {A}]]></fr:tex></fr:li>
      <fr:li>The columns of <fr:tex
display="inline"><![CDATA[\boldsymbol {U}]]></fr:tex> are eigenvectors of <fr:tex
display="inline"><![CDATA[\boldsymbol {A}\boldsymbol {A}^T]]></fr:tex></fr:li>
      <fr:li><fr:tex
display="inline"><![CDATA[{{\sigma _{i}({\mathbf {A}})}}={\sqrt {\lambda _{i}({{{\mathbf {A}}{\mathbf {A}}^{\mathsf {T}}}})}}={\sqrt {\lambda _{i}({\mathbf {A}}^{\mathsf {T}}{\mathbf {A}})}}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>674</fr:anchor><fr:addr
type="user">kak-003C</fr:addr><fr:route>kak-003C.xml</fr:route><fr:title
text="Best rank-r approximation">Best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with SVD, <fr:tex
display="inline"><![CDATA[\mathbf {A}=\sum _{i=1}^{\min \{m,n\}}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }]]></fr:tex>. Then an optimal solution to the best rank-<fr:tex
display="inline"><![CDATA[r]]></fr:tex> approximation problem <fr:tex
display="block"><![CDATA[\min _{\mathbf {X}}||\mathbf {X}-\mathbf {A}||_{2}\,,\quad \text {s.t.}\quad \text {rank}(\mathbf {X})\ \leq \ r]]></fr:tex> is the truncated SVD of the following form <fr:tex
display="block"><![CDATA[\boxed {\widehat {\mathbf {A}}_{r}\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }}\,,\ \ \text {if}\ \ \sigma _{r}>\sigma _{r+1}\,,\,\text {it is unique.}]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>675</fr:anchor><fr:addr
type="machine">#309</fr:addr><fr:route>unstable-309.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Suppose <fr:tex
display="inline"><![CDATA[m \geq  n]]></fr:tex>, then we observe that
<fr:tex
display="block"><![CDATA[\left |\left |{\widehat {\mathbf {A}}}_{r}-{\mathbf {A}}\right |\right |_{2}\;=\;\left |\left |\sum _{i=r+1}^{n}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\mathsf {T}}\right |\right |_{2} \leq  \sigma _{r+1}]]></fr:tex>

Second, to prove our result, we want to show that <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {B}_{r}-\mathbf {A}\right |\right |_{2}\ \geq \ \sigma _{r+1},\quad \forall \mathbf {B}_{r}\ \text {with}\ \mathrm {rank}(\mathbf {B}_{r})=r.]]></fr:tex> We suppose <fr:tex
display="inline"><![CDATA[\ \mathbf {B}_{r}=\widetilde {\mathbf {U}}\widetilde {\mathbf {V}}^{\top },\quad \widetilde {\mathbf {U}}\in \mathbb {R}^{m\times  r},\ \widetilde {\mathbf {V}}\in \mathbb {R}^{n\times  r}.]]></fr:tex>
Note
<fr:tex
display="block"><![CDATA[ \begin {align*} ||\mathbf {B}_r - A||_2^2 &= \sup _{||\boldsymbol {z}||_2 \leq  1} ||(\mathbf {B}_r - \mathbf {A})\mathbf {z}||_2^2 \\ &\geq  ||(\mathbf {B}_r - \mathbf {A})\mathbf {w}||_2^2 \end {align*} ]]></fr:tex>
Since <fr:tex
display="inline"><![CDATA[\widetilde {V}]]></fr:tex> has <fr:tex
display="inline"><![CDATA[r]]></fr:tex> columns, then there must be a nontrivial linear combination of the first <fr:tex
display="inline"><![CDATA[r{+}1]]></fr:tex> columns of <fr:tex
display="inline"><![CDATA[V]]></fr:tex>, i.e., <fr:tex
display="block"><![CDATA[\mathbf {w}=\gamma _{1}\mathbf {v}_{1}+\cdots +\gamma _{r+1}\mathbf {v}_{r+1}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\widetilde {V}^{\top }\mathbf {w}=\mathbf {0}\,.]]></fr:tex> Wlog, we can scale <fr:tex
display="inline"><![CDATA[\left |\left |\mathbf {w}\right |\right |_{2}=1]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\,\sum _{i=1}^{r+1}\gamma _{i}^{2}=1]]></fr:tex>
Then 
<fr:tex
display="block"><![CDATA[||\mathbf {A}-\mathbf {B}_{k}||_{2}^{2}\geq ||(\mathbf {A}-\mathbf {B}_{k})\,\mathbf {w}||_{2}^{2}=||\mathbf {A}\mathbf {w}||_{2}^{2}=\gamma _{1}^{2}\sigma _{1}^{2}+\cdots +\gamma _{r+1}^{2}\sigma _{r+1}^{2}\geq \sigma _{r+1}^{2}.]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>676</fr:anchor><fr:addr
type="user">kak-003G</fr:addr><fr:route>kak-003G.xml</fr:route><fr:title
text="Matrix Operator Norm">Matrix Operator Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{a}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{b}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathbb {R}^{n}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbb {R}^{m}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\left |\left |\mathbf {A}\right |\right |_{a\to  b}\ :=\ \sup _{\left |\left |\mathbf {x}\right |\right |_{a}\leq  1}\left |\left |\mathbf {A}\mathbf {x}\right |\right |_{b}.]]></fr:tex>
It satisfies the <fr:em>three criteria</fr:em> for norm, and is <fr:em>submultiplicative</fr:em> <fr:tex
display="block"><![CDATA[||\boldsymbol {A}\boldsymbol {B}||_{a\to  b}\ \leq \ ||\boldsymbol {A}||_{a\to  b}\cdot  ||\boldsymbol {B}||_{a\to  b};]]></fr:tex>. 
<fr:tex
display="block"><![CDATA[||{\cal  A}||_{2\to 2}\;=\;\sigma _{1}({\cal  A})\;\;(\mathrm {{spectral\ norm}},\;\mathrm {{write\ as}}\;||{\cal  A}||\;\;);\;]]></fr:tex>
<fr:tex
display="block"><![CDATA[\begin {array}{l}{{||{\boldsymbol {A}}||_{1\to  b}\ =\ \operatorname *{max}_{j=1,\cdots ,n}||{\boldsymbol {A e}}_{j}||_{b}}}\\ {{||{\boldsymbol {A}}||_{a\to \infty }\ =\ \operatorname *{max}_{i=1,\cdots ,m}||{\boldsymbol {e}}_{i}^{*}{\boldsymbol {A}}||_{b}^{*}\,,\ \ ||{\boldsymbol {v}}||_{b}^{*}\ :=\ \operatorname *{sup}_{||{\boldsymbol {u}}||_{b}\leq 1}\langle {\boldsymbol {u}},{\boldsymbol {v}}\rangle \,,}}\end {array}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>677</fr:anchor><fr:addr
type="user">kak-003H</fr:addr><fr:route>kak-003H.xml</fr:route><fr:title
text="Unitary Invariant Matrix Norm">Unitary Invariant Matrix Norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}.]]></fr:tex> We say the matrix norm is unitary invariant if <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{\sharp }\ =\ \left ||\mathbf {PAQ}\right ||_{\sharp },\quad \forall \ \mathbf {P}\in  O(m),\ \mathbf {Q}\in  O(n).]]></fr:tex></fr:p><fr:p>Eg.
  <fr:ul><fr:li><fr:strong>Spectral norm</fr:strong> <fr:tex
display="block"><![CDATA[||A||_{2 \to  2}=\sigma _{1}(A)=||\sigma (A)||_{\infty }]]></fr:tex></fr:li>
    <fr:li><fr:strong>Frobenius norm</fr:strong> <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}\right ||_{F}\ =\ \sqrt {\sum _{i=1}^{\min \{m,n\}}\sigma _{i}^{2}(\mathbf {A})}\ =\ \left ||\mathbf {\sigma }(\mathbf {A})\right ||_{2}]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>678</fr:anchor><fr:addr
type="user">kak-003I</fr:addr><fr:route>kak-003I.xml</fr:route><fr:title
text="Schatten p-norm">Schatten <fr:tex
display="inline"><![CDATA[p]]></fr:tex>-norm</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. For any <fr:tex
display="inline"><![CDATA[p \in  [1,+\infty ]]]></fr:tex>, the function <fr:tex
display="block"><![CDATA[\left ||\mathbf {A}|\right |_{\mathrm {S}_{p}}\,:=\,\left ||\mathbf {\sigma }(\mathbf {A})|\right |_{p}]]></fr:tex> is a norm on <fr:tex
display="inline"><![CDATA[\,\mathbb {R}^{m\times  n}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

    
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>679</fr:anchor><fr:addr
type="machine">#313</fr:addr><fr:route>unstable-313.xml</fr:route><fr:title
text="Taylor Expansion and Lipschitz Functions">Taylor Expansion and Lipschitz Functions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>681</fr:anchor><fr:addr
type="user">kak-003J</fr:addr><fr:route>kak-003J.xml</fr:route><fr:title
text="Lipschitz Continous">Lipschitz Continous</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose that 
<fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f:\mathcal {X}\mapsto \mathcal {Y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> being open sets;</fr:li> 
  <fr:li><fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {X}}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[||\cdot ||_{\mathcal {Y}}]]></fr:tex> are norms on <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathcal {Y}]]></fr:tex>, respectively.</fr:li></fr:ul>
<fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex> is Lipschitz continuous over <fr:tex
display="inline"><![CDATA[\mathcal {X}]]></fr:tex> if <fr:tex
display="inline"><![CDATA[\exists  L<\infty \,,]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||f(\boldsymbol {y})-f(\boldsymbol {x})||_{\mathcal {Y}}\ \leq \ L(\boldsymbol {x})\,||\boldsymbol {y}-\boldsymbol {x}||_{\mathcal {X}}\,,\quad \forall \boldsymbol {x},\ \boldsymbol {y}\in \mathcal {X}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>682</fr:anchor><fr:addr
type="user">kak-003K</fr:addr><fr:route>kak-003K.xml</fr:route><fr:title
text="Smooth Function">Smooth Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A differentiable function <fr:tex
display="inline"><![CDATA[f(\mathbf {x})]]></fr:tex> is called smooth iff it has a Lipschitz continuous gradient, i.e., iff <fr:tex
display="inline"><![CDATA[L< \infty ]]></fr:tex> such that <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x})-\nabla  f(\mathbf {z}) ||_{2}\ \leq  L ||\mathbf {x}-\mathbf {z} ||_{2},\quad  \forall  \mathbf {x},\ \mathbf {z}\in \mathbb {R}^{n}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>683</fr:anchor><fr:addr
type="user">kak-003L</fr:addr><fr:route>kak-003L.xml</fr:route><fr:title
text="Mean Value Theorem I">Mean Value Theorem I</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\,f(\mathbf {y})\,=\,f(\mathbf {x})\,+\,\langle \nabla  f(\mathbf {z}(t_{L})),\mathbf {y}-\mathbf {x}\rangle \,]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t_{L})=(1-t_{L})\cdot \mathbf {x}+t_{L}\cdot \mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t_{L}\in (0,1)\,]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>684</fr:anchor><fr:addr
type="machine">#312</fr:addr><fr:route>unstable-312.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^n\mapsto \mathbb {R}]]></fr:tex> is continuously differentiable, <fr:tex
display="block"><![CDATA[\begin {aligned}      |f(\pmb {x})-f(\pmb {y})| &\leq  & \sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2 \, ||\pmb {x}-\pmb {y}||_2   \end {aligned}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2]]></fr:tex>.</fr:li>
          <fr:li>If <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is twice continuously differentiable, <fr:tex
display="block"><![CDATA[||\nabla  f(\boldsymbol {x})-\nabla  f(\boldsymbol {y})||_{2}\ \leq \ \sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}\,||\boldsymbol {x}-\boldsymbol {y}||_{2}]]></fr:tex> so that the Lipschitz constant of <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}]]></fr:tex></fr:li></fr:ul>
      </fr:mainmatter><fr:backmatter /></fr:tree>

      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>686</fr:anchor><fr:addr
type="user">kak-003M</fr:addr><fr:route>kak-003M.xml</fr:route><fr:title
text="Mean Value Theorem II">Mean Value Theorem II</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be twice continuously differentiable. For any fixed <fr:tex
display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {y})\;=\;\nabla  f(\mathbf {x})\,+\,\int _{0}^{1}\nabla ^{2}f(\mathbf {z}(t))\cdot (\mathbf {y}-\mathbf {x})dt]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[\mathbf {z}(t)=(1-t)\mathbf {x}+t\mathbf {y}]]></fr:tex> with <fr:tex
display="inline"><![CDATA[t\in (0,1)\,,]]></fr:tex> and that <fr:tex
display="block"><![CDATA[\boxed {f(\mathbf {y})\;=\;f(\mathbf {x})+(\nabla  f(\mathbf {x}),\mathbf {y}-\mathbf {x})+\frac {1}{2}(\mathbf {y}-\mathbf {x})^{\top }\nabla ^{2}f(\mathbf {z}(t_{Q}))(\mathbf {y}-\mathbf {x})}]]></fr:tex> for some <fr:tex
display="inline"><![CDATA[t_{Q}\in (0,1)\,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>687</fr:anchor><fr:addr
type="user">kak-003N</fr:addr><fr:route>kak-003N.xml</fr:route><fr:title
text="First-order approximation">First-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be continuously differentiable, and <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{L}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{L}(\mathbf {x}_{0})}{2}\,||\mathbf {x}-\mathbf {x}_{0}||_{2}^{2}\,,]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\ :=\ f(\mathbf {x}_{0})\ +\ \langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle \,.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
      <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>688</fr:anchor><fr:addr
type="user">kak-003O</fr:addr><fr:route>kak-003O.xml</fr:route><fr:title
text="Second-order approximation">Second-order approximation</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be twice continuously differentiable, and suppose <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x})]]></fr:tex> is <fr:tex
display="inline"><![CDATA[\gamma _{Q}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex
display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{Q}(\mathbf {x}_{0})}{6}\left ||\mathbf {x}-\mathbf {x}_{0}\right ||_{2}^{3},]]></fr:tex> where we define <fr:tex
display="block"><![CDATA[\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0}):=f(\mathbf {x}_{0})+\langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle ]]></fr:tex> <fr:tex
display="block"><![CDATA[+\frac {1}{2}(\mathbf {x}-\mathbf {x}_{0})^{\top }\nabla ^{2}f(\mathbf {x}_{0})(\mathbf {x}-\mathbf {x}_{0}).]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>689</fr:anchor><fr:addr
type="machine">#316</fr:addr><fr:route>unstable-316.xml</fr:route><fr:title
text="Optimality Conditions">Optimality Conditions</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>691</fr:anchor><fr:addr
type="user">kak-003P</fr:addr><fr:route>kak-003P.xml</fr:route><fr:title
text="Stationary point">Stationary point</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>A point <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a stationary point of <fr:tex
display="inline"><![CDATA[f(\cdot )]]></fr:tex>, if <fr:tex
display="block"><![CDATA[\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.]]></fr:tex> Here, <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is also known as a critical point.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:ul><fr:li><fr:strong>First order necessary condition</fr:strong>:
    If <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[\ f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is continuously differentiable in an open neighborhood of <fr:tex
display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[\boxed {\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.}]]></fr:tex>
    <fr:li><fr:strong>Second order necessary condition:</fr:strong>
    If <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is twice continuously differentiable in an open neighborhood around <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex
display="block"><![CDATA[(i)\ \nabla  f(\mathbf {x_{\star }})=\mathbf {0};]]></fr:tex> <fr:tex
display="block"><![CDATA[(ii)\ \nabla ^{2}f(\mathbf {x_{\star }})\succeq \mathbf {0}.]]></fr:tex>
    <fr:ul><fr:li>If <fr:tex
display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x_{\star }})\succ \mathbf {0}]]></fr:tex> then the above is a sufficient condition.</fr:li></fr:ul></fr:li></fr:li></fr:ul>
  
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>692</fr:anchor><fr:addr
type="machine">#314</fr:addr><fr:route>unstable-314.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be a convex function, then 
  <fr:ul><fr:li>A local minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is also its global minimizer. If <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is strictly convex, the global minimizer is unique</fr:li>
    <fr:li>A point is a global minimizer of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> iff <fr:tex
display="block"><![CDATA[\mathbf {0}\ \in \ \partial  f(\mathbf {x_{\star }}).]]></fr:tex></fr:li></fr:ul>
  If <fr:tex
display="inline"><![CDATA[f\in \mathcal {C}^{1}]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x_{\star }})=\mathbf {0}]]></fr:tex> implies that <fr:tex
display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a global minimizer.
  </fr:mainmatter><fr:backmatter /></fr:tree>

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>694</fr:anchor><fr:addr
type="machine">#315</fr:addr><fr:route>unstable-315.xml</fr:route><fr:title
text="Constrained Case">Constrained Case</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    Consider a smooth contained problem with <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}}f(\mathbf {x}),\quad  \text {s.t.} \quad  r_{i}(\mathbf {x})\ =\ 0,\ 1\leq  i\leq  p,]]></fr:tex> <fr:tex
display="block"><![CDATA[h_{j}(\mathbf {x})\ \leq \ 0,\ 1\leq  j\leq  q.]]></fr:tex> Consider its Lagrangian function <fr:tex
display="block"><![CDATA[\mathscr {L}(\mathbf {x},\mathbf {u},\mathbf {v})\ =\ f(\mathbf {x})+\sum _{i=1}^{p}u_{i}\cdot  r_{i}(\mathbf {x})+\sum _{j=1}^{q}v_{j}\cdot  h_{j}(\mathbf {x}).]]></fr:tex>
    <fr:strong>KKT-conditions:</fr:strong>
    <fr:ul><fr:li>Stationary <fr:tex
display="block"><![CDATA[\nabla _{\mathbf {x}}{\mathcal {L}}(\mathbf {x_*},\mathbf {u_*},\mathbf {v_*})\;=\;\mathbf {0}]]></fr:tex></fr:li>
    <fr:li>Primal Feasibility: <fr:tex
display="block"><![CDATA[\begin {array}{l}{{r_{i}(x_{\star })\ =\ 0,\ 1\leq  i\leq  p,}}\\ {{h_{j}(x_{\star })\ \leq \ 0,\ 1\leq  j\leq  q.}}\end {array}]]></fr:tex></fr:li>
    <fr:li>Dual Feasibility: <fr:tex
display="block"><![CDATA[v_{\star }\geq  0.]]></fr:tex></fr:li>
    <fr:li>Complimentary slackness: <fr:tex
display="block"><![CDATA[h_{j}(x_{\star })\cdot  v_{\star  j}\ =\ 0,\quad \forall \ 1\leq  j\leq  q.]]></fr:tex></fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>696</fr:anchor><fr:addr
type="machine">#317</fr:addr><fr:route>unstable-317.xml</fr:route><fr:title
text="Rate of Convergence">Rate of Convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:p>Want to find
<fr:tex
display="block"><![CDATA[\operatorname *{min}_{\mathbf {x}}\ f(\mathbf {x}),\quad \text {s.t.}\quad \mathbf {x}\ \in \ \mathcal {C}.]]></fr:tex> Solve the problem via iterative methods of optimization, which produce a sequence of points <fr:tex
display="block"><![CDATA[\mathbf {x}_{1},\ \mathbf {x}_{2},\ \cdots ,\mathbf {x}_{k},\cdots ]]></fr:tex> starting from an initialization <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>.</fr:p>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>698</fr:anchor><fr:addr
type="user">kak-003R</fr:addr><fr:route>kak-003R.xml</fr:route><fr:title
text="First-order convergence">First-order convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>First-order function value convergence 
     <fr:tex
display="block"><![CDATA[||\nabla  f(\mathbf {x}_k)||_2 \; \leq  \; \varepsilon .]]></fr:tex>
       <fr:ul><fr:li>For convex functions, this also means convergence to the global minimizer</fr:li>
        <fr:li>For nonconvex functions, this only means   convergence to a <fr:link
type="local"
href="kak-003P.xml"
addr="kak-003P"
title="Stationary point">Stationary point</fr:link> (e.g., a local minimizer or a saddle point).</fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>699</fr:anchor><fr:addr
type="user">kak-003Q</fr:addr><fr:route>kak-003Q.xml</fr:route><fr:title
text="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[(p \geq 1)]]></fr:tex> and with factor <fr:tex
display="inline"><![CDATA[(\gamma  > 0)]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[\exists  k_{0}]]></fr:tex>, such that <fr:tex
display="inline"><![CDATA[\forall  k\geq  k_{0}]]></fr:tex>: <fr:tex
display="block"><![CDATA[\boxed {\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k}}-\mathbf {x_{*}}||_{2}\ \leq \ \gamma \cdot \left (\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k-1}}-\mathbf {x_{*}}||_{2}\right )^{p}.}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>700</fr:anchor><fr:addr
type="user">kak-003S</fr:addr><fr:route>kak-003S.xml</fr:route><fr:title
text="R-convergence"><fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>We say the <fr:tex
display="inline"><![CDATA[R]]></fr:tex>-convergence is of order <fr:tex
display="inline"><![CDATA[p\;(\geq 1)]]></fr:tex>, <fr:tex
display="block"><![CDATA[\min _{\mathbf {x}_{*}\in \mathcal {X}}||\mathbf {x}_{k}-\mathbf {x}_{*}||_{2}\;\leq \;\rho _{k},]]></fr:tex> if the sequence <fr:tex
display="inline"><![CDATA[\{\rho _{k}\}_{k\geq 1}]]></fr:tex> is <fr:link
type="local"
href="kak-003Q.xml"
addr="kak-003Q"
title="Q-convergence"><fr:tex
display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:link> of the order <fr:tex
display="inline"><![CDATA[p]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  


</fr:mainmatter><fr:backmatter /></fr:tree>
  

  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>701</fr:anchor><fr:addr
type="machine">#328</fr:addr><fr:route>unstable-328.xml</fr:route><fr:title
text="Iterative Methods">Iterative Methods</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:strong>Assume:</fr:strong>
  <fr:ul><fr:li><fr:tex
display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">Convex Function</fr:link> and a <fr:link
type="local"
href="kak-003K.xml"
addr="kak-003K"
title="Smooth Function">Smooth Function</fr:link>.</fr:li>
      <fr:li>The gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>.</fr:li></fr:ul>
  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>703</fr:anchor><fr:addr
type="machine">#319</fr:addr><fr:route>unstable-319.xml</fr:route><fr:title
text="Convergence of Gradient Descent">Convergence of Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>705</fr:anchor><fr:addr
type="user">kak-004L</fr:addr><fr:route>kak-004L.xml</fr:route><fr:title
text="Sufficient Value">Sufficient Value</fr:title><fr:taxon>Lemma</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>With step size <fr:tex
display="inline"><![CDATA[\tau _{k}=1/L\,,]]></fr:tex> the gradient descent iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathbf {x}_{k}\ -\ \tau _{k}\cdot \nabla  f(\mathbf {x}_{k})]]></fr:tex>

satisfy the following:

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k+1})\ \leq \ f(\mathbf {x}_{k})\ -\ \frac {1}{2L}\,||\nabla  f(\mathbf {x}_{k})||_{2}^{2}]]></fr:tex> <fr:tex
display="block"><![CDATA[<\ f(\mathbf {x}_{k})\quad (||\nabla  f(\mathbf {x}_{k})||_{2}\neq 0)]]></fr:tex></fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>656</fr:anchor><fr:addr
type="machine">#272</fr:addr><fr:route>unstable-272.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Because <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> is Lipschitz, by 1st-order Taylor approximation

<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})+\langle \nabla  f(\mathbf {x}),\mathbf {x}^{\prime }-\mathbf {x}\rangle +\frac {L}{2}\left ||\mathbf {x}^{\prime }-\mathbf {x}\right ||_{2}^{2},\quad \forall \ \mathbf {x}^{\prime },\mathbf {x}]]></fr:tex>
Now take <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \tau  \nabla  f( \mathbf {x})]]></fr:tex>. Then
<fr:tex
display="block"><![CDATA[   \begin {align*}     f(\mathbf {x}^{\prime }) &\leq  f(\mathbf {x})+ \tau  ||\nabla  f( \mathbf {x} )||_2^2 + \frac {\tau ^2 L}{2} ||\nabla  f( \mathbf {x})||_2^2 \\     &= f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2   \end {align*} ]]></fr:tex>
  Take <fr:tex
display="inline"><![CDATA[\tau  = \frac {1}{L}]]></fr:tex>, such that
<fr:tex
display="block"><![CDATA[     \begin {align*} f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2 &= f( \mathbf {x}) - \frac {1}{2L}||\nabla  f( \mathbf {x})||_2^2     \end {align*}   ]]></fr:tex>
  </fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>706</fr:anchor><fr:addr
type="user">kak-004M</fr:addr><fr:route>kak-004M.xml</fr:route><fr:title
text="Sublinear convergence of GD">Sublinear convergence of GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. If we run GD for <fr:tex
display="inline"><![CDATA[k]]></fr:tex> iterations with a fixed step size <fr:tex
display="inline"><![CDATA[\tau =1/L]]></fr:tex>, it will yield a sequence <fr:tex
display="inline"><![CDATA[\left \{\mathbf {x}_{k}\right \}_{k\geq 1}]]></fr:tex> such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}\ =\ O(\frac {1}{k}),]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p>
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>653</fr:anchor><fr:addr
type="machine">#271</fr:addr><fr:route>unstable-271.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
Given <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is convex and smooth, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_*]]></fr:tex> is an optimal solution, then
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{\star })\geq  f(\mathbf {x})+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}_{\star }-\mathbf {x})]]></fr:tex>
Flipping the inequality yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x})\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })]]></fr:tex>
By <fr:link
type="local"
href="kak-004L.xml"
addr="kak-004L"
title="Sufficient Value">previous lemma</fr:link>, taking <fr:tex
display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \frac {1}{L} \nabla  f( \mathbf {x})]]></fr:tex> yields
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
such that
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
Equivalently,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })\leq {\frac {L}{2}}\left [{\frac {2}{L}}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{L^{2}}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ]]]></fr:tex>
Completing the square,
<fr:tex
display="block"><![CDATA[ \begin {align*}  f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })&\leq \frac {L}{2}\left [\frac {2}{L}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-\frac {1}{L^{2}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}-\frac {1}{L}\nabla  f(\mathbf {x})-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \\   &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}^{\prime }-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \end {align*} ]]></fr:tex>
Let <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}=\mathbf {x}_{k-1}-\frac {1}{L}\nabla  f(\mathbf {x}_{k-1})]]></fr:tex>, then we have

<fr:tex
display="block"><![CDATA[ \begin {align*}  \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right ) &\leq  \frac {L}{2}\sum _{i=1}^{k}\left [\left ||\mathbf {x}_{i-1}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{i}-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]  \\ &=\frac {L}{2}\left [\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{k}-\mathbf {x}_{0}\right ||_{2}^{2}\right ] \\   &\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}  \end {align*} ]]></fr:tex>
Therefore, given <fr:tex
display="inline"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\leq  f(\mathbf {x}_{i})-f(\mathbf {x}_{*}) \text { for } \forall  i\leq  k\,,]]></fr:tex>

<fr:tex
display="block"><![CDATA[k\left (f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\right )\leq \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right )\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}]]></fr:tex>
</fr:mainmatter><fr:backmatter /></fr:tree>
 

</fr:mainmatter><fr:backmatter /></fr:tree>
  <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>707</fr:anchor><fr:addr
type="user">kak-004N</fr:addr><fr:route>kak-004N.xml</fr:route><fr:title
text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose the iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <fr:em>black-box model</fr:em>:

<fr:tex
display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></fr:p><fr:p>For every positive <fr:tex
display="inline"><![CDATA[L]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link
type="local"
href="kak-004D.xml"
addr="kak-004D"
title="Convex Function">convex</fr:link> differentiable <fr:tex
display="inline"><![CDATA[f]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex
display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex
display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>708</fr:anchor><fr:addr
type="machine">#320</fr:addr><fr:route>unstable-320.xml</fr:route><fr:title
text="Accelerated Gradient Descent">Accelerated Gradient Descent</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>710</fr:anchor><fr:addr
type="user">kak-004O</fr:addr><fr:route>kak-004O.xml</fr:route><fr:title
text="Nesterov's Method">Nesterov's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Generate two sequences <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}{\mathrm {~and~}}\{\mathbf {p}_{k}\}_{k\geq 1}]]></fr:tex>
<fr:tex
display="block"><![CDATA[ \begin {align*} {\mathbf {\mathit {p}}}_{k+1}\ &=\ {\mathbf {\mathit {x}}}_{k}\ +\ \beta _{k}\cdot ({\mathbf {\mathit {x}}}_{k}-{\mathbf {\mathit {x}}}_{k-1}), \\ x_{k+1} &= p_{k+1}-\alpha \nabla  f(p_{k+1}) \end {align*} ]]></fr:tex>
<fr:ul><fr:li><fr:strong>Not</fr:strong> a descent method.</fr:li>
<fr:li>With properly chosen <fr:tex
display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\beta ]]></fr:tex> can achieve <fr:link
type="local"
href="kak-004N.xml"
addr="kak-004N"
title="Suboptimality of Gradient Descent">optimal</fr:link> convergence rate <fr:tex
display="inline"><![CDATA[O(1/k^2)]]></fr:tex></fr:li></fr:ul></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>711</fr:anchor><fr:addr
type="user">kak-004P</fr:addr><fr:route>kak-004P.xml</fr:route><fr:title
text="Convergence of accelerated GD">Convergence of accelerated GD</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Suppose <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. The iterates <fr:tex
display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by the accelerated GD method satisfy

<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2(k+1)^{2}}\ ||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}^{2}\ =\ O(\frac {1}{k^{2}}).]]></fr:tex>

Moreover, as <fr:tex
display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>712</fr:anchor><fr:addr
type="machine">#324</fr:addr><fr:route>unstable-324.xml</fr:route><fr:title
text="Line Search">Line Search</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>714</fr:anchor><fr:addr
type="user">kak-004Q</fr:addr><fr:route>kak-004Q.xml</fr:route><fr:title
text="Exact Linesearch">Exact Linesearch</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For 
<fr:tex
display="block"><![CDATA[x_{k+1}\ =\ x_{k}\ -\ \tau _{k}\cdot \nabla  f(x_{k})]]></fr:tex>
Choose step size by solving
<fr:tex
display="block"><![CDATA[\tau _{k}\;=\;\arg \operatorname *{min}_{t\geq 0}\;f({\mathbf {x}}_{k}-t\cdot \nabla  f({\mathbf {x}}_{k}))]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>715</fr:anchor><fr:addr
type="machine">#321</fr:addr><fr:route>unstable-321.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>Way to computationally expensive to use in practice.</fr:mainmatter><fr:backmatter /></fr:tree>

    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>717</fr:anchor><fr:addr
type="user">kak-004R</fr:addr><fr:route>kak-004R.xml</fr:route><fr:title
text="Armijo Condition">Armijo Condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[c_1 \in  (0,1)]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f( \mathbf {x}_k + \tau _k \cdot  \mathbf {d}_k) < f( \mathbf {x}_k) + c_1 \cdot  \tau _k \cdot  \mathbf {d}_{k}^{\top } \nabla  f(\mathbf {x}_k)]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>718</fr:anchor><fr:addr
type="user">kak-004S</fr:addr><fr:route>kak-004S.xml</fr:route><fr:title
text="Wolfe condition">Wolfe condition</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>For some <fr:tex
display="inline"><![CDATA[0 < c_1 < c_2 < 1]]></fr:tex>,
<fr:tex
display="block"><![CDATA[f(\mathbf {x}_{k}+\tau _{k}\cdot \mathbf {d}_{k})\ <\ f(\mathbf {x}_{k})+c_{1}\cdot \tau _{k}\cdot \mathbf {d}_{k}^{\intercal }\nabla  f(\mathbf {x}_{k})]]></fr:tex>
<fr:tex
display="block"><![CDATA[d_{k}^{\top }\nabla  f({\mathbf {x}}_{k}+\tau _{k}{\mathbf {d}}_{k})\ \geq \ c_{2}{\mathbf {d}}_{k}^{\top }\nabla  f({\mathbf {x}}_{k})]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>719</fr:anchor><fr:addr
type="machine">#322</fr:addr><fr:route>unstable-322.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Wolfe condition requires evaluating gradient of function each update to <fr:tex
display="inline"><![CDATA[\tau _k]]></fr:tex>. However,  <fr:link
type="local"
href="kak-004R.xml"
addr="kak-004R"
title="Armijo Condition">Armijo Condition</fr:link> only requires evaluating gradient once. Therefore, it is primarily used in practice.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>721</fr:anchor><fr:addr
type="machine">#323</fr:addr><fr:route>unstable-323.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        Backtracking is not used in optimizing DNNs because even function evaluation is very expensive.
      </fr:mainmatter><fr:backmatter /></fr:tree>

<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>723</fr:anchor><fr:addr
type="user">kak-004T</fr:addr><fr:route>kak-004T.xml</fr:route><fr:title
text="Convergence of GD with backtracking">Convergence of GD with backtracking</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let the function <fr:tex
display="inline"><![CDATA[f(\pmb {x})]]></fr:tex> be <fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex and <fr:tex
display="inline"><![CDATA[L]]></fr:tex>-smooth. With backtracking

linesearch, the GD method converges with

<fr:tex
display="block"><![CDATA[f(\pmb {x}_k)-f(\pmb {x}_\star )\ \le \ \left (1-\min \left \{2c_1\mu ,\dfrac {2\alpha  c_1\mu }{L}\right \}\right )^k(f(\pmb {x}_0)-f(\pmb {x}_\star ))]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\pmb {x}_\star ]]></fr:tex> is the unique minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>724</fr:anchor><fr:addr
type="machine">#326</fr:addr><fr:route>unstable-326.xml</fr:route><fr:title
text="How function properties affect convergence">How function properties affect convergence</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>726</fr:anchor><fr:addr
type="user">kak-004U</fr:addr><fr:route>kak-004U.xml</fr:route><fr:title
text="Linear convergence for strong convexity">Linear convergence for strong convexity</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be smooth and <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity"><fr:tex
display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex</fr:link>, and suppose its gradient <fr:tex
display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link
type="local"
href="kak-003J.xml"
addr="kak-003J"
title="Lipschitz Continous"><fr:tex
display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>. Choose a fixed step size <fr:tex
display="inline"><![CDATA[\tau _{k}\equiv \tau =\frac {2}{\mu +L}]]></fr:tex>, then

<fr:tex
display="block"><![CDATA[\left ||\mathbf {x}_{k}-\mathbf {x}_{\star }\right ||_{2}\ \leq \ \left (\frac {\kappa -1}{\kappa +1}\right )^{k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2},]]></fr:tex>

where <fr:tex
display="inline"><![CDATA[\kappa =\frac {L}{\mu }]]></fr:tex> is the condition number, and <fr:tex
display="inline"><![CDATA[\mathbf {x}_{\star }]]></fr:tex> is the minimizer.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
    
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>727</fr:anchor><fr:addr
type="machine">#325</fr:addr><fr:route>unstable-325.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
        <fr:link
type="local"
href="kak-0036.xml"
addr="kak-0036"
title="Strong convexity">Strong convexity</fr:link> is a sufficient but not necessary condition for linear convergene of gradient descent.
      </fr:mainmatter><fr:backmatter /></fr:tree>

    </fr:mainmatter><fr:backmatter /></fr:tree>
  

  
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>729</fr:anchor><fr:addr
type="machine">#327</fr:addr><fr:route>unstable-327.xml</fr:route><fr:title
text="Newton and Quasi-Newton Method">Newton and Quasi-Newton Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>731</fr:anchor><fr:addr
type="user">kak-004V</fr:addr><fr:route>kak-004V.xml</fr:route><fr:title
text="Newton's Method">Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Consider <fr:link
type="local"
href="kak-003O.xml"
addr="kak-003O"
title="Second-order approximation">second-order taylor approximation</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>
<fr:tex
display="block"><![CDATA[ f(\mathbf {x}_{k}+\mathbf {d})\ \approx \ \underbrace {f(\mathbf {x}_{k})+\mathbf {d}^{\top }\nabla  f(\mathbf {x}_{k})+{\frac {1}{2}}\mathbf {d}^{\top }\nabla ^{2}f(\mathbf {x}_{k})\mathbf {d}}_{Q_k( \mathbf {d})}]]></fr:tex>
Then setting <fr:tex
display="inline"><![CDATA[\nabla  Q_k( \mathbf {d})]]></fr:tex> and solving for <fr:tex
display="inline"><![CDATA[\mathbf {d}]]></fr:tex>, we get
<fr:tex
display="block"><![CDATA[   \nabla  f( \mathbf {x}_k) + \frac {1}{2}\nabla ^2 f( \mathbf {x}_k) \mathbf {d} = 0 ]]></fr:tex>
Thus, take <fr:em>Newton's direction</fr:em>
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{N}=-\left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}\nabla  f(\mathbf {x}_{k}).]]></fr:tex></fr:p>
    <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>650</fr:anchor><fr:addr
type="machine">#270</fr:addr><fr:route>unstable-270.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  Some notes
    <fr:ul><fr:li><fr:strong>Fast convergence:</fr:strong> Newton's method usually has local quadratic convergence.</fr:li>
      <fr:li><fr:strong>Expensive:</fr:strong> requires storing and inverting <fr:tex
display="inline"><![CDATA[\nabla ^2 f( \mathbf {x})]]></fr:tex>.</fr:li>
      <fr:li><fr:strong>Unstable:</fr:strong> <fr:tex
display="inline"><![CDATA[\nabla ^2 f \succ  0]]></fr:tex> might not hold for general nonlinear problems.</fr:li></fr:ul>
  </fr:mainmatter><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>732</fr:anchor><fr:addr
type="user">kak-004W</fr:addr><fr:route>kak-004W.xml</fr:route><fr:title
text="Quasi-Newton's Method">Quasi-Newton's Method</fr:title><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Get around computing and inverting hessian by using a surrogate i.e. 
<fr:tex
display="block"><![CDATA[\mathbf {d}_{k}^{QN}=-\underbrace {\mathbf {H}_k}_{\text {surrogate for } \left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}} \nabla  f(\mathbf {x}_{k}).]]></fr:tex>
Want
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}^{-1}\cdot \underbrace {({\mathbf {x}}_{k+1}-{\mathbf {x}}_{k})}_{{\mathbf {s}}_{k}}\;=\;\underbrace {\nabla  f({\mathbf {x}}_{k+1})-\nabla  f({\mathbf {x}}_{k})}_{{\mathbf {y}}_{k}}]]></fr:tex>
BFGS rank-2 update:
<fr:tex
display="block"><![CDATA[{\mathbf {H}}_{k+1}\ =\ {\mathbf {H}}_{k}+{\frac {\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}+{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}{\mathbf {y}}_{k}\right ){\mathbf {s}}_{k}{\mathbf {s}}_{k}^{\top }}{\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}\right )^{2}}}-{\frac {{\mathbf {H}}_{k}{\mathbf {y}}_{k}{\mathbf {s}}_{k}^{\top }+{\mathbf {s}}_{k}{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}}{{\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}}}]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree>
  </fr:mainmatter><fr:backmatter /></fr:tree>
  

</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2317</fr:anchor><fr:addr
type="user">kak-0004</fr:addr><fr:route>kak-0004.xml</fr:route><fr:title
text="Disk">Disk</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Here are past things of interest that may be of interest in the future. Unfortunately, they are no longer "hot" and have been paged out (hence the name!).</fr:p><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>949</fr:anchor><fr:addr
type="user">kak-0003</fr:addr><fr:route>kak-0003.xml</fr:route><fr:title
text="Notes">Notes</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This will be home to my notes that have graduated from <fr:link
type="local"
href="kak-0015.xml"
addr="kak-0015"
title="Learning">Learning</fr:link> either because they are no longer in development or because I am happy with where they are currently at.</fr:p>
  
    <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>951</fr:anchor><fr:addr
type="machine">#413</fr:addr><fr:route>unstable-413.xml</fr:route><fr:title
text="Old  Notes from Undergrad">Old <fr:tex
display="inline"><![CDATA[\LaTeX ]]></fr:tex> Notes from Undergrad</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
<fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>953</fr:anchor><fr:addr
type="user">algebra</fr:addr><fr:route>algebra.xml</fr:route><fr:title
text="Math 494 Notes">Math 494 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/494-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>955</fr:anchor><fr:addr
type="user">analysis</fr:addr><fr:route>analysis.xml</fr:route><fr:title
text="Math 395 Notes">Math 395 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/395-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>957</fr:anchor><fr:addr
type="user">functional</fr:addr><fr:route>functional.xml</fr:route><fr:title
text="Math 602 Notes">Math 602 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/602-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>959</fr:anchor><fr:addr
type="user">measure</fr:addr><fr:route>measure.xml</fr:route><fr:title
text="Math 597 Notes">Math 597 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/597-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>961</fr:anchor><fr:addr
type="user">kak-004A</fr:addr><fr:route>kak-004A.xml</fr:route><fr:title
text="Old Talks">Old Talks</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>Each semester as part of <fr:link
type="local"
href="leiying.xml"
addr="leiying"
title="Lei Ying">Lei</fr:link>'s group, I am obligated to present a paper / sequence of papers to the group. Here are the slides for these presentations.</fr:p>
  
    <fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>943</fr:anchor><fr:addr
type="machine">#288</fr:addr><fr:route>unstable-288.xml</fr:route><fr:title
text="Previous Group Meeting Talks">Previous Group Meeting Talks</fr:title><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter>
  <fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>944</fr:anchor><fr:addr
type="user">crlr1</fr:addr><fr:route>crlr1.xml</fr:route><fr:title
text="Contrastive Learning as Goal Conditioned RL + Deepseek R1">Contrastive Learning as Goal Conditioned RL + Deepseek R1</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/clrl-r1.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>946</fr:anchor><fr:addr
type="user">rlhf</fr:addr><fr:route>rlhf.xml</fr:route><fr:title
text="Reinforcement Learning from Human Feedback">Reinforcement Learning from Human Feedback</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>30</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">slides/RLHF-Group-Meeting.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree>
</fr:mainmatter><fr:backmatter /></fr:tree>
  
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>962</fr:anchor><fr:addr
type="user">log</fr:addr><fr:route>log.xml</fr:route><fr:title
text="Notebook">Notebook</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p><fr:info>Query returned no results</fr:info></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>963</fr:anchor><fr:addr
type="machine">#412</fr:addr><fr:route>unstable-412.xml</fr:route><fr:title
text="Reading List">Reading List</fr:title><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>29</fr:day></fr:date><fr:authors /></fr:frontmatter><fr:mainmatter><fr:p>I am committing to reading (fairly rigorously) one paper a week. Here I will accumulate my notes and thoughts on each of these papers as I go.</fr:p><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>964</fr:anchor><fr:addr
type="user">touatiLearningOneRepresentation2021</fr:addr><fr:route>touatiLearningOneRepresentation2021.xml</fr:route><fr:title
text="Learning One Representation to Optimize All Rewards">Learning One Representation to Optimize All Rewards</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2021</fr:year><fr:month>10</fr:month></fr:date><fr:authors><fr:author>Ahmed Touati</fr:author><fr:author>Yann Ollivier</fr:author></fr:authors><fr:meta
name="doi">10.48550/arXiv.2103.07945</fr:meta><fr:meta
name="external">https://arxiv.org/abs/2103.07945</fr:meta><fr:meta
name="bibtex"><![CDATA[@misc{touatiLearningOneRepresentation2021,
 title = {Learning {{One Representation}} to {{Optimize All Rewards}}},
 author = {Touati, Ahmed and Ollivier, Yann},
 year = {2021},
 doi = {10.48550/arXiv.2103.07945},
 urldate = {2024-09-18},
 number = {arXiv:2103.07945},
 publisher = {arXiv},
 file = {/home/kellen/Zotero/storage/FN8MPGES/Touati and Ollivier - 2021 - Learning One Representation to Optimize All Rewards.pdf;/home/kellen/Zotero/storage/SXVNRKWC/2103.html},
 keywords = {Computer Science - Artificial Intelligence,Computer Science - Machine Learning,Mathematics - Optimization and Control},
 archiveprefix = {arXiv},
 abstract = {We introduce the forward-backward (FB) representation of the dynamics of a reward-free Markov decision process. It provides explicit near-optimal policies for any reward specified a posteriori. During an unsupervised phase, we use reward-free interactions with the environment to learn two representations via off-the-shelf deep learning methods and temporal difference (TD) learning. In the test phase, a reward representation is estimated either from observations or an explicit reward description (e.g., a target state). The optimal policy for that reward is directly obtained from these representations, with no planning. We assume access to an exploration scheme or replay buffer for the first phase. The corresponding unsupervised loss is well-principled: if training is perfect, the policies obtained are provably optimal for any reward function. With imperfect training, the sub-optimality is proportional to the unsupervised approximation error. The FB representation learns long-range relationships between states and actions, via a predictive occupancy map, without having to synthesize states as in model-based approaches. This is a step towards learning controllable agents in arbitrary black-box stochastic environments. This approach compares well to goal-oriented RL algorithms on discrete and continuous mazes, pixel-based MsPacman, and the FetchReach virtual robot arm. We also illustrate how the agent can immediately adapt to new tasks beyond goal-oriented RL.},
 primaryclass = {cs, math},
 eprint = {2103.07945},
 month = {October}
}]]></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>967</fr:anchor><fr:addr
type="user">nachumOptimalRepresentationLearning2019</fr:addr><fr:route>nachumOptimalRepresentationLearning2019.xml</fr:route><fr:title
text="Near-Optimal Representation Learning for Hierarchical Reinforcement Learning">Near-Optimal Representation Learning for Hierarchical Reinforcement Learning</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2019</fr:year><fr:month>1</fr:month></fr:date><fr:authors><fr:author>Ofir Nachum</fr:author><fr:author>Shixiang Gu</fr:author><fr:author>Honglak Lee</fr:author><fr:author>Sergey Levine</fr:author></fr:authors><fr:meta
name="external">https://arxiv.org/abs/1810.01257</fr:meta><fr:meta
name="bibtex"><![CDATA[@misc{nachumOptimalRepresentationLearning2019,
 title = {Near-{{Optimal Representation Learning}} for {{Hierarchical Reinforcement Learning}}},
 author = {Nachum, Ofir and Gu, Shixiang and Lee, Honglak and Levine, Sergey},
 year = {2019},
 urldate = {2024-11-07},
 number = {arXiv:1810.01257},
 publisher = {arXiv},
 file = {/home/kellen/Zotero/storage/SIK848RC/Nachum et al. - 2019 - Near-Optimal Representation Learning for Hierarchical Reinforcement Learning.pdf},
 keywords = {Computer Science - Artificial Intelligence},
 langid = {english},
 archiveprefix = {arXiv},
 abstract = {We study the problem of representation learning in goal-conditioned hierarchical reinforcement learning. In such hierarchical structures, a higher-level controller solves tasks by iteratively communicating goals which a lower-level policy is trained to reach. Accordingly, the choice of representation -- the mapping of observation space to goal space -- is crucial. To study this problem, we develop a notion of sub-optimality of a representation, defined in terms of expected reward of the optimal hierarchical policy using this representation. We derive expressions which bound the sub-optimality and show how these expressions can be translated to representation learning objectives which may be optimized in practice. Results on a number of difficult continuous-control tasks show that our approach to representation learning yields qualitatively better representations as well as quantitatively better hierarchical policies, compared to existing methods (see videos at https://sites.google.com/view/representation-hrl).},
 primaryclass = {cs},
 eprint = {1810.01257},
 month = {January}
}]]></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree>
  <html:hr
xmlns:html="http://www.w3.org/1999/xhtml" />
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>2318</fr:anchor><fr:addr
type="user">meet</fr:addr><fr:route>meet.xml</fr:route><fr:title
text="Wanna Talk?">Wanna Talk?</fr:title><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>I am currently interested in continual reinforcement learning or more specifically how to learn generalizable representations online. With this, I am currently looking into contrastive / zero-shot / hierarchical RL. If these things sound interesting I would love to talk about your research and potential collaboration opportunities.</fr:p><fr:p>Beyond research, I have a small list of <fr:tex
display="block"><![CDATA[\text {hobbies} \cup  \text {interests} \supseteq  \{\text {lifting}, \text {anime}, \text {NFL}, \text {basketball}\}.]]></fr:tex> If you are a student at <fr:link
type="local"
href="umich.xml"
addr="umich"
title="University of Michigan">University of Michigan</fr:link>, I also have strong opinions / advice on courses.
  <fr:ul><fr:li><fr:link
type="external"
href="https://calendly.com/kellenkk-umich/30min">Schedule a meeting</fr:link>!</fr:li></fr:ul></fr:p><html:div
xmlns:html="http://www.w3.org/1999/xhtml"
style="
      overflow: hidden;
      width: 100%;
      height: 500px;
      position: relative;
    ">
      <html:iframe
src="
        https://calendar.google.com/calendar/embed?height=600&amp;wkst=1&amp;ctz=America%2FNew_York&amp;showPrint=0&amp;showNav=0&amp;showTz=0&amp;showCalendars=0&amp;title=Kellen's%20Calendar&amp;showTitle=0&amp;src=a2VsbGVua2tAdW1pY2guZWR1&amp;src=Y181ZWRiOGU2NTI3MzgzMTVjZWUwNmUyMGEzNzRmNTVlZjE4ODY1MzQwZTg3ODU5MmE1MWI5ZDc5MjYwMTA1ZTIxQGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;src=Y19jYzExODVhYjFlZDA3ZTE1YmViNWMzYjZhZDcwY2M3ZmFkZGI0MWJlZDUyNjlhZjM2MWVlM2Q3MDA4NWFlNzk0QGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;src=Y19jODA4NGNjYjQxNzcxOGY4ZWI4ZjViZjE4ODQ0MjFmNzJlYjdkMjU4ODcxOTUwY2RiZDMzNThlZGFjYjY5YWU3QGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;src=Y180MjEzNzVlY2E2MGI5OThhNzJkYjRhMjI4YWY4ZmMyODQ2MGFlOTU2ZDNmMTQ3YzYwMWM4YmViZDVmMzgxM2QxQGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;color=%23039BE5&amp;color=%23F6BF26&amp;color=%237CB342&amp;color=%23C0CA33&amp;color=%23AD1457
      "
style="
          width: 100%;
          height: 100%;
      " />
    </html:div></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3633</fr:anchor><fr:addr
type="user">algebra</fr:addr><fr:route>algebra.xml</fr:route><fr:title
text="Math 494 Notes">Math 494 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/494-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3635</fr:anchor><fr:addr
type="user">analysis</fr:addr><fr:route>analysis.xml</fr:route><fr:title
text="Math 395 Notes">Math 395 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/395-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3637</fr:anchor><fr:addr
type="user">functional</fr:addr><fr:route>functional.xml</fr:route><fr:title
text="Math 602 Notes">Math 602 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/602-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3639</fr:anchor><fr:addr
type="user">measure</fr:addr><fr:route>measure.xml</fr:route><fr:title
text="Math 597 Notes">Math 597 Notes</fr:title><fr:taxon>Reference</fr:taxon><fr:authors><fr:author><fr:link
type="local"
href="kellenkanarios.xml"
addr="kellenkanarios"
title="Kellen Kanarios">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:meta
name="external">notes/597-note.pdf</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>